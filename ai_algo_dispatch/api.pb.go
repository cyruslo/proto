// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

// package 命名使用 {appid}.{version} 的方式, version 形如 v1, v2 ..

package api

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//斗地主请求参数
type DdzParamsReq struct {
	Uid                  string   `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty" validate:"required"`
	Tid                  string   `protobuf:"bytes,2,opt,name=tid,proto3" json:"tid,omitempty" validate:"required"`
	Ids                  string   `protobuf:"bytes,3,opt,name=ids,proto3" json:"ids,omitempty" validate:"required"`
	Order                string   `protobuf:"bytes,4,opt,name=order,proto3" json:"order,omitempty" validate:"required"`
	Role                 string   `protobuf:"bytes,5,opt,name=role,proto3" json:"role,omitempty" validate:"required"`
	Record               string   `protobuf:"bytes,6,opt,name=record,proto3" json:"record,omitempty" validate:"required"`
	Hands                string   `protobuf:"bytes,7,opt,name=hands,proto3" json:"hands,omitempty" validate:"required"`
	UpHands              string   `protobuf:"bytes,8,opt,name=up_hands,json=upHands,proto3" json:"up_hands,omitempty" validate:"required"`
	DownHands            string   `protobuf:"bytes,9,opt,name=down_hands,json=downHands,proto3" json:"down_hands,omitempty" validate:"required"`
	HoldUp               string   `protobuf:"bytes,10,opt,name=hold_up,json=holdUp,proto3" json:"hold_up,omitempty"`
	IsSpecial            string   `protobuf:"bytes,11,opt,name=is_special,json=isSpecial,proto3" json:"is_special,omitempty"`
	Timestamp            int64    `protobuf:"varint,12,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DdzParamsReq) Reset()         { *m = DdzParamsReq{} }
func (m *DdzParamsReq) String() string { return proto.CompactTextString(m) }
func (*DdzParamsReq) ProtoMessage()    {}
func (*DdzParamsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *DdzParamsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DdzParamsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DdzParamsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DdzParamsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DdzParamsReq.Merge(m, src)
}
func (m *DdzParamsReq) XXX_Size() int {
	return m.Size()
}
func (m *DdzParamsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DdzParamsReq.DiscardUnknown(m)
}

var xxx_messageInfo_DdzParamsReq proto.InternalMessageInfo

type DdzResultRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Action               string   `protobuf:"bytes,3,opt,name=action,proto3" json:"action,omitempty"`
	Atype                string   `protobuf:"bytes,4,opt,name=atype,proto3" json:"atype,omitempty"`
	HoldUp               int32    `protobuf:"varint,5,opt,name=hold_up,json=holdUp,proto3" json:"hold_up,omitempty"`
	Time                 float32  `protobuf:"fixed32,6,opt,name=time,proto3" json:"time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DdzResultRsp) Reset()         { *m = DdzResultRsp{} }
func (m *DdzResultRsp) String() string { return proto.CompactTextString(m) }
func (*DdzResultRsp) ProtoMessage()    {}
func (*DdzResultRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *DdzResultRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DdzResultRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DdzResultRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DdzResultRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DdzResultRsp.Merge(m, src)
}
func (m *DdzResultRsp) XXX_Size() int {
	return m.Size()
}
func (m *DdzResultRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_DdzResultRsp.DiscardUnknown(m)
}

var xxx_messageInfo_DdzResultRsp proto.InternalMessageInfo

type DdzBidParamsReq struct {
	Uid                  string   `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty" validate:"required"`
	Tid                  string   `protobuf:"bytes,2,opt,name=tid,proto3" json:"tid,omitempty" validate:"required"`
	Hands                string   `protobuf:"bytes,3,opt,name=hands,proto3" json:"hands,omitempty" validate:"required"`
	Atype                string   `protobuf:"bytes,4,opt,name=atype,proto3" json:"atype,omitempty" validate:"required"`
	Level                int32    `protobuf:"varint,5,opt,name=level,proto3" json:"level,omitempty"`
	IsSpecial            int32    `protobuf:"varint,6,opt,name=is_special,json=isSpecial,proto3" json:"is_special,omitempty"`
	AiNum                int32    `protobuf:"varint,7,opt,name=ai_num,json=aiNum,proto3" json:"ai_num,omitempty" validate:"required"`
	Timestamp            int64    `protobuf:"varint,8,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DdzBidParamsReq) Reset()         { *m = DdzBidParamsReq{} }
func (m *DdzBidParamsReq) String() string { return proto.CompactTextString(m) }
func (*DdzBidParamsReq) ProtoMessage()    {}
func (*DdzBidParamsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *DdzBidParamsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DdzBidParamsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DdzBidParamsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DdzBidParamsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DdzBidParamsReq.Merge(m, src)
}
func (m *DdzBidParamsReq) XXX_Size() int {
	return m.Size()
}
func (m *DdzBidParamsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DdzBidParamsReq.DiscardUnknown(m)
}

var xxx_messageInfo_DdzBidParamsReq proto.InternalMessageInfo

type DdzBidResultRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Action               bool     `protobuf:"varint,3,opt,name=action,proto3" json:"action"`
	Time                 float32  `protobuf:"fixed32,4,opt,name=time,proto3" json:"time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DdzBidResultRsp) Reset()         { *m = DdzBidResultRsp{} }
func (m *DdzBidResultRsp) String() string { return proto.CompactTextString(m) }
func (*DdzBidResultRsp) ProtoMessage()    {}
func (*DdzBidResultRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *DdzBidResultRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DdzBidResultRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DdzBidResultRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DdzBidResultRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DdzBidResultRsp.Merge(m, src)
}
func (m *DdzBidResultRsp) XXX_Size() int {
	return m.Size()
}
func (m *DdzBidResultRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_DdzBidResultRsp.DiscardUnknown(m)
}

var xxx_messageInfo_DdzBidResultRsp proto.InternalMessageInfo

//德州请求参数
type TexaParamsReq struct {
	Tid                  int32                      `protobuf:"varint,1,opt,name=tid,proto3" json:"tid,omitempty"`
	Chair                int32                      `protobuf:"varint,2,opt,name=chair,proto3" json:"chair"`
	Sb                   []int64                    `protobuf:"varint,3,rep,packed,name=sb,proto3" json:"sb"`
	Dealer               int32                      `protobuf:"varint,4,opt,name=dealer,proto3" json:"dealer"`
	Users                map[string]*TexaUserDetail `protobuf:"bytes,5,rep,name=users,proto3" json:"users,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Cid                  string                     `protobuf:"bytes,6,opt,name=cid,proto3" json:"cid,omitempty"`
	Hands                []int32                    `protobuf:"varint,7,rep,packed,name=hands,proto3" json:"hands,omitempty"`
	Money                float64                    `protobuf:"fixed64,8,opt,name=money,proto3" json:"money"`
	Stage                string                     `protobuf:"bytes,9,opt,name=stage,proto3" json:"stage,omitempty"`
	Commons              []int32                    `protobuf:"varint,10,rep,packed,name=commons,proto3" json:"commons"`
	Record               *TexaRecord                `protobuf:"bytes,11,opt,name=record,proto3" json:"record,omitempty"`
	Timestamp            int64                      `protobuf:"varint,12,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Style                int32                      `protobuf:"varint,13,opt,name=style,proto3" json:"style,omitempty"`
	Level                string                     `protobuf:"bytes,14,opt,name=level,proto3" json:"level,omitempty"`
	Online               int32                      `protobuf:"varint,15,opt,name=online,proto3" json:"online,omitempty"`
	SbCid                string                     `protobuf:"bytes,16,opt,name=sbCid,proto3" json:"sbCid,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TexaParamsReq) Reset()         { *m = TexaParamsReq{} }
func (m *TexaParamsReq) String() string { return proto.CompactTextString(m) }
func (*TexaParamsReq) ProtoMessage()    {}
func (*TexaParamsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *TexaParamsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TexaParamsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TexaParamsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TexaParamsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TexaParamsReq.Merge(m, src)
}
func (m *TexaParamsReq) XXX_Size() int {
	return m.Size()
}
func (m *TexaParamsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TexaParamsReq.DiscardUnknown(m)
}

var xxx_messageInfo_TexaParamsReq proto.InternalMessageInfo

type TexaUserDetail struct {
	Pid                  int64    `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Hands                []int32  `protobuf:"varint,3,rep,packed,name=hands,proto3" json:"hands,omitempty"`
	Chips                int64    `protobuf:"varint,4,opt,name=chips,proto3" json:"chips"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TexaUserDetail) Reset()         { *m = TexaUserDetail{} }
func (m *TexaUserDetail) String() string { return proto.CompactTextString(m) }
func (*TexaUserDetail) ProtoMessage()    {}
func (*TexaUserDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *TexaUserDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TexaUserDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TexaUserDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TexaUserDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TexaUserDetail.Merge(m, src)
}
func (m *TexaUserDetail) XXX_Size() int {
	return m.Size()
}
func (m *TexaUserDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_TexaUserDetail.DiscardUnknown(m)
}

var xxx_messageInfo_TexaUserDetail proto.InternalMessageInfo

type TexaRecord struct {
	Preflop              []*TexaUserAction `protobuf:"bytes,1,rep,name=preflop,proto3" json:"preflop,omitempty"`
	Flop                 []*TexaUserAction `protobuf:"bytes,2,rep,name=flop,proto3" json:"flop,omitempty"`
	Turn                 []*TexaUserAction `protobuf:"bytes,3,rep,name=turn,proto3" json:"turn,omitempty"`
	River                []*TexaUserAction `protobuf:"bytes,4,rep,name=river,proto3" json:"river,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TexaRecord) Reset()         { *m = TexaRecord{} }
func (m *TexaRecord) String() string { return proto.CompactTextString(m) }
func (*TexaRecord) ProtoMessage()    {}
func (*TexaRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *TexaRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TexaRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TexaRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TexaRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TexaRecord.Merge(m, src)
}
func (m *TexaRecord) XXX_Size() int {
	return m.Size()
}
func (m *TexaRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_TexaRecord.DiscardUnknown(m)
}

var xxx_messageInfo_TexaRecord proto.InternalMessageInfo

type TexaUserAction struct {
	Cid                  string   `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
	Action               int32    `protobuf:"varint,2,opt,name=action,proto3" json:"action"`
	Bet                  int64    `protobuf:"varint,3,opt,name=bet,proto3" json:"bet"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TexaUserAction) Reset()         { *m = TexaUserAction{} }
func (m *TexaUserAction) String() string { return proto.CompactTextString(m) }
func (*TexaUserAction) ProtoMessage()    {}
func (*TexaUserAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *TexaUserAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TexaUserAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TexaUserAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TexaUserAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TexaUserAction.Merge(m, src)
}
func (m *TexaUserAction) XXX_Size() int {
	return m.Size()
}
func (m *TexaUserAction) XXX_DiscardUnknown() {
	xxx_messageInfo_TexaUserAction.DiscardUnknown(m)
}

var xxx_messageInfo_TexaUserAction proto.InternalMessageInfo

type TexaResultRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Action               int32    `protobuf:"varint,3,opt,name=action,proto3" json:"action,omitempty"`
	Bets                 float64  `protobuf:"fixed64,4,opt,name=bets,proto3" json:"bets,omitempty"`
	Time                 float32  `protobuf:"fixed32,5,opt,name=time,proto3" json:"time,omitempty"`
	Tid                  int32    `protobuf:"varint,6,opt,name=tid,proto3" json:"tid,omitempty"`
	Cid                  string   `protobuf:"bytes,7,opt,name=cid,proto3" json:"cid,omitempty"`
	Level                string   `protobuf:"bytes,8,opt,name=level,proto3" json:"level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TexaResultRsp) Reset()         { *m = TexaResultRsp{} }
func (m *TexaResultRsp) String() string { return proto.CompactTextString(m) }
func (*TexaResultRsp) ProtoMessage()    {}
func (*TexaResultRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *TexaResultRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TexaResultRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TexaResultRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TexaResultRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TexaResultRsp.Merge(m, src)
}
func (m *TexaResultRsp) XXX_Size() int {
	return m.Size()
}
func (m *TexaResultRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_TexaResultRsp.DiscardUnknown(m)
}

var xxx_messageInfo_TexaResultRsp proto.InternalMessageInfo

type DaXuanUserInfo struct {
	PosIdx               int32    `protobuf:"varint,1,opt,name=pos_idx,json=posIdx,proto3" json:"pos_idx,omitempty"`
	CurrentBet           int32    `protobuf:"varint,2,opt,name=current_bet,json=currentBet,proto3" json:"current_bet,omitempty"`
	PreviousBet          int32    `protobuf:"varint,3,opt,name=previous_bet,json=previousBet,proto3" json:"previous_bet,omitempty"`
	HandCards            string   `protobuf:"bytes,4,opt,name=hand_cards,json=handCards,proto3" json:"hand_cards,omitempty"`
	Mango                int32    `protobuf:"varint,5,opt,name=mango,proto3" json:"mango,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaXuanUserInfo) Reset()         { *m = DaXuanUserInfo{} }
func (m *DaXuanUserInfo) String() string { return proto.CompactTextString(m) }
func (*DaXuanUserInfo) ProtoMessage()    {}
func (*DaXuanUserInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *DaXuanUserInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaXuanUserInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaXuanUserInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaXuanUserInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaXuanUserInfo.Merge(m, src)
}
func (m *DaXuanUserInfo) XXX_Size() int {
	return m.Size()
}
func (m *DaXuanUserInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DaXuanUserInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DaXuanUserInfo proto.InternalMessageInfo

type DaXuanEnvInfo struct {
	StepDealerIdx        int32             `protobuf:"varint,1,opt,name=step_dealer_idx,json=stepDealerIdx,proto3" json:"step_dealer_idx,omitempty"`
	CurrentIdx           int32             `protobuf:"varint,2,opt,name=current_idx,json=currentIdx,proto3" json:"current_idx,omitempty"`
	PlyNum               int32             `protobuf:"varint,3,opt,name=ply_num,json=plyNum,proto3" json:"ply_num,omitempty"`
	OptList              string            `protobuf:"bytes,4,opt,name=opt_list,json=optList,proto3" json:"opt_list,omitempty"`
	UserInfo             []*DaXuanUserInfo `protobuf:"bytes,5,rep,name=user_info,json=userInfo,proto3" json:"user_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DaXuanEnvInfo) Reset()         { *m = DaXuanEnvInfo{} }
func (m *DaXuanEnvInfo) String() string { return proto.CompactTextString(m) }
func (*DaXuanEnvInfo) ProtoMessage()    {}
func (*DaXuanEnvInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *DaXuanEnvInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaXuanEnvInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaXuanEnvInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaXuanEnvInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaXuanEnvInfo.Merge(m, src)
}
func (m *DaXuanEnvInfo) XXX_Size() int {
	return m.Size()
}
func (m *DaXuanEnvInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DaXuanEnvInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DaXuanEnvInfo proto.InternalMessageInfo

//打旋请求参数
type DaXuanParamsReq struct {
	Uid                  int64          `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" validate:"required"`
	Tid                  int32          `protobuf:"varint,2,opt,name=tid,proto3" json:"tid,omitempty" validate:"required"`
	Timestamp            int64          `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	TagAIEnvInfo         *DaXuanEnvInfo `protobuf:"bytes,4,opt,name=TagAIEnvInfo,proto3" json:"TagAIEnvInfo,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DaXuanParamsReq) Reset()         { *m = DaXuanParamsReq{} }
func (m *DaXuanParamsReq) String() string { return proto.CompactTextString(m) }
func (*DaXuanParamsReq) ProtoMessage()    {}
func (*DaXuanParamsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *DaXuanParamsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaXuanParamsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaXuanParamsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaXuanParamsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaXuanParamsReq.Merge(m, src)
}
func (m *DaXuanParamsReq) XXX_Size() int {
	return m.Size()
}
func (m *DaXuanParamsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DaXuanParamsReq.DiscardUnknown(m)
}

var xxx_messageInfo_DaXuanParamsReq proto.InternalMessageInfo

type DaXuanResultRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Action               int32    `protobuf:"varint,3,opt,name=action,proto3" json:"action,omitempty"`
	Head                 string   `protobuf:"bytes,4,opt,name=head,proto3" json:"head,omitempty"`
	Tail                 string   `protobuf:"bytes,5,opt,name=tail,proto3" json:"tail,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaXuanResultRsp) Reset()         { *m = DaXuanResultRsp{} }
func (m *DaXuanResultRsp) String() string { return proto.CompactTextString(m) }
func (*DaXuanResultRsp) ProtoMessage()    {}
func (*DaXuanResultRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *DaXuanResultRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaXuanResultRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaXuanResultRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaXuanResultRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaXuanResultRsp.Merge(m, src)
}
func (m *DaXuanResultRsp) XXX_Size() int {
	return m.Size()
}
func (m *DaXuanResultRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_DaXuanResultRsp.DiscardUnknown(m)
}

var xxx_messageInfo_DaXuanResultRsp proto.InternalMessageInfo

func init() {
	proto.RegisterType((*DdzParamsReq)(nil), "ai_algo_dispatch.service.v1.DdzParamsReq")
	proto.RegisterType((*DdzResultRsp)(nil), "ai_algo_dispatch.service.v1.DdzResultRsp")
	proto.RegisterType((*DdzBidParamsReq)(nil), "ai_algo_dispatch.service.v1.DdzBidParamsReq")
	proto.RegisterType((*DdzBidResultRsp)(nil), "ai_algo_dispatch.service.v1.DdzBidResultRsp")
	proto.RegisterType((*TexaParamsReq)(nil), "ai_algo_dispatch.service.v1.TexaParamsReq")
	proto.RegisterMapType((map[string]*TexaUserDetail)(nil), "ai_algo_dispatch.service.v1.TexaParamsReq.UsersEntry")
	proto.RegisterType((*TexaUserDetail)(nil), "ai_algo_dispatch.service.v1.TexaUserDetail")
	proto.RegisterType((*TexaRecord)(nil), "ai_algo_dispatch.service.v1.TexaRecord")
	proto.RegisterType((*TexaUserAction)(nil), "ai_algo_dispatch.service.v1.TexaUserAction")
	proto.RegisterType((*TexaResultRsp)(nil), "ai_algo_dispatch.service.v1.TexaResultRsp")
	proto.RegisterType((*DaXuanUserInfo)(nil), "ai_algo_dispatch.service.v1.DaXuanUserInfo")
	proto.RegisterType((*DaXuanEnvInfo)(nil), "ai_algo_dispatch.service.v1.DaXuanEnvInfo")
	proto.RegisterType((*DaXuanParamsReq)(nil), "ai_algo_dispatch.service.v1.DaXuanParamsReq")
	proto.RegisterType((*DaXuanResultRsp)(nil), "ai_algo_dispatch.service.v1.DaXuanResultRsp")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 1379 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xcf, 0x8f, 0xdb, 0xc4,
	0x17, 0xaf, 0xe3, 0x38, 0xd9, 0xbc, 0xec, 0x8f, 0x6a, 0xbe, 0xfd, 0x6e, 0xdd, 0xd0, 0x6e, 0x16,
	0x4b, 0xc0, 0xb6, 0xa5, 0x89, 0x58, 0x04, 0x42, 0xbd, 0x54, 0x9b, 0xa6, 0x52, 0x2b, 0x10, 0x42,
	0x43, 0x2b, 0x21, 0x2e, 0xd6, 0x24, 0x33, 0x9b, 0x8c, 0x70, 0x3c, 0xae, 0xc7, 0x4e, 0x37, 0x7b,
	0x00, 0x89, 0x03, 0x37, 0x4e, 0x20, 0xd1, 0x33, 0x67, 0xee, 0xfc, 0x0b, 0x3d, 0x22, 0x21, 0x71,
	0x5c, 0x41, 0xe1, 0xb4, 0x07, 0x24, 0xf8, 0x0b, 0xd0, 0xcc, 0xd8, 0xeb, 0x24, 0x94, 0x24, 0x45,
	0xf4, 0xb2, 0x99, 0xf7, 0xfc, 0xde, 0xf3, 0xe7, 0xbd, 0xcf, 0x7b, 0xcf, 0xb3, 0x50, 0x23, 0x11,
	0x6f, 0x45, 0xb1, 0x48, 0x04, 0x7a, 0x89, 0x70, 0x9f, 0x04, 0x03, 0xe1, 0x53, 0x2e, 0x23, 0x92,
	0xf4, 0x87, 0x2d, 0xc9, 0xe2, 0x31, 0xef, 0xb3, 0xd6, 0xf8, 0x8d, 0xc6, 0x8d, 0x01, 0x4f, 0x86,
	0x69, 0xaf, 0xd5, 0x17, 0xa3, 0xf6, 0x40, 0x0c, 0x44, 0x5b, 0xfb, 0xf4, 0xd2, 0x43, 0x2d, 0x69,
	0x41, 0x9f, 0x4c, 0xac, 0xc6, 0xe5, 0x81, 0x10, 0x83, 0x80, 0xb5, 0x49, 0xc4, 0xdb, 0x24, 0x0c,
	0x45, 0x42, 0x12, 0x2e, 0x42, 0x69, 0x9e, 0x7a, 0x5f, 0x96, 0x61, 0xbd, 0x4b, 0x8f, 0x3f, 0x20,
	0x31, 0x19, 0x49, 0xcc, 0x1e, 0xa2, 0xab, 0x60, 0xa7, 0x9c, 0xba, 0xd6, 0xae, 0xb5, 0x57, 0xeb,
	0x5c, 0xfc, 0xf3, 0xa4, 0xf9, 0xbf, 0x31, 0x09, 0x38, 0x25, 0x09, 0xbb, 0xe9, 0xc5, 0xec, 0x61,
	0xca, 0x63, 0x46, 0x3d, 0xac, 0x6c, 0x94, 0x69, 0xc2, 0xa9, 0x5b, 0x5a, 0x62, 0x9a, 0x18, 0x53,
	0x4e, 0xa5, 0x6b, 0x2f, 0x31, 0xe5, 0x54, 0xa2, 0x1b, 0xe0, 0x88, 0x98, 0xb2, 0xd8, 0x2d, 0x2f,
	0x36, 0x36, 0x56, 0xe8, 0x3a, 0x94, 0x63, 0x11, 0x30, 0xd7, 0x59, 0x6c, 0xad, 0x8d, 0x50, 0x1b,
	0x2a, 0x31, 0xeb, 0x8b, 0x98, 0xba, 0x95, 0xc5, 0xe6, 0x99, 0x99, 0x02, 0x33, 0x24, 0x21, 0x95,
	0x6e, 0x75, 0x09, 0x18, 0x6d, 0x85, 0xf6, 0x61, 0x2d, 0x8d, 0x7c, 0xe3, 0xb1, 0xb6, 0xd8, 0xa3,
	0x9a, 0x46, 0x77, 0xb5, 0xcf, 0xdb, 0x00, 0x54, 0x3c, 0x0a, 0x33, 0xaf, 0xda, 0x62, 0xaf, 0x9a,
	0x32, 0x35, 0x7e, 0x17, 0xa1, 0x3a, 0x14, 0x01, 0xf5, 0xd3, 0xc8, 0x05, 0xe5, 0x84, 0x2b, 0x4a,
	0x7c, 0x10, 0xa1, 0x2b, 0x00, 0x5c, 0xfa, 0x32, 0x62, 0x7d, 0x4e, 0x02, 0xb7, 0xae, 0x9f, 0xd5,
	0xb8, 0xfc, 0xd0, 0x28, 0xd0, 0x65, 0xa8, 0x25, 0x7c, 0xc4, 0x64, 0x42, 0x46, 0x91, 0xbb, 0xbe,
	0x6b, 0xed, 0xd9, 0xb8, 0x50, 0x78, 0xdf, 0x58, 0xba, 0x1f, 0x30, 0x93, 0x69, 0x90, 0x60, 0x19,
	0x21, 0x04, 0xe5, 0xbe, 0xa0, 0x4c, 0x37, 0x84, 0x83, 0xf5, 0x19, 0xb9, 0x50, 0x1d, 0x31, 0x29,
	0xc9, 0x80, 0x19, 0xf2, 0x71, 0x2e, 0xa2, 0x6d, 0xa8, 0x90, 0xbe, 0xea, 0x2f, 0x43, 0x35, 0xce,
	0x24, 0x74, 0x01, 0x1c, 0x92, 0x4c, 0x22, 0x66, 0x48, 0xc5, 0x46, 0x98, 0x4e, 0xc1, 0xd1, 0xe1,
	0xf3, 0x14, 0x10, 0x94, 0x15, 0x24, 0xcd, 0x52, 0x09, 0xeb, 0xb3, 0xf7, 0xa4, 0x04, 0x5b, 0x5d,
	0x7a, 0xdc, 0xe1, 0xf4, 0x45, 0x37, 0xeb, 0x19, 0xe9, 0xf6, 0x4a, 0xa4, 0xdf, 0x98, 0xc9, 0x6d,
	0x81, 0xb9, 0x49, 0xfa, 0x02, 0x38, 0x01, 0x1b, 0xb3, 0x20, 0x4b, 0xd9, 0x08, 0x73, 0xa4, 0x55,
	0xf4, 0xa3, 0x29, 0xd2, 0x5a, 0x50, 0x21, 0xdc, 0x0f, 0xd3, 0x91, 0x6e, 0x44, 0x67, 0xd1, 0x4b,
	0xf8, 0xfb, 0xe9, 0x68, 0x96, 0xe4, 0xb5, 0x79, 0x92, 0x1f, 0xe5, 0x95, 0xfc, 0xb7, 0x34, 0x7b,
	0x33, 0x34, 0xaf, 0x75, 0xe0, 0xf4, 0xa4, 0x99, 0x69, 0xce, 0x28, 0xcf, 0x39, 0x2c, 0x4f, 0x71,
	0xf8, 0x47, 0x19, 0x36, 0xee, 0xb3, 0x23, 0x52, 0x30, 0x78, 0xde, 0xd0, 0x62, 0x5e, 0xab, 0xab,
	0xdf, 0x04, 0xa7, 0x3f, 0x24, 0x3c, 0xd6, 0xef, 0x74, 0x3a, 0xb5, 0xd3, 0x93, 0xa6, 0x51, 0x60,
	0xf3, 0x83, 0xb6, 0xa1, 0x24, 0x7b, 0xae, 0xbd, 0x6b, 0xef, 0xd9, 0x9d, 0xca, 0xe9, 0x49, 0xb3,
	0x24, 0x7b, 0xb8, 0x24, 0x7b, 0x0a, 0x14, 0x65, 0x24, 0xc8, 0x36, 0x87, 0x63, 0x40, 0x19, 0x0d,
	0xce, 0x7e, 0xd1, 0xbb, 0xe0, 0xa4, 0x92, 0xc5, 0xd2, 0x75, 0x76, 0xed, 0xbd, 0xfa, 0xfe, 0x5b,
	0xad, 0x05, 0x8b, 0xb6, 0x35, 0x83, 0xb4, 0xf5, 0x40, 0xf9, 0xdd, 0x09, 0x93, 0x78, 0x82, 0x4d,
	0x0c, 0x85, 0xbd, 0xcf, 0xb3, 0x55, 0x82, 0xd5, 0x51, 0x71, 0x9b, 0xaf, 0x0b, 0x5b, 0x71, 0x6b,
	0x1a, 0xa4, 0x09, 0xce, 0x48, 0x84, 0x6c, 0xa2, 0x89, 0xb0, 0x4c, 0x46, 0x5a, 0x81, 0xcd, 0x8f,
	0x72, 0x93, 0x89, 0x2a, 0x73, 0xcd, 0x4c, 0x87, 0x16, 0xd0, 0x2b, 0x50, 0xed, 0x8b, 0xd1, 0x48,
	0x84, 0xd2, 0x05, 0x15, 0xae, 0x53, 0x3f, 0x3d, 0x69, 0xe6, 0x2a, 0x9c, 0x1f, 0xd0, 0xad, 0xb3,
	0x9d, 0xa6, 0x46, 0xbd, 0xbe, 0xff, 0xda, 0xd2, 0x9c, 0xb0, 0x36, 0x3f, 0xdb, 0x71, 0x0b, 0x17,
	0x82, 0xc1, 0x36, 0x09, 0x98, 0xbb, 0x61, 0xda, 0x55, 0x0b, 0x45, 0x13, 0x6f, 0x1a, 0xc4, 0xa6,
	0x89, 0xb7, 0xa1, 0x22, 0xc2, 0x80, 0x87, 0xcc, 0xdd, 0x32, 0xe3, 0x6c, 0x24, 0x1d, 0xa3, 0x77,
	0x9b, 0x53, 0xf7, 0x7c, 0x96, 0x9f, 0x12, 0x1a, 0x0c, 0xa0, 0xa8, 0xa9, 0x2a, 0xe6, 0x27, 0x6c,
	0x62, 0x46, 0x19, 0xab, 0x23, 0x3a, 0x00, 0x67, 0x4c, 0x82, 0xd4, 0x34, 0x5f, 0x7d, 0xff, 0xfa,
	0xd2, 0xbc, 0x54, 0xb4, 0x2e, 0x4b, 0x08, 0x0f, 0xb0, 0xf1, 0xbc, 0x59, 0x7a, 0xc7, 0xf2, 0x46,
	0xb0, 0x39, 0xfb, 0x50, 0xbd, 0x2a, 0xca, 0x7a, 0xce, 0xc6, 0xea, 0xa8, 0x7a, 0x35, 0x24, 0xa3,
	0xbc, 0xcd, 0xf5, 0xb9, 0xe0, 0xd2, 0x9e, 0xe3, 0xb2, 0x3f, 0xe4, 0x91, 0xd4, 0x3d, 0x66, 0xe7,
	0xdd, 0xc9, 0x23, 0x89, 0xcd, 0x8f, 0xf7, 0xb8, 0x04, 0x50, 0x14, 0x19, 0xdd, 0x81, 0x6a, 0x14,
	0xb3, 0xc3, 0x40, 0x44, 0xae, 0xa5, 0x5b, 0x6e, 0xb5, 0x34, 0x0e, 0xcc, 0x2c, 0xe5, 0xbe, 0xe8,
	0x16, 0x94, 0x75, 0x8c, 0xd2, 0xf3, 0xc7, 0x28, 0xe7, 0x01, 0x92, 0x34, 0x0e, 0x75, 0x32, 0xcf,
	0x1b, 0x40, 0x39, 0x2a, 0x36, 0x62, 0x3e, 0xd6, 0xc3, 0xf5, 0xdc, 0x11, 0x8c, 0xa7, 0x47, 0x0a,
	0x26, 0xcc, 0x83, 0x7c, 0x82, 0xac, 0x62, 0x82, 0x8a, 0xcd, 0x52, 0x2a, 0x86, 0x78, 0x6e, 0xb3,
	0x5c, 0x02, 0xbb, 0xc7, 0x12, 0xbd, 0x7a, 0xec, 0x4e, 0xf5, 0xf4, 0xa4, 0xa9, 0x44, 0xac, 0xfe,
	0x78, 0xdf, 0x5b, 0x66, 0xc1, 0xfc, 0x37, 0xdf, 0x2f, 0x67, 0x7a, 0x99, 0xf5, 0x58, 0x62, 0x58,
	0xb7, 0xb0, 0x3e, 0x9f, 0x2d, 0x38, 0xa7, 0x58, 0x70, 0xf9, 0x3a, 0xab, 0x14, 0xeb, 0x2c, 0x4b,
	0xb1, 0x3a, 0xb3, 0x24, 0xcc, 0xec, 0xac, 0x4d, 0xcd, 0x8e, 0xf7, 0xad, 0x05, 0x9b, 0x5d, 0xf2,
	0x51, 0x4a, 0x42, 0x55, 0x9f, 0x7b, 0xe1, 0xa1, 0x50, 0x9f, 0xc7, 0x48, 0x48, 0x9f, 0xd3, 0xa3,
	0x0c, 0x7d, 0x25, 0x12, 0xf2, 0x1e, 0x3d, 0x42, 0x4d, 0xa8, 0xf7, 0xd3, 0x38, 0x66, 0x61, 0xe2,
	0xab, 0x42, 0xe8, 0x4a, 0x61, 0xc8, 0x54, 0x1d, 0x96, 0xa0, 0x97, 0x61, 0x3d, 0x8a, 0xd9, 0x98,
	0x8b, 0x54, 0xfa, 0x79, 0xa9, 0x1c, 0x5c, 0xcf, 0x75, 0xca, 0xe4, 0x0a, 0x80, 0xea, 0x68, 0xbf,
	0x4f, 0x62, 0x2a, 0xb3, 0xcf, 0x72, 0x4d, 0x69, 0x6e, 0x2b, 0x85, 0x02, 0x39, 0x22, 0xe1, 0x40,
	0xe4, 0x5f, 0x29, 0x2d, 0x78, 0x3f, 0x59, 0xb0, 0x61, 0x40, 0xde, 0x09, 0xc7, 0x1a, 0xe3, 0xab,
	0xb0, 0x25, 0x13, 0x16, 0xf9, 0x66, 0xbf, 0x4e, 0x61, 0xdd, 0x50, 0xea, 0xae, 0xd6, 0xce, 0x41,
	0x56, 0x36, 0xb3, 0x90, 0x95, 0x81, 0x4a, 0x36, 0x98, 0xe8, 0x4f, 0x5c, 0x56, 0xfa, 0x28, 0x98,
	0xa8, 0x4f, 0xd9, 0x25, 0x58, 0x13, 0x51, 0xe2, 0x07, 0x5c, 0x26, 0x19, 0xcc, 0xaa, 0x88, 0x92,
	0xf7, 0xb8, 0x4c, 0xd0, 0x5d, 0xa8, 0xa9, 0x4d, 0xec, 0xf3, 0xf0, 0x50, 0x64, 0x1b, 0x7d, 0x71,
	0x5f, 0xce, 0x16, 0x18, 0xaf, 0xa5, 0xd9, 0xc9, 0xfb, 0xdd, 0x82, 0x2d, 0xf3, 0xf0, 0x99, 0x97,
	0x0b, 0x7b, 0xf5, 0xcb, 0x85, 0xb3, 0xe4, 0x72, 0x31, 0xb3, 0x6d, 0xed, 0xf9, 0x6d, 0x3b, 0x80,
	0xf5, 0xfb, 0x64, 0x70, 0x70, 0x2f, 0x2b, 0xaf, 0x4e, 0xb8, 0xbe, 0x7f, 0x6d, 0x85, 0xa4, 0x32,
	0x8f, 0x7f, 0x7e, 0xfb, 0x4c, 0x60, 0xef, 0xb3, 0x3c, 0xdf, 0x17, 0x30, 0x29, 0x43, 0x46, 0x68,
	0x46, 0x95, 0x3e, 0xeb, 0x49, 0x21, 0xdc, 0xdc, 0x78, 0x6a, 0x58, 0x9f, 0xf7, 0xbf, 0x2b, 0xc3,
	0xe6, 0x01, 0x3f, 0x08, 0x06, 0xa2, 0x9b, 0xe5, 0x84, 0x8e, 0xc1, 0xee, 0xd2, 0x63, 0x74, 0x75,
	0x71, 0xb6, 0x53, 0xff, 0xac, 0x34, 0x96, 0x9a, 0x9e, 0x65, 0xe7, 0x5d, 0xf9, 0xfc, 0xc7, 0xdf,
	0xbe, 0x2a, 0x5d, 0xf4, 0xfe, 0xdf, 0x9e, 0x77, 0x69, 0x53, 0x7a, 0x8c, 0xbe, 0x36, 0xf7, 0xde,
	0x0e, 0xa7, 0xd9, 0x6a, 0x7a, 0x7d, 0x59, 0xe8, 0xe9, 0x8b, 0x68, 0x63, 0x15, 0xeb, 0x02, 0xcb,
	0x9e, 0xc6, 0xe2, 0x79, 0xbb, 0xcf, 0xc4, 0xe2, 0xf7, 0x38, 0xf5, 0xb3, 0x6a, 0x7e, 0x0a, 0x65,
	0xb5, 0xce, 0xd0, 0xb5, 0xd5, 0x2f, 0x2a, 0x8d, 0x6b, 0x2b, 0x5c, 0x00, 0x72, 0x24, 0x3b, 0x1a,
	0x89, 0xeb, 0x6d, 0xff, 0x1d, 0x49, 0xa2, 0xde, 0xfb, 0x85, 0x05, 0x15, 0xd3, 0x27, 0xcb, 0x0a,
	0x32, 0x3b, 0x3c, 0x8d, 0x55, 0xac, 0x0b, 0x18, 0xbb, 0x1a, 0x46, 0xc3, 0x73, 0x9f, 0x51, 0x10,
	0x72, 0x94, 0x92, 0xb0, 0x73, 0xe9, 0xc9, 0x2f, 0x3b, 0xe7, 0x9e, 0x3c, 0xdd, 0xb1, 0x7e, 0x78,
	0xba, 0x63, 0xfd, 0xfc, 0x74, 0xc7, 0x7a, 0xfc, 0xeb, 0xce, 0xb9, 0x8f, 0x6d, 0x12, 0xf1, 0x5e,
	0x45, 0xff, 0x27, 0xfb, 0xe6, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x38, 0x3d, 0xda, 0x0c, 0x40,
	0x0f, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AiAlgoDispatchClient is the client API for AiAlgoDispatch service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AiAlgoDispatchClient interface {
	//斗地主AI
	Ddz(ctx context.Context, in *DdzParamsReq, opts ...grpc.CallOption) (*DdzResultRsp, error)
	//斗地主叫地主请求
	DdzBidAction(ctx context.Context, in *DdzBidParamsReq, opts ...grpc.CallOption) (*DdzBidResultRsp, error)
	//德州
	Texa(ctx context.Context, in *TexaParamsReq, opts ...grpc.CallOption) (*TexaResultRsp, error)
	//打旋AI
	DaXuan(ctx context.Context, in *DaXuanParamsReq, opts ...grpc.CallOption) (*DaXuanResultRsp, error)
}

type aiAlgoDispatchClient struct {
	cc *grpc.ClientConn
}

func NewAiAlgoDispatchClient(cc *grpc.ClientConn) AiAlgoDispatchClient {
	return &aiAlgoDispatchClient{cc}
}

func (c *aiAlgoDispatchClient) Ddz(ctx context.Context, in *DdzParamsReq, opts ...grpc.CallOption) (*DdzResultRsp, error) {
	out := new(DdzResultRsp)
	err := c.cc.Invoke(ctx, "/ai_algo_dispatch.service.v1.AiAlgoDispatch/Ddz", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiAlgoDispatchClient) DdzBidAction(ctx context.Context, in *DdzBidParamsReq, opts ...grpc.CallOption) (*DdzBidResultRsp, error) {
	out := new(DdzBidResultRsp)
	err := c.cc.Invoke(ctx, "/ai_algo_dispatch.service.v1.AiAlgoDispatch/DdzBidAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiAlgoDispatchClient) Texa(ctx context.Context, in *TexaParamsReq, opts ...grpc.CallOption) (*TexaResultRsp, error) {
	out := new(TexaResultRsp)
	err := c.cc.Invoke(ctx, "/ai_algo_dispatch.service.v1.AiAlgoDispatch/Texa", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiAlgoDispatchClient) DaXuan(ctx context.Context, in *DaXuanParamsReq, opts ...grpc.CallOption) (*DaXuanResultRsp, error) {
	out := new(DaXuanResultRsp)
	err := c.cc.Invoke(ctx, "/ai_algo_dispatch.service.v1.AiAlgoDispatch/DaXuan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AiAlgoDispatchServer is the server API for AiAlgoDispatch service.
type AiAlgoDispatchServer interface {
	//斗地主AI
	Ddz(context.Context, *DdzParamsReq) (*DdzResultRsp, error)
	//斗地主叫地主请求
	DdzBidAction(context.Context, *DdzBidParamsReq) (*DdzBidResultRsp, error)
	//德州
	Texa(context.Context, *TexaParamsReq) (*TexaResultRsp, error)
	//打旋AI
	DaXuan(context.Context, *DaXuanParamsReq) (*DaXuanResultRsp, error)
}

// UnimplementedAiAlgoDispatchServer can be embedded to have forward compatible implementations.
type UnimplementedAiAlgoDispatchServer struct {
}

func (*UnimplementedAiAlgoDispatchServer) Ddz(ctx context.Context, req *DdzParamsReq) (*DdzResultRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ddz not implemented")
}
func (*UnimplementedAiAlgoDispatchServer) DdzBidAction(ctx context.Context, req *DdzBidParamsReq) (*DdzBidResultRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DdzBidAction not implemented")
}
func (*UnimplementedAiAlgoDispatchServer) Texa(ctx context.Context, req *TexaParamsReq) (*TexaResultRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Texa not implemented")
}
func (*UnimplementedAiAlgoDispatchServer) DaXuan(ctx context.Context, req *DaXuanParamsReq) (*DaXuanResultRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DaXuan not implemented")
}

func RegisterAiAlgoDispatchServer(s *grpc.Server, srv AiAlgoDispatchServer) {
	s.RegisterService(&_AiAlgoDispatch_serviceDesc, srv)
}

func _AiAlgoDispatch_Ddz_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DdzParamsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiAlgoDispatchServer).Ddz(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ai_algo_dispatch.service.v1.AiAlgoDispatch/Ddz",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiAlgoDispatchServer).Ddz(ctx, req.(*DdzParamsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiAlgoDispatch_DdzBidAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DdzBidParamsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiAlgoDispatchServer).DdzBidAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ai_algo_dispatch.service.v1.AiAlgoDispatch/DdzBidAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiAlgoDispatchServer).DdzBidAction(ctx, req.(*DdzBidParamsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiAlgoDispatch_Texa_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TexaParamsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiAlgoDispatchServer).Texa(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ai_algo_dispatch.service.v1.AiAlgoDispatch/Texa",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiAlgoDispatchServer).Texa(ctx, req.(*TexaParamsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiAlgoDispatch_DaXuan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DaXuanParamsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiAlgoDispatchServer).DaXuan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ai_algo_dispatch.service.v1.AiAlgoDispatch/DaXuan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiAlgoDispatchServer).DaXuan(ctx, req.(*DaXuanParamsReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _AiAlgoDispatch_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ai_algo_dispatch.service.v1.AiAlgoDispatch",
	HandlerType: (*AiAlgoDispatchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ddz",
			Handler:    _AiAlgoDispatch_Ddz_Handler,
		},
		{
			MethodName: "DdzBidAction",
			Handler:    _AiAlgoDispatch_DdzBidAction_Handler,
		},
		{
			MethodName: "Texa",
			Handler:    _AiAlgoDispatch_Texa_Handler,
		},
		{
			MethodName: "DaXuan",
			Handler:    _AiAlgoDispatch_DaXuan_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *DdzParamsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DdzParamsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DdzParamsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timestamp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x60
	}
	if len(m.IsSpecial) > 0 {
		i -= len(m.IsSpecial)
		copy(dAtA[i:], m.IsSpecial)
		i = encodeVarintApi(dAtA, i, uint64(len(m.IsSpecial)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.HoldUp) > 0 {
		i -= len(m.HoldUp)
		copy(dAtA[i:], m.HoldUp)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HoldUp)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.DownHands) > 0 {
		i -= len(m.DownHands)
		copy(dAtA[i:], m.DownHands)
		i = encodeVarintApi(dAtA, i, uint64(len(m.DownHands)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.UpHands) > 0 {
		i -= len(m.UpHands)
		copy(dAtA[i:], m.UpHands)
		i = encodeVarintApi(dAtA, i, uint64(len(m.UpHands)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Hands) > 0 {
		i -= len(m.Hands)
		copy(dAtA[i:], m.Hands)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Hands)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Record) > 0 {
		i -= len(m.Record)
		copy(dAtA[i:], m.Record)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Record)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Order) > 0 {
		i -= len(m.Order)
		copy(dAtA[i:], m.Order)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Order)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ids) > 0 {
		i -= len(m.Ids)
		copy(dAtA[i:], m.Ids)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ids)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tid) > 0 {
		i -= len(m.Tid)
		copy(dAtA[i:], m.Tid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DdzResultRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DdzResultRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DdzResultRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Time != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i--
		dAtA[i] = 0x35
	}
	if m.HoldUp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.HoldUp))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Atype) > 0 {
		i -= len(m.Atype)
		copy(dAtA[i:], m.Atype)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Atype)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Action) > 0 {
		i -= len(m.Action)
		copy(dAtA[i:], m.Action)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Action)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DdzBidParamsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DdzBidParamsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DdzBidParamsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timestamp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x40
	}
	if m.AiNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AiNum))
		i--
		dAtA[i] = 0x38
	}
	if m.IsSpecial != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.IsSpecial))
		i--
		dAtA[i] = 0x30
	}
	if m.Level != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Atype) > 0 {
		i -= len(m.Atype)
		copy(dAtA[i:], m.Atype)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Atype)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hands) > 0 {
		i -= len(m.Hands)
		copy(dAtA[i:], m.Hands)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Hands)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tid) > 0 {
		i -= len(m.Tid)
		copy(dAtA[i:], m.Tid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DdzBidResultRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DdzBidResultRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DdzBidResultRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Time != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i--
		dAtA[i] = 0x25
	}
	if m.Action {
		i--
		if m.Action {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TexaParamsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TexaParamsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TexaParamsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SbCid) > 0 {
		i -= len(m.SbCid)
		copy(dAtA[i:], m.SbCid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SbCid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Online != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Online))
		i--
		dAtA[i] = 0x78
	}
	if len(m.Level) > 0 {
		i -= len(m.Level)
		copy(dAtA[i:], m.Level)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Level)))
		i--
		dAtA[i] = 0x72
	}
	if m.Style != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x68
	}
	if m.Timestamp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x60
	}
	if m.Record != nil {
		{
			size, err := m.Record.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Commons) > 0 {
		dAtA3 := make([]byte, len(m.Commons)*10)
		var j2 int
		for _, num1 := range m.Commons {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintApi(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Stage) > 0 {
		i -= len(m.Stage)
		copy(dAtA[i:], m.Stage)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Stage)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Money != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Money))))
		i--
		dAtA[i] = 0x41
	}
	if len(m.Hands) > 0 {
		dAtA5 := make([]byte, len(m.Hands)*10)
		var j4 int
		for _, num1 := range m.Hands {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintApi(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Users) > 0 {
		for k := range m.Users {
			v := m.Users[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Dealer != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Dealer))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Sb) > 0 {
		dAtA8 := make([]byte, len(m.Sb)*10)
		var j7 int
		for _, num1 := range m.Sb {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintApi(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x1a
	}
	if m.Chair != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Chair))
		i--
		dAtA[i] = 0x10
	}
	if m.Tid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Tid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TexaUserDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TexaUserDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TexaUserDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Chips != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Chips))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Hands) > 0 {
		dAtA10 := make([]byte, len(m.Hands)*10)
		var j9 int
		for _, num1 := range m.Hands {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintApi(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Pid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TexaRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TexaRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TexaRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.River) > 0 {
		for iNdEx := len(m.River) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.River[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Turn) > 0 {
		for iNdEx := len(m.Turn) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Turn[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Flop) > 0 {
		for iNdEx := len(m.Flop) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Flop[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Preflop) > 0 {
		for iNdEx := len(m.Preflop) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Preflop[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TexaUserAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TexaUserAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TexaUserAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Bet != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Bet))
		i--
		dAtA[i] = 0x18
	}
	if m.Action != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TexaResultRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TexaResultRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TexaResultRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Level) > 0 {
		i -= len(m.Level)
		copy(dAtA[i:], m.Level)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Level)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Tid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Tid))
		i--
		dAtA[i] = 0x30
	}
	if m.Time != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Bets != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Bets))))
		i--
		dAtA[i] = 0x21
	}
	if m.Action != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaXuanUserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaXuanUserInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaXuanUserInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mango != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mango))
		i--
		dAtA[i] = 0x28
	}
	if len(m.HandCards) > 0 {
		i -= len(m.HandCards)
		copy(dAtA[i:], m.HandCards)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HandCards)))
		i--
		dAtA[i] = 0x22
	}
	if m.PreviousBet != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PreviousBet))
		i--
		dAtA[i] = 0x18
	}
	if m.CurrentBet != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CurrentBet))
		i--
		dAtA[i] = 0x10
	}
	if m.PosIdx != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PosIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaXuanEnvInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaXuanEnvInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaXuanEnvInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserInfo) > 0 {
		for iNdEx := len(m.UserInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.OptList) > 0 {
		i -= len(m.OptList)
		copy(dAtA[i:], m.OptList)
		i = encodeVarintApi(dAtA, i, uint64(len(m.OptList)))
		i--
		dAtA[i] = 0x22
	}
	if m.PlyNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlyNum))
		i--
		dAtA[i] = 0x18
	}
	if m.CurrentIdx != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CurrentIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.StepDealerIdx != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StepDealerIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaXuanParamsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaXuanParamsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaXuanParamsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TagAIEnvInfo != nil {
		{
			size, err := m.TagAIEnvInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Timestamp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x18
	}
	if m.Tid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Tid))
		i--
		dAtA[i] = 0x10
	}
	if m.Uid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaXuanResultRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaXuanResultRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaXuanResultRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tail) > 0 {
		i -= len(m.Tail)
		copy(dAtA[i:], m.Tail)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tail)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Head) > 0 {
		i -= len(m.Head)
		copy(dAtA[i:], m.Head)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Head)))
		i--
		dAtA[i] = 0x22
	}
	if m.Action != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DdzParamsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Tid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Ids)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Order)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Record)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Hands)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.UpHands)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DownHands)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.HoldUp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.IsSpecial)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovApi(uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DdzResultRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Atype)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.HoldUp != 0 {
		n += 1 + sovApi(uint64(m.HoldUp))
	}
	if m.Time != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DdzBidParamsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Tid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Hands)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Atype)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovApi(uint64(m.Level))
	}
	if m.IsSpecial != 0 {
		n += 1 + sovApi(uint64(m.IsSpecial))
	}
	if m.AiNum != 0 {
		n += 1 + sovApi(uint64(m.AiNum))
	}
	if m.Timestamp != 0 {
		n += 1 + sovApi(uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DdzBidResultRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Action {
		n += 2
	}
	if m.Time != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TexaParamsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tid != 0 {
		n += 1 + sovApi(uint64(m.Tid))
	}
	if m.Chair != 0 {
		n += 1 + sovApi(uint64(m.Chair))
	}
	if len(m.Sb) > 0 {
		l = 0
		for _, e := range m.Sb {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Dealer != 0 {
		n += 1 + sovApi(uint64(m.Dealer))
	}
	if len(m.Users) > 0 {
		for k, v := range m.Users {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Hands) > 0 {
		l = 0
		for _, e := range m.Hands {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Money != 0 {
		n += 9
	}
	l = len(m.Stage)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Commons) > 0 {
		l = 0
		for _, e := range m.Commons {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Record != nil {
		l = m.Record.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovApi(uint64(m.Timestamp))
	}
	if m.Style != 0 {
		n += 1 + sovApi(uint64(m.Style))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Online != 0 {
		n += 1 + sovApi(uint64(m.Online))
	}
	l = len(m.SbCid)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TexaUserDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pid != 0 {
		n += 1 + sovApi(uint64(m.Pid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Hands) > 0 {
		l = 0
		for _, e := range m.Hands {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Chips != 0 {
		n += 1 + sovApi(uint64(m.Chips))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TexaRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Preflop) > 0 {
		for _, e := range m.Preflop {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Flop) > 0 {
		for _, e := range m.Flop {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Turn) > 0 {
		for _, e := range m.Turn {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.River) > 0 {
		for _, e := range m.River {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TexaUserAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovApi(uint64(m.Action))
	}
	if m.Bet != 0 {
		n += 1 + sovApi(uint64(m.Bet))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TexaResultRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovApi(uint64(m.Action))
	}
	if m.Bets != 0 {
		n += 9
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Tid != 0 {
		n += 1 + sovApi(uint64(m.Tid))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaXuanUserInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PosIdx != 0 {
		n += 1 + sovApi(uint64(m.PosIdx))
	}
	if m.CurrentBet != 0 {
		n += 1 + sovApi(uint64(m.CurrentBet))
	}
	if m.PreviousBet != 0 {
		n += 1 + sovApi(uint64(m.PreviousBet))
	}
	l = len(m.HandCards)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mango != 0 {
		n += 1 + sovApi(uint64(m.Mango))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaXuanEnvInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StepDealerIdx != 0 {
		n += 1 + sovApi(uint64(m.StepDealerIdx))
	}
	if m.CurrentIdx != 0 {
		n += 1 + sovApi(uint64(m.CurrentIdx))
	}
	if m.PlyNum != 0 {
		n += 1 + sovApi(uint64(m.PlyNum))
	}
	l = len(m.OptList)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.UserInfo) > 0 {
		for _, e := range m.UserInfo {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaXuanParamsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.Tid != 0 {
		n += 1 + sovApi(uint64(m.Tid))
	}
	if m.Timestamp != 0 {
		n += 1 + sovApi(uint64(m.Timestamp))
	}
	if m.TagAIEnvInfo != nil {
		l = m.TagAIEnvInfo.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaXuanResultRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovApi(uint64(m.Action))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Tail)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DdzParamsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DdzParamsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DdzParamsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Order = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Record = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hands", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hands = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpHands", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpHands = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownHands", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownHands = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldUp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HoldUp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSpecial", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsSpecial = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DdzResultRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DdzResultRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DdzResultRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Atype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldUp", wireType)
			}
			m.HoldUp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldUp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DdzBidParamsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DdzBidParamsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DdzBidParamsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hands", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hands = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Atype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSpecial", wireType)
			}
			m.IsSpecial = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsSpecial |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AiNum", wireType)
			}
			m.AiNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AiNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DdzBidResultRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DdzBidResultRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DdzBidResultRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Action = bool(v != 0)
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TexaParamsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TexaParamsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TexaParamsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chair", wireType)
			}
			m.Chair = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chair |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sb = append(m.Sb, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Sb) == 0 {
					m.Sb = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sb = append(m.Sb, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sb", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dealer", wireType)
			}
			m.Dealer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dealer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Users == nil {
				m.Users = make(map[string]*TexaUserDetail)
			}
			var mapkey string
			var mapvalue *TexaUserDetail
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TexaUserDetail{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Users[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Hands = append(m.Hands, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Hands) == 0 {
					m.Hands = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Hands = append(m.Hands, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Hands", wireType)
			}
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Money = float64(math.Float64frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Commons = append(m.Commons, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Commons) == 0 {
					m.Commons = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Commons = append(m.Commons, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Commons", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Record == nil {
				m.Record = &TexaRecord{}
			}
			if err := m.Record.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			m.Online = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Online |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SbCid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SbCid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TexaUserDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TexaUserDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TexaUserDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Hands = append(m.Hands, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Hands) == 0 {
					m.Hands = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Hands = append(m.Hands, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Hands", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chips", wireType)
			}
			m.Chips = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chips |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TexaRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TexaRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TexaRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preflop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Preflop = append(m.Preflop, &TexaUserAction{})
			if err := m.Preflop[len(m.Preflop)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flop = append(m.Flop, &TexaUserAction{})
			if err := m.Flop[len(m.Flop)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Turn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Turn = append(m.Turn, &TexaUserAction{})
			if err := m.Turn[len(m.Turn)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field River", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.River = append(m.River, &TexaUserAction{})
			if err := m.River[len(m.River)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TexaUserAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TexaUserAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TexaUserAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TexaResultRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TexaResultRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TexaResultRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bets", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Bets = float64(math.Float64frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaXuanUserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaXuanUserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaXuanUserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosIdx", wireType)
			}
			m.PosIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PosIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBet", wireType)
			}
			m.CurrentBet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentBet |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousBet", wireType)
			}
			m.PreviousBet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreviousBet |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandCards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HandCards = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mango", wireType)
			}
			m.Mango = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mango |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaXuanEnvInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaXuanEnvInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaXuanEnvInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepDealerIdx", wireType)
			}
			m.StepDealerIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepDealerIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentIdx", wireType)
			}
			m.CurrentIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlyNum", wireType)
			}
			m.PlyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlyNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptList = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserInfo = append(m.UserInfo, &DaXuanUserInfo{})
			if err := m.UserInfo[len(m.UserInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaXuanParamsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaXuanParamsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaXuanParamsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagAIEnvInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TagAIEnvInfo == nil {
				m.TagAIEnvInfo = &DaXuanEnvInfo{}
			}
			if err := m.TagAIEnvInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaXuanResultRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaXuanResultRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaXuanResultRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
