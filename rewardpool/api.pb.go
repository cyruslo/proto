// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

// package 命名使用 {appid}.{version} 的方式, version 形如 v1, v2 ..

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PoolTypeCode int32

const (
	PoolTypeCode_PoolTypeDefault PoolTypeCode = 0
	PoolTypeCode_PoolA           PoolTypeCode = 1
	PoolTypeCode_PoolB           PoolTypeCode = 2
)

var PoolTypeCode_name = map[int32]string{
	0: "PoolTypeDefault",
	1: "PoolA",
	2: "PoolB",
}

var PoolTypeCode_value = map[string]int32{
	"PoolTypeDefault": 0,
	"PoolA":           1,
	"PoolB":           2,
}

func (x PoolTypeCode) String() string {
	return proto.EnumName(PoolTypeCode_name, int32(x))
}

func (PoolTypeCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

type PoolIDCode int32

const (
	PoolIDCode_PoolHundred  PoolIDCode = 0
	PoolIDCode_PoolThousand PoolIDCode = 1
	PoolIDCode_PoolBillion  PoolIDCode = 2
)

var PoolIDCode_name = map[int32]string{
	0: "PoolHundred",
	1: "PoolThousand",
	2: "PoolBillion",
}

var PoolIDCode_value = map[string]int32{
	"PoolHundred":  0,
	"PoolThousand": 1,
	"PoolBillion":  2,
}

func (x PoolIDCode) String() string {
	return proto.EnumName(PoolIDCode_name, int32(x))
}

func (PoolIDCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}

type RewardPoolErrCode int32

const (
	RewardPoolErrCode_Success                 RewardPoolErrCode = 0
	RewardPoolErrCode_GetRewardPoolConfigFail RewardPoolErrCode = 1000300
	RewardPoolErrCode_RewardPoolNumOverLimit  RewardPoolErrCode = 1000301
)

var RewardPoolErrCode_name = map[int32]string{
	0:       "Success",
	1000300: "GetRewardPoolConfigFail",
	1000301: "RewardPoolNumOverLimit",
}

var RewardPoolErrCode_value = map[string]int32{
	"Success":                 0,
	"GetRewardPoolConfigFail": 1000300,
	"RewardPoolNumOverLimit":  1000301,
}

func (x RewardPoolErrCode) String() string {
	return proto.EnumName(RewardPoolErrCode_name, int32(x))
}

func (RewardPoolErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}

type CommonResp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code" form:"Code" `
	Msg                  string   `protobuf:"bytes,2,opt,name=Msg,proto3" json:"Msg" form:"Msg" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonResp) Reset()         { *m = CommonResp{} }
func (m *CommonResp) String() string { return proto.CompactTextString(m) }
func (*CommonResp) ProtoMessage()    {}
func (*CommonResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *CommonResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonResp.Merge(m, src)
}
func (m *CommonResp) XXX_Size() int {
	return m.Size()
}
func (m *CommonResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonResp.DiscardUnknown(m)
}

var xxx_messageInfo_CommonResp proto.InternalMessageInfo

type QueryPoolReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,2,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	PoolTypeID           int32    `protobuf:"varint,3,opt,name=PoolTypeID,proto3" json:"PoolTypeID" form:"PoolTypeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryPoolReq) Reset()         { *m = QueryPoolReq{} }
func (m *QueryPoolReq) String() string { return proto.CompactTextString(m) }
func (*QueryPoolReq) ProtoMessage()    {}
func (*QueryPoolReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *QueryPoolReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPoolReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPoolReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPoolReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPoolReq.Merge(m, src)
}
func (m *QueryPoolReq) XXX_Size() int {
	return m.Size()
}
func (m *QueryPoolReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPoolReq.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPoolReq proto.InternalMessageInfo

type QueryPoolRsp struct {
	GameID               int32        `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	ArenaID              int32        `protobuf:"varint,2,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	PoolTypeID           int32        `protobuf:"varint,3,opt,name=PoolTypeID,proto3" json:"PoolTypeID" form:"PoolTypeID"`
	Pools                []*PoolMoney `protobuf:"bytes,4,rep,name=Pools,proto3" json:"Pools" form:"Pools"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *QueryPoolRsp) Reset()         { *m = QueryPoolRsp{} }
func (m *QueryPoolRsp) String() string { return proto.CompactTextString(m) }
func (*QueryPoolRsp) ProtoMessage()    {}
func (*QueryPoolRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *QueryPoolRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPoolRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPoolRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPoolRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPoolRsp.Merge(m, src)
}
func (m *QueryPoolRsp) XXX_Size() int {
	return m.Size()
}
func (m *QueryPoolRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPoolRsp.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPoolRsp proto.InternalMessageInfo

type PoolMoney struct {
	PoolID               int32    `protobuf:"varint,1,opt,name=PoolID,proto3" json:"PoolID" form:"PoolID"`
	Delta                int64    `protobuf:"varint,2,opt,name=Delta,proto3" json:"Delta" form:"Delta"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PoolMoney) Reset()         { *m = PoolMoney{} }
func (m *PoolMoney) String() string { return proto.CompactTextString(m) }
func (*PoolMoney) ProtoMessage()    {}
func (*PoolMoney) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *PoolMoney) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolMoney) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolMoney.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolMoney) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolMoney.Merge(m, src)
}
func (m *PoolMoney) XXX_Size() int {
	return m.Size()
}
func (m *PoolMoney) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolMoney.DiscardUnknown(m)
}

var xxx_messageInfo_PoolMoney proto.InternalMessageInfo

type UpdatePoolReq struct {
	GameID               int32        `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	ArenaID              int32        `protobuf:"varint,2,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	PoolTypeID           int32        `protobuf:"varint,3,opt,name=PoolTypeID,proto3" json:"PoolTypeID" form:"PoolTypeID"`
	Pools                []*PoolMoney `protobuf:"bytes,4,rep,name=Pools,proto3" json:"Pools" form:"Pools"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *UpdatePoolReq) Reset()         { *m = UpdatePoolReq{} }
func (m *UpdatePoolReq) String() string { return proto.CompactTextString(m) }
func (*UpdatePoolReq) ProtoMessage()    {}
func (*UpdatePoolReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *UpdatePoolReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdatePoolReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdatePoolReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdatePoolReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdatePoolReq.Merge(m, src)
}
func (m *UpdatePoolReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdatePoolReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdatePoolReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdatePoolReq proto.InternalMessageInfo

type GamePoolMoney struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,2,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	PoolTypeID           int32    `protobuf:"varint,3,opt,name=PoolTypeID,proto3" json:"PoolTypeID" form:"PoolTypeID"`
	PoolID               int32    `protobuf:"varint,4,opt,name=PoolID,proto3" json:"PoolID" form:"PoolID"`
	Money                int64    `protobuf:"varint,5,opt,name=Money,proto3" json:"Money" form:"Money"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GamePoolMoney) Reset()         { *m = GamePoolMoney{} }
func (m *GamePoolMoney) String() string { return proto.CompactTextString(m) }
func (*GamePoolMoney) ProtoMessage()    {}
func (*GamePoolMoney) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *GamePoolMoney) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GamePoolMoney) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GamePoolMoney.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GamePoolMoney) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GamePoolMoney.Merge(m, src)
}
func (m *GamePoolMoney) XXX_Size() int {
	return m.Size()
}
func (m *GamePoolMoney) XXX_DiscardUnknown() {
	xxx_messageInfo_GamePoolMoney.DiscardUnknown(m)
}

var xxx_messageInfo_GamePoolMoney proto.InternalMessageInfo

type QueryGamePoolsReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryGamePoolsReq) Reset()         { *m = QueryGamePoolsReq{} }
func (m *QueryGamePoolsReq) String() string { return proto.CompactTextString(m) }
func (*QueryGamePoolsReq) ProtoMessage()    {}
func (*QueryGamePoolsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *QueryGamePoolsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryGamePoolsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryGamePoolsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryGamePoolsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryGamePoolsReq.Merge(m, src)
}
func (m *QueryGamePoolsReq) XXX_Size() int {
	return m.Size()
}
func (m *QueryGamePoolsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryGamePoolsReq.DiscardUnknown(m)
}

var xxx_messageInfo_QueryGamePoolsReq proto.InternalMessageInfo

type QueryGamePoolsRsp struct {
	Pools                []*GamePoolMoney `protobuf:"bytes,1,rep,name=Pools,proto3" json:"Pools" form:"Pools"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *QueryGamePoolsRsp) Reset()         { *m = QueryGamePoolsRsp{} }
func (m *QueryGamePoolsRsp) String() string { return proto.CompactTextString(m) }
func (*QueryGamePoolsRsp) ProtoMessage()    {}
func (*QueryGamePoolsRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *QueryGamePoolsRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryGamePoolsRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryGamePoolsRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryGamePoolsRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryGamePoolsRsp.Merge(m, src)
}
func (m *QueryGamePoolsRsp) XXX_Size() int {
	return m.Size()
}
func (m *QueryGamePoolsRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryGamePoolsRsp.DiscardUnknown(m)
}

var xxx_messageInfo_QueryGamePoolsRsp proto.InternalMessageInfo

type RecordDetail struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" `
	PoolID               int32    `protobuf:"varint,2,opt,name=PoolID,proto3" json:"PoolID" form:"PoolID" `
	Award                int64    `protobuf:"varint,3,opt,name=Award,proto3" json:"Award" form:"Award" `
	UserID               int64    `protobuf:"varint,4,opt,name=UserID,proto3" json:"UserID" form:"UserID" `
	Nickname             string   `protobuf:"bytes,5,opt,name=Nickname,proto3" json:"Nickname" form:"Nickname" `
	Time                 string   `protobuf:"bytes,6,opt,name=Time,proto3" json:"Time" form:"Time" `
	PoolTypeID           int32    `protobuf:"varint,7,opt,name=PoolTypeID,proto3" json:"PoolTypeID" form:"PoolTypeID" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecordDetail) Reset()         { *m = RecordDetail{} }
func (m *RecordDetail) String() string { return proto.CompactTextString(m) }
func (*RecordDetail) ProtoMessage()    {}
func (*RecordDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *RecordDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordDetail.Merge(m, src)
}
func (m *RecordDetail) XXX_Size() int {
	return m.Size()
}
func (m *RecordDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RecordDetail proto.InternalMessageInfo

type AddRewardRecordReq struct {
	Record               *RecordDetail `protobuf:"bytes,1,opt,name=Record,proto3" json:"Record" form:"Record" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *AddRewardRecordReq) Reset()         { *m = AddRewardRecordReq{} }
func (m *AddRewardRecordReq) String() string { return proto.CompactTextString(m) }
func (*AddRewardRecordReq) ProtoMessage()    {}
func (*AddRewardRecordReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *AddRewardRecordReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddRewardRecordReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddRewardRecordReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddRewardRecordReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddRewardRecordReq.Merge(m, src)
}
func (m *AddRewardRecordReq) XXX_Size() int {
	return m.Size()
}
func (m *AddRewardRecordReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddRewardRecordReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddRewardRecordReq proto.InternalMessageInfo

type QueryRewardRecordReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryRewardRecordReq) Reset()         { *m = QueryRewardRecordReq{} }
func (m *QueryRewardRecordReq) String() string { return proto.CompactTextString(m) }
func (*QueryRewardRecordReq) ProtoMessage()    {}
func (*QueryRewardRecordReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *QueryRewardRecordReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRewardRecordReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRewardRecordReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRewardRecordReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRewardRecordReq.Merge(m, src)
}
func (m *QueryRewardRecordReq) XXX_Size() int {
	return m.Size()
}
func (m *QueryRewardRecordReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRewardRecordReq.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRewardRecordReq proto.InternalMessageInfo

type QueryRewardRecordRsp struct {
	Records              []*RecordDetail `protobuf:"bytes,1,rep,name=Records,proto3" json:"Records" form:"Records" `
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *QueryRewardRecordRsp) Reset()         { *m = QueryRewardRecordRsp{} }
func (m *QueryRewardRecordRsp) String() string { return proto.CompactTextString(m) }
func (*QueryRewardRecordRsp) ProtoMessage()    {}
func (*QueryRewardRecordRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *QueryRewardRecordRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRewardRecordRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRewardRecordRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRewardRecordRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRewardRecordRsp.Merge(m, src)
}
func (m *QueryRewardRecordRsp) XXX_Size() int {
	return m.Size()
}
func (m *QueryRewardRecordRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRewardRecordRsp.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRewardRecordRsp proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("rewardpool.service.v1.PoolTypeCode", PoolTypeCode_name, PoolTypeCode_value)
	proto.RegisterEnum("rewardpool.service.v1.PoolIDCode", PoolIDCode_name, PoolIDCode_value)
	proto.RegisterEnum("rewardpool.service.v1.RewardPoolErrCode", RewardPoolErrCode_name, RewardPoolErrCode_value)
	proto.RegisterType((*CommonResp)(nil), "rewardpool.service.v1.CommonResp")
	proto.RegisterType((*QueryPoolReq)(nil), "rewardpool.service.v1.QueryPoolReq")
	proto.RegisterType((*QueryPoolRsp)(nil), "rewardpool.service.v1.QueryPoolRsp")
	proto.RegisterType((*PoolMoney)(nil), "rewardpool.service.v1.PoolMoney")
	proto.RegisterType((*UpdatePoolReq)(nil), "rewardpool.service.v1.UpdatePoolReq")
	proto.RegisterType((*GamePoolMoney)(nil), "rewardpool.service.v1.GamePoolMoney")
	proto.RegisterType((*QueryGamePoolsReq)(nil), "rewardpool.service.v1.QueryGamePoolsReq")
	proto.RegisterType((*QueryGamePoolsRsp)(nil), "rewardpool.service.v1.QueryGamePoolsRsp")
	proto.RegisterType((*RecordDetail)(nil), "rewardpool.service.v1.RecordDetail")
	proto.RegisterType((*AddRewardRecordReq)(nil), "rewardpool.service.v1.AddRewardRecordReq")
	proto.RegisterType((*QueryRewardRecordReq)(nil), "rewardpool.service.v1.QueryRewardRecordReq")
	proto.RegisterType((*QueryRewardRecordRsp)(nil), "rewardpool.service.v1.QueryRewardRecordRsp")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 1087 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x56, 0x4d, 0x6f, 0x1b, 0x45,
	0x18, 0xce, 0xda, 0x71, 0x82, 0xdf, 0x7c, 0x6d, 0xa6, 0x34, 0x75, 0x9d, 0xc4, 0xbb, 0x9d, 0x14,
	0x29, 0x04, 0xb0, 0x21, 0xad, 0x40, 0x54, 0x54, 0x22, 0x8e, 0x4b, 0x88, 0x44, 0x4a, 0xbb, 0x34,
	0x17, 0xa4, 0x0a, 0x6d, 0xbc, 0x13, 0x77, 0x61, 0x77, 0x67, 0xb3, 0x1f, 0x41, 0xb9, 0x56, 0xa8,
	0xe2, 0x4e, 0x0f, 0xfc, 0x04, 0xf8, 0x0f, 0xfc, 0x80, 0x1e, 0x91, 0x10, 0x17, 0x0e, 0x2b, 0x08,
	0x9c, 0x2c, 0xb8, 0xf8, 0x17, 0xa0, 0x99, 0xd9, 0xf5, 0xac, 0xed, 0xba, 0x18, 0x09, 0x2e, 0x39,
	0xd9, 0xcf, 0x33, 0xef, 0xcc, 0xfb, 0xce, 0xf3, 0xbc, 0xb3, 0x33, 0x50, 0x36, 0x7d, 0xbb, 0xee,
	0x07, 0x34, 0xa2, 0xe8, 0x72, 0x40, 0xbe, 0x34, 0x03, 0xcb, 0xa7, 0xd4, 0xa9, 0x87, 0x24, 0x38,
	0xb5, 0xdb, 0xa4, 0x7e, 0xfa, 0x56, 0xf5, 0x8d, 0x8e, 0x1d, 0x3d, 0x8a, 0x8f, 0xea, 0x6d, 0xea,
	0x36, 0x3a, 0xb4, 0x43, 0x1b, 0x3c, 0xfa, 0x28, 0x3e, 0xe6, 0x88, 0x03, 0xfe, 0x4f, 0xac, 0x52,
	0x5d, 0xed, 0x50, 0xda, 0x71, 0x88, 0x8c, 0x22, 0xae, 0x1f, 0x9d, 0xa5, 0x83, 0x6b, 0xe9, 0xa0,
	0xe9, 0xdb, 0x0d, 0xd3, 0xf3, 0x68, 0x64, 0x46, 0x36, 0xf5, 0x42, 0x31, 0x8a, 0x2d, 0x80, 0x5d,
	0xea, 0xba, 0xd4, 0x33, 0x48, 0xe8, 0xa3, 0xd7, 0x61, 0x7a, 0x97, 0x5a, 0xa4, 0xa2, 0xe8, 0xca,
	0x66, 0xa9, 0x59, 0xe9, 0x26, 0x1a, 0xc7, 0xbd, 0x44, 0x9b, 0x3f, 0xa6, 0x81, 0x7b, 0x0b, 0x33,
	0x84, 0x75, 0x83, 0xb3, 0x68, 0x13, 0x8a, 0x07, 0x61, 0xa7, 0x52, 0xd0, 0x95, 0xcd, 0x72, 0x73,
	0xa5, 0x9b, 0x68, 0x0c, 0xf6, 0x12, 0x6d, 0x4e, 0xc4, 0x1e, 0x84, 0x1d, 0xac, 0x1b, 0x8c, 0xc3,
	0x3f, 0x2b, 0x30, 0x7f, 0x3f, 0x26, 0xc1, 0xd9, 0x3d, 0x4a, 0x1d, 0x83, 0x9c, 0xa0, 0x3d, 0x98,
	0xd9, 0x33, 0x5d, 0xb2, 0xdf, 0x4a, 0x53, 0x35, 0xba, 0x89, 0x96, 0x32, 0xbd, 0x44, 0xbb, 0x26,
	0x16, 0x10, 0x18, 0xeb, 0xa7, 0xa6, 0x63, 0x5b, 0x66, 0x44, 0x6e, 0xe1, 0x80, 0x9c, 0xc4, 0x76,
	0x40, 0x2c, 0x6c, 0xa4, 0xc1, 0xe8, 0x1d, 0x98, 0xdd, 0x09, 0x88, 0x67, 0xee, 0xb7, 0x78, 0x1d,
	0xa5, 0xe6, 0x7a, 0x37, 0xd1, 0x32, 0xaa, 0x97, 0x68, 0x8b, 0x62, 0xa9, 0x94, 0xc0, 0x46, 0x36,
	0x84, 0x76, 0x01, 0x58, 0x31, 0x0f, 0xce, 0x7c, 0x56, 0x45, 0x91, 0xcf, 0xdd, 0xe8, 0x26, 0x5a,
	0x8e, 0xed, 0x25, 0xda, 0xb2, 0x98, 0x2e, 0x39, 0x6c, 0xe4, 0x02, 0xf0, 0x77, 0x85, 0xfc, 0xbe,
	0x42, 0xff, 0x82, 0xec, 0x0b, 0xdd, 0x87, 0x12, 0x43, 0x61, 0x65, 0x5a, 0x2f, 0x6e, 0xce, 0x6d,
	0xeb, 0xf5, 0xe7, 0xb6, 0x69, 0x9d, 0xc5, 0x1c, 0x50, 0x8f, 0x9c, 0x35, 0xaf, 0x76, 0x13, 0x4d,
	0x4c, 0x91, 0xbd, 0xc2, 0x21, 0x36, 0x04, 0x8d, 0x4f, 0xa0, 0xdc, 0x0f, 0x47, 0x37, 0x60, 0x86,
	0x81, 0xbe, 0x4c, 0xab, 0x4c, 0x26, 0xc1, 0xf4, 0x12, 0x6d, 0x41, 0xce, 0x67, 0x85, 0xa5, 0x03,
	0xa8, 0x01, 0xa5, 0x16, 0x71, 0x22, 0x93, 0x0b, 0x52, 0x14, 0x29, 0x39, 0x21, 0x53, 0x72, 0x88,
	0x0d, 0x41, 0xe3, 0xef, 0x0b, 0xb0, 0x70, 0xe8, 0x33, 0x85, 0x2f, 0x56, 0xdb, 0xfd, 0x1f, 0xf6,
	0xfc, 0x50, 0x80, 0x05, 0xb6, 0x37, 0xe9, 0xd1, 0x05, 0xd1, 0x4a, 0xb6, 0xda, 0xf4, 0xbf, 0x6a,
	0x35, 0x2e, 0x42, 0xa5, 0x24, 0x5b, 0x8d, 0x13, 0x52, 0x3e, 0x0e, 0xb1, 0x21, 0x68, 0x7c, 0x09,
	0x96, 0xf9, 0x77, 0x20, 0x93, 0x30, 0x34, 0xc8, 0x09, 0xfe, 0x7c, 0x84, 0x0c, 0x7d, 0x74, 0x98,
	0x79, 0xa7, 0x70, 0xef, 0xae, 0x8f, 0xf1, 0x6e, 0xc0, 0x8b, 0x09, 0xfc, 0x7b, 0x5a, 0x84, 0x79,
	0x83, 0xb4, 0x69, 0x60, 0xb5, 0x48, 0x64, 0xda, 0x0e, 0xba, 0x39, 0x64, 0xdf, 0xda, 0x80, 0x7d,
	0x8b, 0x83, 0xf6, 0xf5, 0xbd, 0xba, 0xd9, 0x57, 0xab, 0x20, 0x67, 0xf5, 0xd5, 0x5a, 0x1c, 0x50,
	0x4b, 0xef, 0xcb, 0xf5, 0x26, 0x94, 0x76, 0xd8, 0x26, 0xb8, 0x47, 0xc5, 0x66, 0x95, 0x55, 0xcb,
	0x09, 0xa9, 0x30, 0x87, 0x58, 0x37, 0x04, 0xcf, 0xf2, 0x1c, 0x86, 0x24, 0x48, 0x5d, 0x29, 0x8a,
	0x3c, 0x82, 0x91, 0x79, 0x04, 0x66, 0x79, 0xc4, 0x3f, 0xf4, 0x1e, 0xbc, 0x74, 0xd7, 0x6e, 0x7f,
	0xe1, 0x99, 0x2e, 0xe1, 0xce, 0x94, 0x9b, 0x7a, 0x37, 0xd1, 0xfa, 0x5c, 0x2f, 0xd1, 0x54, 0x31,
	0x33, 0x63, 0xb0, 0x6e, 0xf4, 0x47, 0xd9, 0xe5, 0xf6, 0xc0, 0x76, 0x49, 0x65, 0x86, 0xcf, 0xe4,
	0x97, 0x1b, 0xc3, 0x52, 0x51, 0x86, 0xd8, 0xe5, 0xc6, 0x7e, 0x51, 0x6b, 0xa0, 0xf9, 0x66, 0xb9,
	0x1a, 0xd7, 0x47, 0x9a, 0x0f, 0x8d, 0x34, 0x9f, 0x3e, 0x70, 0x41, 0x3c, 0x56, 0x00, 0xed, 0x58,
	0x96, 0xc1, 0x3d, 0x16, 0xfe, 0xb0, 0xef, 0x90, 0x03, 0x33, 0x02, 0x70, 0x73, 0xe6, 0xb6, 0x37,
	0xc6, 0x74, 0x41, 0xde, 0x51, 0x71, 0x00, 0x05, 0x23, 0x0f, 0xa0, 0xc0, 0x63, 0x0e, 0x60, 0x3a,
	0xf8, 0x19, 0xbc, 0xcc, 0xfb, 0x70, 0xb8, 0x8a, 0xff, 0xea, 0x84, 0xe3, 0xf8, 0x79, 0x09, 0x42,
	0x1f, 0x3d, 0x84, 0x59, 0x01, 0xb2, 0x6e, 0x9f, 0x68, 0x9f, 0x35, 0xf6, 0x79, 0x48, 0xe7, 0xf5,
	0x12, 0x6d, 0x29, 0xbf, 0xd1, 0x10, 0xeb, 0x46, 0x36, 0xb6, 0xf5, 0x2e, 0xcc, 0x67, 0x52, 0xf3,
	0xf7, 0xc8, 0x25, 0x58, 0xca, 0x70, 0x8b, 0x1c, 0x9b, 0xb1, 0x13, 0xa9, 0x53, 0xa8, 0x2c, 0xce,
	0xdb, 0x8e, 0xaa, 0x64, 0x7f, 0x9b, 0x6a, 0x61, 0xeb, 0x7d, 0xe1, 0xee, 0x7e, 0x8b, 0x4f, 0x5c,
	0x82, 0x39, 0x86, 0x3e, 0x8c, 0x3d, 0x2b, 0x20, 0x96, 0x3a, 0x85, 0xd4, 0x74, 0xe5, 0x47, 0x34,
	0x0e, 0x4d, 0xcf, 0x52, 0x95, 0x2c, 0xa4, 0x69, 0x3b, 0x8e, 0x4d, 0x3d, 0xb5, 0xb0, 0xf5, 0x10,
	0x96, 0xc5, 0x76, 0x19, 0x7d, 0x27, 0x08, 0xf8, 0x42, 0x73, 0x30, 0xfb, 0x49, 0xdc, 0x6e, 0x93,
	0x30, 0x54, 0xa7, 0xd0, 0x3a, 0x5c, 0xd9, 0x23, 0x91, 0x0c, 0xda, 0xa5, 0xde, 0xb1, 0xdd, 0xf9,
	0xc0, 0xb4, 0x1d, 0xf5, 0xcf, 0x27, 0xb7, 0xd1, 0x1a, 0xac, 0xc8, 0xb1, 0xbb, 0xb1, 0xfb, 0xf1,
	0x29, 0x09, 0x3e, 0xb2, 0x5d, 0x3b, 0x52, 0xff, 0x7a, 0x72, 0x7b, 0xfb, 0x97, 0x12, 0x80, 0x1c,
	0x46, 0x6f, 0xc3, 0xf4, 0x3d, 0xdb, 0xeb, 0xa0, 0x95, 0xba, 0x78, 0xcd, 0xd5, 0xb3, 0xa7, 0x5e,
	0xfd, 0x0e, 0x7b, 0xea, 0x55, 0xc7, 0xf0, 0x28, 0x82, 0x72, 0xff, 0x7d, 0x82, 0xc6, 0xa9, 0x9f,
	0x7f, 0x99, 0x55, 0xff, 0x39, 0x28, 0xf4, 0xf1, 0xfa, 0xe3, 0x9f, 0xfe, 0xf8, 0xa6, 0x70, 0x05,
	0x5f, 0x6e, 0xc8, 0x1a, 0x1b, 0x32, 0x51, 0x0c, 0x20, 0xef, 0x5d, 0x34, 0xee, 0x13, 0x37, 0x70,
	0x35, 0x57, 0xaf, 0x8d, 0x89, 0x92, 0xaf, 0x53, 0x5c, 0xe3, 0x59, 0x2b, 0x78, 0x25, 0x9f, 0x35,
	0x97, 0xe8, 0x2b, 0x05, 0x96, 0x86, 0x0e, 0x1b, 0x7a, 0x75, 0xcc, 0xb2, 0xa3, 0x87, 0x72, 0x92,
	0x0a, 0x36, 0x78, 0x05, 0xeb, 0x78, 0x35, 0x5f, 0xc1, 0x70, 0xca, 0xaf, 0x15, 0x58, 0x1c, 0xfc,
	0xee, 0xa3, 0xcd, 0x17, 0x89, 0x9a, 0xbf, 0x33, 0xaa, 0x13, 0x46, 0x86, 0x3e, 0xc6, 0xbc, 0x96,
	0x35, 0x5c, 0x1d, 0xf1, 0x40, 0xe6, 0x7d, 0xaa, 0xa4, 0x57, 0xd0, 0x40, 0x81, 0xaf, 0xbd, 0x28,
	0xc7, 0xb0, 0x2a, 0x93, 0x07, 0x87, 0x3e, 0x7e, 0x85, 0xd7, 0xa4, 0xe1, 0xf5, 0x91, 0x9a, 0xf2,
	0x91, 0xcd, 0xab, 0xcf, 0x7e, 0xab, 0x4d, 0x3d, 0x3b, 0xaf, 0x29, 0x3f, 0x9e, 0xd7, 0x94, 0x5f,
	0xcf, 0x6b, 0xca, 0xb7, 0xbf, 0xd7, 0xa6, 0x3e, 0x2d, 0x9a, 0xbe, 0x7d, 0x34, 0xc3, 0x1b, 0xf8,
	0xc6, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x90, 0x25, 0x7b, 0x91, 0x24, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RewardPoolClient is the client API for RewardPool service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RewardPoolClient interface {
	Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// 奖池信息查询
	QueryPool(ctx context.Context, in *QueryPoolReq, opts ...grpc.CallOption) (*QueryPoolRsp, error)
	// 更新奖池金额
	UpdatePool(ctx context.Context, in *UpdatePoolReq, opts ...grpc.CallOption) (*CommonResp, error)
	AddRewardRecord(ctx context.Context, in *AddRewardRecordReq, opts ...grpc.CallOption) (*CommonResp, error)
	// 查询游戏的所有奖池值(对外)
	QueryGamePools(ctx context.Context, in *QueryGamePoolsReq, opts ...grpc.CallOption) (*QueryGamePoolsRsp, error)
	// 查询指定游戏的中奖记录(对外)
	QueryRewardRecord(ctx context.Context, in *QueryRewardRecordReq, opts ...grpc.CallOption) (*QueryRewardRecordRsp, error)
}

type rewardPoolClient struct {
	cc *grpc.ClientConn
}

func NewRewardPoolClient(cc *grpc.ClientConn) RewardPoolClient {
	return &rewardPoolClient{cc}
}

func (c *rewardPoolClient) Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/rewardpool.service.v1.RewardPool/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rewardPoolClient) QueryPool(ctx context.Context, in *QueryPoolReq, opts ...grpc.CallOption) (*QueryPoolRsp, error) {
	out := new(QueryPoolRsp)
	err := c.cc.Invoke(ctx, "/rewardpool.service.v1.RewardPool/QueryPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rewardPoolClient) UpdatePool(ctx context.Context, in *UpdatePoolReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/rewardpool.service.v1.RewardPool/UpdatePool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rewardPoolClient) AddRewardRecord(ctx context.Context, in *AddRewardRecordReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/rewardpool.service.v1.RewardPool/AddRewardRecord", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rewardPoolClient) QueryGamePools(ctx context.Context, in *QueryGamePoolsReq, opts ...grpc.CallOption) (*QueryGamePoolsRsp, error) {
	out := new(QueryGamePoolsRsp)
	err := c.cc.Invoke(ctx, "/rewardpool.service.v1.RewardPool/QueryGamePools", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rewardPoolClient) QueryRewardRecord(ctx context.Context, in *QueryRewardRecordReq, opts ...grpc.CallOption) (*QueryRewardRecordRsp, error) {
	out := new(QueryRewardRecordRsp)
	err := c.cc.Invoke(ctx, "/rewardpool.service.v1.RewardPool/QueryRewardRecord", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RewardPoolServer is the server API for RewardPool service.
type RewardPoolServer interface {
	Ping(context.Context, *empty.Empty) (*empty.Empty, error)
	// 奖池信息查询
	QueryPool(context.Context, *QueryPoolReq) (*QueryPoolRsp, error)
	// 更新奖池金额
	UpdatePool(context.Context, *UpdatePoolReq) (*CommonResp, error)
	AddRewardRecord(context.Context, *AddRewardRecordReq) (*CommonResp, error)
	// 查询游戏的所有奖池值(对外)
	QueryGamePools(context.Context, *QueryGamePoolsReq) (*QueryGamePoolsRsp, error)
	// 查询指定游戏的中奖记录(对外)
	QueryRewardRecord(context.Context, *QueryRewardRecordReq) (*QueryRewardRecordRsp, error)
}

// UnimplementedRewardPoolServer can be embedded to have forward compatible implementations.
type UnimplementedRewardPoolServer struct {
}

func (*UnimplementedRewardPoolServer) Ping(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (*UnimplementedRewardPoolServer) QueryPool(ctx context.Context, req *QueryPoolReq) (*QueryPoolRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPool not implemented")
}
func (*UnimplementedRewardPoolServer) UpdatePool(ctx context.Context, req *UpdatePoolReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePool not implemented")
}
func (*UnimplementedRewardPoolServer) AddRewardRecord(ctx context.Context, req *AddRewardRecordReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRewardRecord not implemented")
}
func (*UnimplementedRewardPoolServer) QueryGamePools(ctx context.Context, req *QueryGamePoolsReq) (*QueryGamePoolsRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryGamePools not implemented")
}
func (*UnimplementedRewardPoolServer) QueryRewardRecord(ctx context.Context, req *QueryRewardRecordReq) (*QueryRewardRecordRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRewardRecord not implemented")
}

func RegisterRewardPoolServer(s *grpc.Server, srv RewardPoolServer) {
	s.RegisterService(&_RewardPool_serviceDesc, srv)
}

func _RewardPool_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RewardPoolServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rewardpool.service.v1.RewardPool/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RewardPoolServer).Ping(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _RewardPool_QueryPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPoolReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RewardPoolServer).QueryPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rewardpool.service.v1.RewardPool/QueryPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RewardPoolServer).QueryPool(ctx, req.(*QueryPoolReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RewardPool_UpdatePool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePoolReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RewardPoolServer).UpdatePool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rewardpool.service.v1.RewardPool/UpdatePool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RewardPoolServer).UpdatePool(ctx, req.(*UpdatePoolReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RewardPool_AddRewardRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRewardRecordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RewardPoolServer).AddRewardRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rewardpool.service.v1.RewardPool/AddRewardRecord",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RewardPoolServer).AddRewardRecord(ctx, req.(*AddRewardRecordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RewardPool_QueryGamePools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGamePoolsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RewardPoolServer).QueryGamePools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rewardpool.service.v1.RewardPool/QueryGamePools",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RewardPoolServer).QueryGamePools(ctx, req.(*QueryGamePoolsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RewardPool_QueryRewardRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRewardRecordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RewardPoolServer).QueryRewardRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rewardpool.service.v1.RewardPool/QueryRewardRecord",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RewardPoolServer).QueryRewardRecord(ctx, req.(*QueryRewardRecordReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _RewardPool_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rewardpool.service.v1.RewardPool",
	HandlerType: (*RewardPoolServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _RewardPool_Ping_Handler,
		},
		{
			MethodName: "QueryPool",
			Handler:    _RewardPool_QueryPool_Handler,
		},
		{
			MethodName: "UpdatePool",
			Handler:    _RewardPool_UpdatePool_Handler,
		},
		{
			MethodName: "AddRewardRecord",
			Handler:    _RewardPool_AddRewardRecord_Handler,
		},
		{
			MethodName: "QueryGamePools",
			Handler:    _RewardPool_QueryGamePools_Handler,
		},
		{
			MethodName: "QueryRewardRecord",
			Handler:    _RewardPool_QueryRewardRecord_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *CommonResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryPoolReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPoolReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPoolReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PoolTypeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PoolTypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryPoolRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPoolRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPoolRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.PoolTypeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PoolTypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PoolMoney) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolMoney) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolMoney) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Delta != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Delta))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PoolID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdatePoolReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePoolReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdatePoolReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.PoolTypeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PoolTypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GamePoolMoney) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GamePoolMoney) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GamePoolMoney) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Money != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x28
	}
	if m.PoolID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PoolID))
		i--
		dAtA[i] = 0x20
	}
	if m.PoolTypeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PoolTypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryGamePoolsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryGamePoolsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryGamePoolsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *QueryGamePoolsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryGamePoolsRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryGamePoolsRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RecordDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PoolTypeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PoolTypeID))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Nickname) > 0 {
		i -= len(m.Nickname)
		copy(dAtA[i:], m.Nickname)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Nickname)))
		i--
		dAtA[i] = 0x2a
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x20
	}
	if m.Award != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Award))
		i--
		dAtA[i] = 0x18
	}
	if m.PoolID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PoolID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddRewardRecordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddRewardRecordReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddRewardRecordReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Record != nil {
		{
			size, err := m.Record.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryRewardRecordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRewardRecordReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRewardRecordReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryRewardRecordRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRewardRecordRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRewardRecordRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CommonResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryPoolReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.PoolTypeID != 0 {
		n += 1 + sovApi(uint64(m.PoolTypeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryPoolRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.PoolTypeID != 0 {
		n += 1 + sovApi(uint64(m.PoolTypeID))
	}
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PoolMoney) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolID != 0 {
		n += 1 + sovApi(uint64(m.PoolID))
	}
	if m.Delta != 0 {
		n += 1 + sovApi(uint64(m.Delta))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdatePoolReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.PoolTypeID != 0 {
		n += 1 + sovApi(uint64(m.PoolTypeID))
	}
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GamePoolMoney) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.PoolTypeID != 0 {
		n += 1 + sovApi(uint64(m.PoolTypeID))
	}
	if m.PoolID != 0 {
		n += 1 + sovApi(uint64(m.PoolID))
	}
	if m.Money != 0 {
		n += 1 + sovApi(uint64(m.Money))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryGamePoolsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryGamePoolsRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecordDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.PoolID != 0 {
		n += 1 + sovApi(uint64(m.PoolID))
	}
	if m.Award != 0 {
		n += 1 + sovApi(uint64(m.Award))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PoolTypeID != 0 {
		n += 1 + sovApi(uint64(m.PoolTypeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddRewardRecordReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Record != nil {
		l = m.Record.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryRewardRecordReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryRewardRecordRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CommonResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPoolReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPoolReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPoolReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolTypeID", wireType)
			}
			m.PoolTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolTypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPoolRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPoolRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPoolRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolTypeID", wireType)
			}
			m.PoolTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolTypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, &PoolMoney{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolMoney) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolMoney: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolMoney: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolID", wireType)
			}
			m.PoolID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			m.Delta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delta |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePoolReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePoolReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePoolReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolTypeID", wireType)
			}
			m.PoolTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolTypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, &PoolMoney{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GamePoolMoney) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GamePoolMoney: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GamePoolMoney: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolTypeID", wireType)
			}
			m.PoolTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolTypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolID", wireType)
			}
			m.PoolID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryGamePoolsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryGamePoolsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryGamePoolsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryGamePoolsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryGamePoolsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryGamePoolsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, &GamePoolMoney{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolID", wireType)
			}
			m.PoolID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Award", wireType)
			}
			m.Award = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Award |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolTypeID", wireType)
			}
			m.PoolTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolTypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddRewardRecordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddRewardRecordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddRewardRecordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Record == nil {
				m.Record = &RecordDetail{}
			}
			if err := m.Record.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRewardRecordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRewardRecordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRewardRecordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRewardRecordRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRewardRecordRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRewardRecordRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &RecordDetail{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
