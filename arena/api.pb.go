// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

// package 命名使用 {appid}.{version} 的方式, version 形如 v1, v2 ..

package api

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ArenaMsgCode int32

const (
	ArenaMsgCode_AMC_InvalId ArenaMsgCode = 0
	//客户端-全民赛
	ArenaMsgCode_AMC_C_PMatchStatus ArenaMsgCode = 30
	ArenaMsgCode_AMC_C_PShareStatus ArenaMsgCode = 31
	ArenaMsgCode_AMC_C_PAwardList   ArenaMsgCode = 32
	ArenaMsgCode_AMC_C_PGetAward    ArenaMsgCode = 33
	ArenaMsgCode_AMC_C_PAwardCount  ArenaMsgCode = 34
	ArenaMsgCode_AMC_C_PRankList    ArenaMsgCode = 35
	ArenaMsgCode_AMC_C_PMatchList   ArenaMsgCode = 36
	ArenaMsgCode_AMC_C_PSignUp      ArenaMsgCode = 37
	//客户端-快速赛
	ArenaMsgCode_AMC_C_FMatchStatus    ArenaMsgCode = 50
	ArenaMsgCode_AMC_C_FShareStatus    ArenaMsgCode = 51
	ArenaMsgCode_AMC_C_FAwardList      ArenaMsgCode = 52
	ArenaMsgCode_AMC_C_FGetAward       ArenaMsgCode = 53
	ArenaMsgCode_AMC_C_FAwardCount     ArenaMsgCode = 54
	ArenaMsgCode_AMC_C_FRankList       ArenaMsgCode = 55
	ArenaMsgCode_AMC_C_FMatchList      ArenaMsgCode = 56
	ArenaMsgCode_AMC_C_FWaitMatch      ArenaMsgCode = 57
	ArenaMsgCode_AMC_C_FCancelMatch    ArenaMsgCode = 58
	ArenaMsgCode_AMC_C_FSignUp         ArenaMsgCode = 59
	ArenaMsgCode_AMC_C_FConfirm        ArenaMsgCode = 60
	ArenaMsgCode_AMC_C_FRobotLogin     ArenaMsgCode = 61
	ArenaMsgCode_AMC_C_FRobotJoinMatch ArenaMsgCode = 62
	ArenaMsgCode_AMC_C_FRobotHeart     ArenaMsgCode = 63
	//服务器部分-公共部分
	ArenaMsgCode_AMC_S_GameCountDown ArenaMsgCode = 100
	ArenaMsgCode_AMC_S_ReportStatus  ArenaMsgCode = 101
	//服务器部分-全民赛
	ArenaMsgCode_AMC_S_PReportMatch ArenaMsgCode = 131
	ArenaMsgCode_AMC_S_PGameEnd     ArenaMsgCode = 132
	//服务器部分-快速比赛
	ArenaMsgCode_AMC_S_FReportMatch  ArenaMsgCode = 151
	ArenaMsgCode_AMC_S_FGameEnd      ArenaMsgCode = 153
	ArenaMsgCode_AMC_C_FRobotNameSyn ArenaMsgCode = 154
)

var ArenaMsgCode_name = map[int32]string{
	0:   "AMC_InvalId",
	30:  "AMC_C_PMatchStatus",
	31:  "AMC_C_PShareStatus",
	32:  "AMC_C_PAwardList",
	33:  "AMC_C_PGetAward",
	34:  "AMC_C_PAwardCount",
	35:  "AMC_C_PRankList",
	36:  "AMC_C_PMatchList",
	37:  "AMC_C_PSignUp",
	50:  "AMC_C_FMatchStatus",
	51:  "AMC_C_FShareStatus",
	52:  "AMC_C_FAwardList",
	53:  "AMC_C_FGetAward",
	54:  "AMC_C_FAwardCount",
	55:  "AMC_C_FRankList",
	56:  "AMC_C_FMatchList",
	57:  "AMC_C_FWaitMatch",
	58:  "AMC_C_FCancelMatch",
	59:  "AMC_C_FSignUp",
	60:  "AMC_C_FConfirm",
	61:  "AMC_C_FRobotLogin",
	62:  "AMC_C_FRobotJoinMatch",
	63:  "AMC_C_FRobotHeart",
	100: "AMC_S_GameCountDown",
	101: "AMC_S_ReportStatus",
	131: "AMC_S_PReportMatch",
	132: "AMC_S_PGameEnd",
	151: "AMC_S_FReportMatch",
	153: "AMC_S_FGameEnd",
	154: "AMC_C_FRobotNameSyn",
}

var ArenaMsgCode_value = map[string]int32{
	"AMC_InvalId":           0,
	"AMC_C_PMatchStatus":    30,
	"AMC_C_PShareStatus":    31,
	"AMC_C_PAwardList":      32,
	"AMC_C_PGetAward":       33,
	"AMC_C_PAwardCount":     34,
	"AMC_C_PRankList":       35,
	"AMC_C_PMatchList":      36,
	"AMC_C_PSignUp":         37,
	"AMC_C_FMatchStatus":    50,
	"AMC_C_FShareStatus":    51,
	"AMC_C_FAwardList":      52,
	"AMC_C_FGetAward":       53,
	"AMC_C_FAwardCount":     54,
	"AMC_C_FRankList":       55,
	"AMC_C_FMatchList":      56,
	"AMC_C_FWaitMatch":      57,
	"AMC_C_FCancelMatch":    58,
	"AMC_C_FSignUp":         59,
	"AMC_C_FConfirm":        60,
	"AMC_C_FRobotLogin":     61,
	"AMC_C_FRobotJoinMatch": 62,
	"AMC_C_FRobotHeart":     63,
	"AMC_S_GameCountDown":   100,
	"AMC_S_ReportStatus":    101,
	"AMC_S_PReportMatch":    131,
	"AMC_S_PGameEnd":        132,
	"AMC_S_FReportMatch":    151,
	"AMC_S_FGameEnd":        153,
	"AMC_C_FRobotNameSyn":   154,
}

func (x ArenaMsgCode) String() string {
	return proto.EnumName(ArenaMsgCode_name, int32(x))
}

func (ArenaMsgCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

type ArenaMsgErrorCode int32

const (
	ArenaMsgErrorCode_AMEC_InvalId           ArenaMsgErrorCode = 0
	ArenaMsgErrorCode_AMEC_Sucess            ArenaMsgErrorCode = 1
	ArenaMsgErrorCode_AMEC_Param             ArenaMsgErrorCode = 2
	ArenaMsgErrorCode_AMEC_PlayerNotExist    ArenaMsgErrorCode = 3
	ArenaMsgErrorCode_AMEC_PlayerNotGameing  ArenaMsgErrorCode = 4
	ArenaMsgErrorCode_AMEC_UnserializeFailed ArenaMsgErrorCode = 5
	ArenaMsgErrorCode_AMEC_DeserializeFailed ArenaMsgErrorCode = 6
	ArenaMsgErrorCode_AMEC_FreshUserMoney    ArenaMsgErrorCode = 7
	ArenaMsgErrorCode_AMEC_SystemError       ArenaMsgErrorCode = 8
	ArenaMsgErrorCode_AMEC_SqlConn           ArenaMsgErrorCode = 9
	ArenaMsgErrorCode_AMEC_Infos             ArenaMsgErrorCode = 10
	ArenaMsgErrorCode_AMEC_VipLevel          ArenaMsgErrorCode = 11
	ArenaMsgErrorCode_AMEC_Money             ArenaMsgErrorCode = 12
	ArenaMsgErrorCode_AMEC_Share             ArenaMsgErrorCode = 13
	ArenaMsgErrorCode_AMEC_JoinTime          ArenaMsgErrorCode = 14
	ArenaMsgErrorCode_AMEC_MatchNotExist     ArenaMsgErrorCode = 15
	ArenaMsgErrorCode_AMEC_MatchNotOpen      ArenaMsgErrorCode = 16
	ArenaMsgErrorCode_AMEC_SignUpFailed      ArenaMsgErrorCode = 17
	ArenaMsgErrorCode_AMEC_SignUpSucess      ArenaMsgErrorCode = 18
	ArenaMsgErrorCode_AMEC_NoAward           ArenaMsgErrorCode = 19
	ArenaMsgErrorCode_AMEC_Collection        ArenaMsgErrorCode = 20
	ArenaMsgErrorCode_AMEC_AwardSucess       ArenaMsgErrorCode = 21
	ArenaMsgErrorCode_AMEC_NotWaiting        ArenaMsgErrorCode = 22
	ArenaMsgErrorCode_AMEC_NotTable          ArenaMsgErrorCode = 23
	ArenaMsgErrorCode_AMEC_TableStarted      ArenaMsgErrorCode = 24
	ArenaMsgErrorCode_AMEC_PhoneFailed       ArenaMsgErrorCode = 25
)

var ArenaMsgErrorCode_name = map[int32]string{
	0:  "AMEC_InvalId",
	1:  "AMEC_Sucess",
	2:  "AMEC_Param",
	3:  "AMEC_PlayerNotExist",
	4:  "AMEC_PlayerNotGameing",
	5:  "AMEC_UnserializeFailed",
	6:  "AMEC_DeserializeFailed",
	7:  "AMEC_FreshUserMoney",
	8:  "AMEC_SystemError",
	9:  "AMEC_SqlConn",
	10: "AMEC_Infos",
	11: "AMEC_VipLevel",
	12: "AMEC_Money",
	13: "AMEC_Share",
	14: "AMEC_JoinTime",
	15: "AMEC_MatchNotExist",
	16: "AMEC_MatchNotOpen",
	17: "AMEC_SignUpFailed",
	18: "AMEC_SignUpSucess",
	19: "AMEC_NoAward",
	20: "AMEC_Collection",
	21: "AMEC_AwardSucess",
	22: "AMEC_NotWaiting",
	23: "AMEC_NotTable",
	24: "AMEC_TableStarted",
	25: "AMEC_PhoneFailed",
}

var ArenaMsgErrorCode_value = map[string]int32{
	"AMEC_InvalId":           0,
	"AMEC_Sucess":            1,
	"AMEC_Param":             2,
	"AMEC_PlayerNotExist":    3,
	"AMEC_PlayerNotGameing":  4,
	"AMEC_UnserializeFailed": 5,
	"AMEC_DeserializeFailed": 6,
	"AMEC_FreshUserMoney":    7,
	"AMEC_SystemError":       8,
	"AMEC_SqlConn":           9,
	"AMEC_Infos":             10,
	"AMEC_VipLevel":          11,
	"AMEC_Money":             12,
	"AMEC_Share":             13,
	"AMEC_JoinTime":          14,
	"AMEC_MatchNotExist":     15,
	"AMEC_MatchNotOpen":      16,
	"AMEC_SignUpFailed":      17,
	"AMEC_SignUpSucess":      18,
	"AMEC_NoAward":           19,
	"AMEC_Collection":        20,
	"AMEC_AwardSucess":       21,
	"AMEC_NotWaiting":        22,
	"AMEC_NotTable":          23,
	"AMEC_TableStarted":      24,
	"AMEC_PhoneFailed":       25,
}

func (x ArenaMsgErrorCode) String() string {
	return proto.EnumName(ArenaMsgErrorCode_name, int32(x))
}

func (ArenaMsgErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}

//------------------------- 客户端部分-公用部分 ------------------------------------
type HttpCommonRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	En                   int32    `protobuf:"varint,3,opt,name=En,proto3" json:"En"`
	Data                 []byte   `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HttpCommonRsp) Reset()         { *m = HttpCommonRsp{} }
func (m *HttpCommonRsp) String() string { return proto.CompactTextString(m) }
func (*HttpCommonRsp) ProtoMessage()    {}
func (*HttpCommonRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *HttpCommonRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpCommonRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpCommonRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpCommonRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpCommonRsp.Merge(m, src)
}
func (m *HttpCommonRsp) XXX_Size() int {
	return m.Size()
}
func (m *HttpCommonRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpCommonRsp.DiscardUnknown(m)
}

var xxx_messageInfo_HttpCommonRsp proto.InternalMessageInfo

type MatchStatusReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchStatusReq) Reset()         { *m = MatchStatusReq{} }
func (m *MatchStatusReq) String() string { return proto.CompactTextString(m) }
func (*MatchStatusReq) ProtoMessage()    {}
func (*MatchStatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *MatchStatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchStatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchStatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchStatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchStatusReq.Merge(m, src)
}
func (m *MatchStatusReq) XXX_Size() int {
	return m.Size()
}
func (m *MatchStatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchStatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_MatchStatusReq proto.InternalMessageInfo

type MatchTips struct {
	GameType             int32    `protobuf:"varint,1,opt,name=GameType,proto3" json:"GameType"`
	Type                 int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type"`
	TypeTips             string   `protobuf:"bytes,3,opt,name=TypeTips,proto3" json:"TypeTips"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchTips) Reset()         { *m = MatchTips{} }
func (m *MatchTips) String() string { return proto.CompactTextString(m) }
func (*MatchTips) ProtoMessage()    {}
func (*MatchTips) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *MatchTips) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchTips) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchTips.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchTips) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchTips.Merge(m, src)
}
func (m *MatchTips) XXX_Size() int {
	return m.Size()
}
func (m *MatchTips) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchTips.DiscardUnknown(m)
}

var xxx_messageInfo_MatchTips proto.InternalMessageInfo

type MatchStatusRsp struct {
	Code                 int32        `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string       `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	Tips                 []*MatchTips `protobuf:"bytes,3,rep,name=Tips,proto3" json:"Tips,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MatchStatusRsp) Reset()         { *m = MatchStatusRsp{} }
func (m *MatchStatusRsp) String() string { return proto.CompactTextString(m) }
func (*MatchStatusRsp) ProtoMessage()    {}
func (*MatchStatusRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *MatchStatusRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchStatusRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchStatusRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchStatusRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchStatusRsp.Merge(m, src)
}
func (m *MatchStatusRsp) XXX_Size() int {
	return m.Size()
}
func (m *MatchStatusRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchStatusRsp.DiscardUnknown(m)
}

var xxx_messageInfo_MatchStatusRsp proto.InternalMessageInfo

type ShareStatusReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShareStatusReq) Reset()         { *m = ShareStatusReq{} }
func (m *ShareStatusReq) String() string { return proto.CompactTextString(m) }
func (*ShareStatusReq) ProtoMessage()    {}
func (*ShareStatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *ShareStatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShareStatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShareStatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShareStatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShareStatusReq.Merge(m, src)
}
func (m *ShareStatusReq) XXX_Size() int {
	return m.Size()
}
func (m *ShareStatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ShareStatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_ShareStatusReq proto.InternalMessageInfo

type ShareStatusRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	Core                 int32    `protobuf:"varint,4,opt,name=Core,proto3" json:"Core"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShareStatusRsp) Reset()         { *m = ShareStatusRsp{} }
func (m *ShareStatusRsp) String() string { return proto.CompactTextString(m) }
func (*ShareStatusRsp) ProtoMessage()    {}
func (*ShareStatusRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *ShareStatusRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShareStatusRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShareStatusRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShareStatusRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShareStatusRsp.Merge(m, src)
}
func (m *ShareStatusRsp) XXX_Size() int {
	return m.Size()
}
func (m *ShareStatusRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ShareStatusRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ShareStatusRsp proto.InternalMessageInfo

type Award struct {
	Id                   int32    `protobuf:"varint,1,opt,name=Id,proto3" json:"Id"`
	Num                  int64    `protobuf:"varint,2,opt,name=Num,proto3" json:"Num"`
	Mux                  int32    `protobuf:"varint,3,opt,name=Mux,proto3" json:"Mux"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Award) Reset()         { *m = Award{} }
func (m *Award) String() string { return proto.CompactTextString(m) }
func (*Award) ProtoMessage()    {}
func (*Award) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *Award) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Award) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Award.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Award) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Award.Merge(m, src)
}
func (m *Award) XXX_Size() int {
	return m.Size()
}
func (m *Award) XXX_DiscardUnknown() {
	xxx_messageInfo_Award.DiscardUnknown(m)
}

var xxx_messageInfo_Award proto.InternalMessageInfo

type AwardInfo struct {
	AwardId              string   `protobuf:"bytes,1,opt,name=AwardId,proto3" json:"AwardId"`
	ModeId               int32    `protobuf:"varint,2,opt,name=ModeId,proto3" json:"ModeId"`
	TypeTips             string   `protobuf:"bytes,3,opt,name=TypeTips,proto3" json:"TypeTips"`
	Awards               []*Award `protobuf:"bytes,4,rep,name=Awards,proto3" json:"Awards,omitempty"`
	Date                 string   `protobuf:"bytes,5,opt,name=Date,proto3" json:"Date"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AwardInfo) Reset()         { *m = AwardInfo{} }
func (m *AwardInfo) String() string { return proto.CompactTextString(m) }
func (*AwardInfo) ProtoMessage()    {}
func (*AwardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *AwardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardInfo.Merge(m, src)
}
func (m *AwardInfo) XXX_Size() int {
	return m.Size()
}
func (m *AwardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AwardInfo proto.InternalMessageInfo

type AwardListReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AwardListReq) Reset()         { *m = AwardListReq{} }
func (m *AwardListReq) String() string { return proto.CompactTextString(m) }
func (*AwardListReq) ProtoMessage()    {}
func (*AwardListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *AwardListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardListReq.Merge(m, src)
}
func (m *AwardListReq) XXX_Size() int {
	return m.Size()
}
func (m *AwardListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardListReq.DiscardUnknown(m)
}

var xxx_messageInfo_AwardListReq proto.InternalMessageInfo

type AwardListRsp struct {
	Code                 int32        `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string       `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	AwardList            []*AwardInfo `protobuf:"bytes,3,rep,name=AwardList,proto3" json:"AwardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AwardListRsp) Reset()         { *m = AwardListRsp{} }
func (m *AwardListRsp) String() string { return proto.CompactTextString(m) }
func (*AwardListRsp) ProtoMessage()    {}
func (*AwardListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *AwardListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardListRsp.Merge(m, src)
}
func (m *AwardListRsp) XXX_Size() int {
	return m.Size()
}
func (m *AwardListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AwardListRsp proto.InternalMessageInfo

type GetAwardData struct {
	AwardId              string   `protobuf:"bytes,1,opt,name=AwardId,proto3" json:"AwardId"`
	Phone                string   `protobuf:"bytes,2,opt,name=Phone,proto3" json:"Phone"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAwardData) Reset()         { *m = GetAwardData{} }
func (m *GetAwardData) String() string { return proto.CompactTextString(m) }
func (*GetAwardData) ProtoMessage()    {}
func (*GetAwardData) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *GetAwardData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAwardData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAwardData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAwardData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAwardData.Merge(m, src)
}
func (m *GetAwardData) XXX_Size() int {
	return m.Size()
}
func (m *GetAwardData) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAwardData.DiscardUnknown(m)
}

var xxx_messageInfo_GetAwardData proto.InternalMessageInfo

type GetAwardReq struct {
	PlayerId             int32           `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	AwardList            []*GetAwardData `protobuf:"bytes,2,rep,name=AwardList,proto3" json:"AwardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetAwardReq) Reset()         { *m = GetAwardReq{} }
func (m *GetAwardReq) String() string { return proto.CompactTextString(m) }
func (*GetAwardReq) ProtoMessage()    {}
func (*GetAwardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *GetAwardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAwardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAwardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAwardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAwardReq.Merge(m, src)
}
func (m *GetAwardReq) XXX_Size() int {
	return m.Size()
}
func (m *GetAwardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAwardReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetAwardReq proto.InternalMessageInfo

type GetAwardRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	AwardIdList          []string `protobuf:"bytes,4,rep,name=AwardIdList,proto3" json:"AwardIdList,omitempty"`
	AwardList            []*Award `protobuf:"bytes,5,rep,name=AwardList,proto3" json:"AwardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAwardRsp) Reset()         { *m = GetAwardRsp{} }
func (m *GetAwardRsp) String() string { return proto.CompactTextString(m) }
func (*GetAwardRsp) ProtoMessage()    {}
func (*GetAwardRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *GetAwardRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAwardRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAwardRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAwardRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAwardRsp.Merge(m, src)
}
func (m *GetAwardRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetAwardRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAwardRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetAwardRsp proto.InternalMessageInfo

type AwardCountReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AwardCountReq) Reset()         { *m = AwardCountReq{} }
func (m *AwardCountReq) String() string { return proto.CompactTextString(m) }
func (*AwardCountReq) ProtoMessage()    {}
func (*AwardCountReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *AwardCountReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardCountReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardCountReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardCountReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardCountReq.Merge(m, src)
}
func (m *AwardCountReq) XXX_Size() int {
	return m.Size()
}
func (m *AwardCountReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardCountReq.DiscardUnknown(m)
}

var xxx_messageInfo_AwardCountReq proto.InternalMessageInfo

type AwardCountRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	Count                int32    `protobuf:"varint,4,opt,name=Count,proto3" json:"Count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AwardCountRsp) Reset()         { *m = AwardCountRsp{} }
func (m *AwardCountRsp) String() string { return proto.CompactTextString(m) }
func (*AwardCountRsp) ProtoMessage()    {}
func (*AwardCountRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *AwardCountRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardCountRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardCountRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardCountRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardCountRsp.Merge(m, src)
}
func (m *AwardCountRsp) XXX_Size() int {
	return m.Size()
}
func (m *AwardCountRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardCountRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AwardCountRsp proto.InternalMessageInfo

type RankListReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	Type                 int32    `protobuf:"varint,2,opt,name=type,proto3" json:"type"`
	ArenaType            int32    `protobuf:"varint,3,opt,name=ArenaType,proto3" json:"ArenaType"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RankListReq) Reset()         { *m = RankListReq{} }
func (m *RankListReq) String() string { return proto.CompactTextString(m) }
func (*RankListReq) ProtoMessage()    {}
func (*RankListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *RankListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankListReq.Merge(m, src)
}
func (m *RankListReq) XXX_Size() int {
	return m.Size()
}
func (m *RankListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RankListReq.DiscardUnknown(m)
}

var xxx_messageInfo_RankListReq proto.InternalMessageInfo

type RankListInfo struct {
	StartRank            int32    `protobuf:"varint,1,opt,name=StartRank,proto3" json:"StartRank"`
	EndRank              int32    `protobuf:"varint,2,opt,name=EndRank,proto3" json:"EndRank"`
	UserType             int32    `protobuf:"varint,3,opt,name=UserType,proto3" json:"UserType"`
	Name                 string   `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name"`
	Icon                 string   `protobuf:"bytes,5,opt,name=Icon,proto3" json:"Icon"`
	Mark                 int32    `protobuf:"varint,6,opt,name=Mark,proto3" json:"Mark"`
	AwardList            []*Award `protobuf:"bytes,7,rep,name=AwardList,proto3" json:"AwardList,omitempty"`
	Stars                bool     `protobuf:"varint,8,opt,name=Stars,proto3" json:"Stars"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RankListInfo) Reset()         { *m = RankListInfo{} }
func (m *RankListInfo) String() string { return proto.CompactTextString(m) }
func (*RankListInfo) ProtoMessage()    {}
func (*RankListInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *RankListInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankListInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankListInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankListInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankListInfo.Merge(m, src)
}
func (m *RankListInfo) XXX_Size() int {
	return m.Size()
}
func (m *RankListInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RankListInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RankListInfo proto.InternalMessageInfo

type RankListRsp struct {
	Code                 int32           `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string          `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	Type                 int32           `protobuf:"varint,3,opt,name=Type,proto3" json:"Type"`
	ArenaType            int32           `protobuf:"varint,4,opt,name=ArenaType,proto3" json:"ArenaType"`
	RankList             []*RankListInfo `protobuf:"bytes,5,rep,name=RankList,proto3" json:"RankList,omitempty"`
	Rank                 int32           `protobuf:"varint,6,opt,name=Rank,proto3" json:"Rank"`
	TotalRank            int32           `protobuf:"varint,7,opt,name=TotalRank,proto3" json:"TotalRank"`
	Mark                 int32           `protobuf:"varint,8,opt,name=Mark,proto3" json:"Mark"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RankListRsp) Reset()         { *m = RankListRsp{} }
func (m *RankListRsp) String() string { return proto.CompactTextString(m) }
func (*RankListRsp) ProtoMessage()    {}
func (*RankListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *RankListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankListRsp.Merge(m, src)
}
func (m *RankListRsp) XXX_Size() int {
	return m.Size()
}
func (m *RankListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RankListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RankListRsp proto.InternalMessageInfo

//-------------------------全民赛-----------------------------------
type Condition struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type"`
	Value                int32    `protobuf:"varint,2,opt,name=Value,proto3" json:"Value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Condition) Reset()         { *m = Condition{} }
func (m *Condition) String() string { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()    {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{18}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

type PMatchInfo struct {
	Type                 int32        `protobuf:"varint,1,opt,name=Type,proto3" json:"Type"`
	TypeTips             string       `protobuf:"bytes,2,opt,name=TypeTips,proto3" json:"TypeTips"`
	Id                   int32        `protobuf:"varint,3,opt,name=Id,proto3" json:"Id"`
	JoinTimes            int32        `protobuf:"varint,4,opt,name=JoinTimes,proto3" json:"JoinTimes"`
	TotalTimes           int32        `protobuf:"varint,5,opt,name=TotalTimes,proto3" json:"TotalTimes"`
	Date                 string       `protobuf:"bytes,6,opt,name=Date,proto3" json:"Date"`
	Status               int32        `protobuf:"varint,7,opt,name=Status,proto3" json:"Status"`
	ConditionList        []*Condition `protobuf:"bytes,8,rep,name=ConditionList,proto3" json:"ConditionList,omitempty"`
	Rank                 int32        `protobuf:"varint,9,opt,name=Rank,proto3" json:"Rank"`
	TotalRank            int32        `protobuf:"varint,10,opt,name=TotalRank,proto3" json:"TotalRank"`
	Awards               []*Award     `protobuf:"bytes,11,rep,name=Awards,proto3" json:"Awards,omitempty"`
	AwardCount           int32        `protobuf:"varint,12,opt,name=AwardCount,proto3" json:"AwardCount"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PMatchInfo) Reset()         { *m = PMatchInfo{} }
func (m *PMatchInfo) String() string { return proto.CompactTextString(m) }
func (*PMatchInfo) ProtoMessage()    {}
func (*PMatchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{19}
}
func (m *PMatchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PMatchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PMatchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PMatchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PMatchInfo.Merge(m, src)
}
func (m *PMatchInfo) XXX_Size() int {
	return m.Size()
}
func (m *PMatchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PMatchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PMatchInfo proto.InternalMessageInfo

type PMatchListReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PMatchListReq) Reset()         { *m = PMatchListReq{} }
func (m *PMatchListReq) String() string { return proto.CompactTextString(m) }
func (*PMatchListReq) ProtoMessage()    {}
func (*PMatchListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{20}
}
func (m *PMatchListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PMatchListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PMatchListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PMatchListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PMatchListReq.Merge(m, src)
}
func (m *PMatchListReq) XXX_Size() int {
	return m.Size()
}
func (m *PMatchListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PMatchListReq.DiscardUnknown(m)
}

var xxx_messageInfo_PMatchListReq proto.InternalMessageInfo

type PMatchListRsp struct {
	Code                 int32         `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string        `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	MatchList            []*PMatchInfo `protobuf:"bytes,3,rep,name=MatchList,proto3" json:"MatchList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PMatchListRsp) Reset()         { *m = PMatchListRsp{} }
func (m *PMatchListRsp) String() string { return proto.CompactTextString(m) }
func (*PMatchListRsp) ProtoMessage()    {}
func (*PMatchListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{21}
}
func (m *PMatchListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PMatchListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PMatchListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PMatchListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PMatchListRsp.Merge(m, src)
}
func (m *PMatchListRsp) XXX_Size() int {
	return m.Size()
}
func (m *PMatchListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PMatchListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PMatchListRsp proto.InternalMessageInfo

type PSignUpReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name"`
	Head                 string   `protobuf:"bytes,3,opt,name=Head,proto3" json:"Head"`
	Type                 int32    `protobuf:"varint,4,opt,name=Type,proto3" json:"Type"`
	Id                   int32    `protobuf:"varint,5,opt,name=Id,proto3" json:"Id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PSignUpReq) Reset()         { *m = PSignUpReq{} }
func (m *PSignUpReq) String() string { return proto.CompactTextString(m) }
func (*PSignUpReq) ProtoMessage()    {}
func (*PSignUpReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{22}
}
func (m *PSignUpReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PSignUpReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PSignUpReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PSignUpReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PSignUpReq.Merge(m, src)
}
func (m *PSignUpReq) XXX_Size() int {
	return m.Size()
}
func (m *PSignUpReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PSignUpReq.DiscardUnknown(m)
}

var xxx_messageInfo_PSignUpReq proto.InternalMessageInfo

type PSignUpRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	Type                 int32    `protobuf:"varint,4,opt,name=Type,proto3" json:"Type"`
	Id                   int32    `protobuf:"varint,5,opt,name=Id,proto3" json:"Id"`
	Money                int64    `protobuf:"varint,6,opt,name=Money,proto3" json:"Money"`
	Core                 int32    `protobuf:"varint,7,opt,name=Core,proto3" json:"Core"`
	Url                  string   `protobuf:"bytes,8,opt,name=Url,proto3" json:"Url"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PSignUpRsp) Reset()         { *m = PSignUpRsp{} }
func (m *PSignUpRsp) String() string { return proto.CompactTextString(m) }
func (*PSignUpRsp) ProtoMessage()    {}
func (*PSignUpRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{23}
}
func (m *PSignUpRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PSignUpRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PSignUpRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PSignUpRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PSignUpRsp.Merge(m, src)
}
func (m *PSignUpRsp) XXX_Size() int {
	return m.Size()
}
func (m *PSignUpRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PSignUpRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PSignUpRsp proto.InternalMessageInfo

//-------------------------快速赛-----------------------------------
type FMatchInfo struct {
	Type                 int32           `protobuf:"varint,1,opt,name=Type,proto3" json:"Type"`
	TypeTips             string          `protobuf:"bytes,2,opt,name=TypeTips,proto3" json:"TypeTips"`
	Id                   int32           `protobuf:"varint,3,opt,name=Id,proto3" json:"Id"`
	OpenTime             string          `protobuf:"bytes,4,opt,name=OpenTime,proto3" json:"OpenTime"`
	PlayerTimes          int32           `protobuf:"varint,5,opt,name=PlayerTimes,proto3" json:"PlayerTimes"`
	JoinTimes            int32           `protobuf:"varint,6,opt,name=JoinTimes,proto3" json:"JoinTimes"`
	TotalTimes           int32           `protobuf:"varint,7,opt,name=TotalTimes,proto3" json:"TotalTimes"`
	MatchTime            int32           `protobuf:"varint,8,opt,name=MatchTime,proto3" json:"MatchTime"`
	ConditionList        []*Condition    `protobuf:"bytes,9,rep,name=ConditionList,proto3" json:"ConditionList,omitempty"`
	RankInfoList         []*RankListInfo `protobuf:"bytes,10,rep,name=RankInfoList,proto3" json:"RankInfoList,omitempty"`
	Status               int32           `protobuf:"varint,11,opt,name=Status,proto3" json:"Status"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *FMatchInfo) Reset()         { *m = FMatchInfo{} }
func (m *FMatchInfo) String() string { return proto.CompactTextString(m) }
func (*FMatchInfo) ProtoMessage()    {}
func (*FMatchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{24}
}
func (m *FMatchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FMatchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FMatchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FMatchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FMatchInfo.Merge(m, src)
}
func (m *FMatchInfo) XXX_Size() int {
	return m.Size()
}
func (m *FMatchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FMatchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FMatchInfo proto.InternalMessageInfo

type FMatchListReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FMatchListReq) Reset()         { *m = FMatchListReq{} }
func (m *FMatchListReq) String() string { return proto.CompactTextString(m) }
func (*FMatchListReq) ProtoMessage()    {}
func (*FMatchListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{25}
}
func (m *FMatchListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FMatchListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FMatchListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FMatchListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FMatchListReq.Merge(m, src)
}
func (m *FMatchListReq) XXX_Size() int {
	return m.Size()
}
func (m *FMatchListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FMatchListReq.DiscardUnknown(m)
}

var xxx_messageInfo_FMatchListReq proto.InternalMessageInfo

type FMatchListRsp struct {
	Code                 int32         `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string        `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	MatchList            []*FMatchInfo `protobuf:"bytes,3,rep,name=MatchList,proto3" json:"MatchList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FMatchListRsp) Reset()         { *m = FMatchListRsp{} }
func (m *FMatchListRsp) String() string { return proto.CompactTextString(m) }
func (*FMatchListRsp) ProtoMessage()    {}
func (*FMatchListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{26}
}
func (m *FMatchListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FMatchListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FMatchListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FMatchListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FMatchListRsp.Merge(m, src)
}
func (m *FMatchListRsp) XXX_Size() int {
	return m.Size()
}
func (m *FMatchListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FMatchListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FMatchListRsp proto.InternalMessageInfo

type FWaitMatchReq struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type"`
	Id                   int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FWaitMatchReq) Reset()         { *m = FWaitMatchReq{} }
func (m *FWaitMatchReq) String() string { return proto.CompactTextString(m) }
func (*FWaitMatchReq) ProtoMessage()    {}
func (*FWaitMatchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{27}
}
func (m *FWaitMatchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FWaitMatchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FWaitMatchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FWaitMatchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FWaitMatchReq.Merge(m, src)
}
func (m *FWaitMatchReq) XXX_Size() int {
	return m.Size()
}
func (m *FWaitMatchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FWaitMatchReq.DiscardUnknown(m)
}

var xxx_messageInfo_FWaitMatchReq proto.InternalMessageInfo

type FWaitMatchRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	Type                 int32    `protobuf:"varint,3,opt,name=Type,proto3" json:"Type"`
	Id                   int32    `protobuf:"varint,4,opt,name=Id,proto3" json:"Id"`
	PlayerId             int32    `protobuf:"varint,5,opt,name=PlayerId,proto3" json:"PlayerId"`
	Status               int32    `protobuf:"varint,6,opt,name=Status,proto3" json:"Status"`
	Join                 int32    `protobuf:"varint,7,opt,name=Join,proto3" json:"Join"`
	Total                int32    `protobuf:"varint,8,opt,name=Total,proto3" json:"Total"`
	Url                  string   `protobuf:"bytes,9,opt,name=Url,proto3" json:"Url"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FWaitMatchRsp) Reset()         { *m = FWaitMatchRsp{} }
func (m *FWaitMatchRsp) String() string { return proto.CompactTextString(m) }
func (*FWaitMatchRsp) ProtoMessage()    {}
func (*FWaitMatchRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{28}
}
func (m *FWaitMatchRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FWaitMatchRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FWaitMatchRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FWaitMatchRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FWaitMatchRsp.Merge(m, src)
}
func (m *FWaitMatchRsp) XXX_Size() int {
	return m.Size()
}
func (m *FWaitMatchRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FWaitMatchRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FWaitMatchRsp proto.InternalMessageInfo

type FCancelMatchReq struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type"`
	Id                   int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FCancelMatchReq) Reset()         { *m = FCancelMatchReq{} }
func (m *FCancelMatchReq) String() string { return proto.CompactTextString(m) }
func (*FCancelMatchReq) ProtoMessage()    {}
func (*FCancelMatchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{29}
}
func (m *FCancelMatchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FCancelMatchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FCancelMatchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FCancelMatchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FCancelMatchReq.Merge(m, src)
}
func (m *FCancelMatchReq) XXX_Size() int {
	return m.Size()
}
func (m *FCancelMatchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FCancelMatchReq.DiscardUnknown(m)
}

var xxx_messageInfo_FCancelMatchReq proto.InternalMessageInfo

type FCancelMatchRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	Type                 int32    `protobuf:"varint,3,opt,name=Type,proto3" json:"Type"`
	Id                   int32    `protobuf:"varint,4,opt,name=Id,proto3" json:"Id"`
	PlayerId             int32    `protobuf:"varint,5,opt,name=PlayerId,proto3" json:"PlayerId"`
	Result               int32    `protobuf:"varint,6,opt,name=Result,proto3" json:"Result"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FCancelMatchRsp) Reset()         { *m = FCancelMatchRsp{} }
func (m *FCancelMatchRsp) String() string { return proto.CompactTextString(m) }
func (*FCancelMatchRsp) ProtoMessage()    {}
func (*FCancelMatchRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{30}
}
func (m *FCancelMatchRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FCancelMatchRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FCancelMatchRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FCancelMatchRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FCancelMatchRsp.Merge(m, src)
}
func (m *FCancelMatchRsp) XXX_Size() int {
	return m.Size()
}
func (m *FCancelMatchRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FCancelMatchRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FCancelMatchRsp proto.InternalMessageInfo

type PositionInfo struct {
	Latitude             float64  `protobuf:"fixed64,1,opt,name=Latitude,proto3" json:"Latitude"`
	Longitude            float64  `protobuf:"fixed64,2,opt,name=Longitude,proto3" json:"Longitude"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PositionInfo) Reset()         { *m = PositionInfo{} }
func (m *PositionInfo) String() string { return proto.CompactTextString(m) }
func (*PositionInfo) ProtoMessage()    {}
func (*PositionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{31}
}
func (m *PositionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionInfo.Merge(m, src)
}
func (m *PositionInfo) XXX_Size() int {
	return m.Size()
}
func (m *PositionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PositionInfo proto.InternalMessageInfo

type FSignUpReq struct {
	PlayerId             int32         `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	Name                 string        `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name"`
	Head                 string        `protobuf:"bytes,3,opt,name=Head,proto3" json:"Head"`
	Type                 int32         `protobuf:"varint,4,opt,name=Type,proto3" json:"Type"`
	Id                   int32         `protobuf:"varint,5,opt,name=Id,proto3" json:"Id"`
	Ip                   string        `protobuf:"bytes,6,opt,name=Ip,proto3" json:"Ip"`
	Position             *PositionInfo `protobuf:"bytes,7,opt,name=Position,proto3" json:"Position"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FSignUpReq) Reset()         { *m = FSignUpReq{} }
func (m *FSignUpReq) String() string { return proto.CompactTextString(m) }
func (*FSignUpReq) ProtoMessage()    {}
func (*FSignUpReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{32}
}
func (m *FSignUpReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FSignUpReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FSignUpReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FSignUpReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FSignUpReq.Merge(m, src)
}
func (m *FSignUpReq) XXX_Size() int {
	return m.Size()
}
func (m *FSignUpReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FSignUpReq.DiscardUnknown(m)
}

var xxx_messageInfo_FSignUpReq proto.InternalMessageInfo

type FSignUpRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	Type                 int32    `protobuf:"varint,4,opt,name=Type,proto3" json:"Type"`
	Id                   int32    `protobuf:"varint,5,opt,name=Id,proto3" json:"Id"`
	Core                 int32    `protobuf:"varint,6,opt,name=Core,proto3" json:"Core"`
	Url                  string   `protobuf:"bytes,7,opt,name=Url,proto3" json:"Url"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FSignUpRsp) Reset()         { *m = FSignUpRsp{} }
func (m *FSignUpRsp) String() string { return proto.CompactTextString(m) }
func (*FSignUpRsp) ProtoMessage()    {}
func (*FSignUpRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{33}
}
func (m *FSignUpRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FSignUpRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FSignUpRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FSignUpRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FSignUpRsp.Merge(m, src)
}
func (m *FSignUpRsp) XXX_Size() int {
	return m.Size()
}
func (m *FSignUpRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FSignUpRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FSignUpRsp proto.InternalMessageInfo

type FConfirmReq struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type"`
	Id                   int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FConfirmReq) Reset()         { *m = FConfirmReq{} }
func (m *FConfirmReq) String() string { return proto.CompactTextString(m) }
func (*FConfirmReq) ProtoMessage()    {}
func (*FConfirmReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{34}
}
func (m *FConfirmReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FConfirmReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FConfirmReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FConfirmReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FConfirmReq.Merge(m, src)
}
func (m *FConfirmReq) XXX_Size() int {
	return m.Size()
}
func (m *FConfirmReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FConfirmReq.DiscardUnknown(m)
}

var xxx_messageInfo_FConfirmReq proto.InternalMessageInfo

type FConfirmRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	Type                 int32    `protobuf:"varint,3,opt,name=Type,proto3" json:"Type"`
	Id                   int32    `protobuf:"varint,4,opt,name=Id,proto3" json:"Id"`
	PlayerId             int32    `protobuf:"varint,5,opt,name=PlayerId,proto3" json:"PlayerId"`
	Result               int32    `protobuf:"varint,6,opt,name=Result,proto3" json:"Result"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FConfirmRsp) Reset()         { *m = FConfirmRsp{} }
func (m *FConfirmRsp) String() string { return proto.CompactTextString(m) }
func (*FConfirmRsp) ProtoMessage()    {}
func (*FConfirmRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{35}
}
func (m *FConfirmRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FConfirmRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FConfirmRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FConfirmRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FConfirmRsp.Merge(m, src)
}
func (m *FConfirmRsp) XXX_Size() int {
	return m.Size()
}
func (m *FConfirmRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FConfirmRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FConfirmRsp proto.InternalMessageInfo

type FRobotLoginReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FRobotLoginReq) Reset()         { *m = FRobotLoginReq{} }
func (m *FRobotLoginReq) String() string { return proto.CompactTextString(m) }
func (*FRobotLoginReq) ProtoMessage()    {}
func (*FRobotLoginReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{36}
}
func (m *FRobotLoginReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FRobotLoginReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FRobotLoginReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FRobotLoginReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FRobotLoginReq.Merge(m, src)
}
func (m *FRobotLoginReq) XXX_Size() int {
	return m.Size()
}
func (m *FRobotLoginReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FRobotLoginReq.DiscardUnknown(m)
}

var xxx_messageInfo_FRobotLoginReq proto.InternalMessageInfo

type FRobotLoginRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	Core                 int32    `protobuf:"varint,4,opt,name=Core,proto3" json:"Core"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FRobotLoginRsp) Reset()         { *m = FRobotLoginRsp{} }
func (m *FRobotLoginRsp) String() string { return proto.CompactTextString(m) }
func (*FRobotLoginRsp) ProtoMessage()    {}
func (*FRobotLoginRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{37}
}
func (m *FRobotLoginRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FRobotLoginRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FRobotLoginRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FRobotLoginRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FRobotLoginRsp.Merge(m, src)
}
func (m *FRobotLoginRsp) XXX_Size() int {
	return m.Size()
}
func (m *FRobotLoginRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FRobotLoginRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FRobotLoginRsp proto.InternalMessageInfo

type FRobotJoinMatchRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	Type                 int32    `protobuf:"varint,4,opt,name=Type,proto3" json:"Type"`
	Id                   int32    `protobuf:"varint,5,opt,name=Id,proto3" json:"Id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FRobotJoinMatchRsp) Reset()         { *m = FRobotJoinMatchRsp{} }
func (m *FRobotJoinMatchRsp) String() string { return proto.CompactTextString(m) }
func (*FRobotJoinMatchRsp) ProtoMessage()    {}
func (*FRobotJoinMatchRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{38}
}
func (m *FRobotJoinMatchRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FRobotJoinMatchRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FRobotJoinMatchRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FRobotJoinMatchRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FRobotJoinMatchRsp.Merge(m, src)
}
func (m *FRobotJoinMatchRsp) XXX_Size() int {
	return m.Size()
}
func (m *FRobotJoinMatchRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FRobotJoinMatchRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FRobotJoinMatchRsp proto.InternalMessageInfo

type FRobotHeartReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FRobotHeartReq) Reset()         { *m = FRobotHeartReq{} }
func (m *FRobotHeartReq) String() string { return proto.CompactTextString(m) }
func (*FRobotHeartReq) ProtoMessage()    {}
func (*FRobotHeartReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{39}
}
func (m *FRobotHeartReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FRobotHeartReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FRobotHeartReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FRobotHeartReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FRobotHeartReq.Merge(m, src)
}
func (m *FRobotHeartReq) XXX_Size() int {
	return m.Size()
}
func (m *FRobotHeartReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FRobotHeartReq.DiscardUnknown(m)
}

var xxx_messageInfo_FRobotHeartReq proto.InternalMessageInfo

type FRobotHeartRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	Core                 int32    `protobuf:"varint,4,opt,name=Core,proto3" json:"Core"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FRobotHeartRsp) Reset()         { *m = FRobotHeartRsp{} }
func (m *FRobotHeartRsp) String() string { return proto.CompactTextString(m) }
func (*FRobotHeartRsp) ProtoMessage()    {}
func (*FRobotHeartRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{40}
}
func (m *FRobotHeartRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FRobotHeartRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FRobotHeartRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FRobotHeartRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FRobotHeartRsp.Merge(m, src)
}
func (m *FRobotHeartRsp) XXX_Size() int {
	return m.Size()
}
func (m *FRobotHeartRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FRobotHeartRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FRobotHeartRsp proto.InternalMessageInfo

type GameUserInfoReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameUserInfoReq) Reset()         { *m = GameUserInfoReq{} }
func (m *GameUserInfoReq) String() string { return proto.CompactTextString(m) }
func (*GameUserInfoReq) ProtoMessage()    {}
func (*GameUserInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{41}
}
func (m *GameUserInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameUserInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameUserInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameUserInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameUserInfoReq.Merge(m, src)
}
func (m *GameUserInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *GameUserInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GameUserInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_GameUserInfoReq proto.InternalMessageInfo

type GameUserInfoRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	GameType             int32    `protobuf:"varint,3,opt,name=GameType,proto3" json:"GameType"`
	PlayerId             int32    `protobuf:"varint,4,opt,name=playerId,proto3" json:"playerId"`
	Count                int32    `protobuf:"varint,5,opt,name=Count,proto3" json:"Count"`
	Status               int32    `protobuf:"varint,6,opt,name=Status,proto3" json:"Status"`
	Tips                 string   `protobuf:"bytes,7,opt,name=Tips,proto3" json:"Tips"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameUserInfoRsp) Reset()         { *m = GameUserInfoRsp{} }
func (m *GameUserInfoRsp) String() string { return proto.CompactTextString(m) }
func (*GameUserInfoRsp) ProtoMessage()    {}
func (*GameUserInfoRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{42}
}
func (m *GameUserInfoRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameUserInfoRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameUserInfoRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameUserInfoRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameUserInfoRsp.Merge(m, src)
}
func (m *GameUserInfoRsp) XXX_Size() int {
	return m.Size()
}
func (m *GameUserInfoRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GameUserInfoRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GameUserInfoRsp proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("arena.service.v1.ArenaMsgCode", ArenaMsgCode_name, ArenaMsgCode_value)
	proto.RegisterEnum("arena.service.v1.ArenaMsgErrorCode", ArenaMsgErrorCode_name, ArenaMsgErrorCode_value)
	proto.RegisterType((*HttpCommonRsp)(nil), "arena.service.v1.HttpCommonRsp")
	proto.RegisterType((*MatchStatusReq)(nil), "arena.service.v1.MatchStatusReq")
	proto.RegisterType((*MatchTips)(nil), "arena.service.v1.MatchTips")
	proto.RegisterType((*MatchStatusRsp)(nil), "arena.service.v1.MatchStatusRsp")
	proto.RegisterType((*ShareStatusReq)(nil), "arena.service.v1.ShareStatusReq")
	proto.RegisterType((*ShareStatusRsp)(nil), "arena.service.v1.ShareStatusRsp")
	proto.RegisterType((*Award)(nil), "arena.service.v1.Award")
	proto.RegisterType((*AwardInfo)(nil), "arena.service.v1.AwardInfo")
	proto.RegisterType((*AwardListReq)(nil), "arena.service.v1.AwardListReq")
	proto.RegisterType((*AwardListRsp)(nil), "arena.service.v1.AwardListRsp")
	proto.RegisterType((*GetAwardData)(nil), "arena.service.v1.GetAwardData")
	proto.RegisterType((*GetAwardReq)(nil), "arena.service.v1.GetAwardReq")
	proto.RegisterType((*GetAwardRsp)(nil), "arena.service.v1.GetAwardRsp")
	proto.RegisterType((*AwardCountReq)(nil), "arena.service.v1.AwardCountReq")
	proto.RegisterType((*AwardCountRsp)(nil), "arena.service.v1.AwardCountRsp")
	proto.RegisterType((*RankListReq)(nil), "arena.service.v1.RankListReq")
	proto.RegisterType((*RankListInfo)(nil), "arena.service.v1.RankListInfo")
	proto.RegisterType((*RankListRsp)(nil), "arena.service.v1.RankListRsp")
	proto.RegisterType((*Condition)(nil), "arena.service.v1.Condition")
	proto.RegisterType((*PMatchInfo)(nil), "arena.service.v1.PMatchInfo")
	proto.RegisterType((*PMatchListReq)(nil), "arena.service.v1.PMatchListReq")
	proto.RegisterType((*PMatchListRsp)(nil), "arena.service.v1.PMatchListRsp")
	proto.RegisterType((*PSignUpReq)(nil), "arena.service.v1.PSignUpReq")
	proto.RegisterType((*PSignUpRsp)(nil), "arena.service.v1.PSignUpRsp")
	proto.RegisterType((*FMatchInfo)(nil), "arena.service.v1.FMatchInfo")
	proto.RegisterType((*FMatchListReq)(nil), "arena.service.v1.FMatchListReq")
	proto.RegisterType((*FMatchListRsp)(nil), "arena.service.v1.FMatchListRsp")
	proto.RegisterType((*FWaitMatchReq)(nil), "arena.service.v1.FWaitMatchReq")
	proto.RegisterType((*FWaitMatchRsp)(nil), "arena.service.v1.FWaitMatchRsp")
	proto.RegisterType((*FCancelMatchReq)(nil), "arena.service.v1.FCancelMatchReq")
	proto.RegisterType((*FCancelMatchRsp)(nil), "arena.service.v1.FCancelMatchRsp")
	proto.RegisterType((*PositionInfo)(nil), "arena.service.v1.PositionInfo")
	proto.RegisterType((*FSignUpReq)(nil), "arena.service.v1.FSignUpReq")
	proto.RegisterType((*FSignUpRsp)(nil), "arena.service.v1.FSignUpRsp")
	proto.RegisterType((*FConfirmReq)(nil), "arena.service.v1.FConfirmReq")
	proto.RegisterType((*FConfirmRsp)(nil), "arena.service.v1.FConfirmRsp")
	proto.RegisterType((*FRobotLoginReq)(nil), "arena.service.v1.FRobotLoginReq")
	proto.RegisterType((*FRobotLoginRsp)(nil), "arena.service.v1.FRobotLoginRsp")
	proto.RegisterType((*FRobotJoinMatchRsp)(nil), "arena.service.v1.FRobotJoinMatchRsp")
	proto.RegisterType((*FRobotHeartReq)(nil), "arena.service.v1.FRobotHeartReq")
	proto.RegisterType((*FRobotHeartRsp)(nil), "arena.service.v1.FRobotHeartRsp")
	proto.RegisterType((*GameUserInfoReq)(nil), "arena.service.v1.GameUserInfoReq")
	proto.RegisterType((*GameUserInfoRsp)(nil), "arena.service.v1.GameUserInfoRsp")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 2524 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x3a, 0xcd, 0x6f, 0x1c, 0x49,
	0xf5, 0xe9, 0xf9, 0xb0, 0x67, 0xde, 0x8c, 0xed, 0x4e, 0x67, 0x93, 0x4c, 0x26, 0x89, 0xc7, 0xe9,
	0xfd, 0xad, 0x64, 0x6d, 0xf4, 0xb3, 0xb5, 0x59, 0x16, 0x36, 0xd9, 0x05, 0x94, 0x4c, 0xa6, 0x13,
	0xaf, 0x62, 0xc7, 0xaa, 0x89, 0x83, 0xc4, 0xc5, 0xea, 0x78, 0x2a, 0x93, 0xd6, 0xce, 0x74, 0x77,
	0xba, 0x7b, 0xbc, 0x31, 0x88, 0xcb, 0x82, 0x38, 0x2c, 0x02, 0x21, 0x71, 0xe0, 0x43, 0x42, 0x5c,
	0xb9, 0xc2, 0x09, 0x2e, 0x1c, 0x38, 0xed, 0x0d, 0x24, 0x04, 0x07, 0x0e, 0x16, 0x04, 0x4e, 0xf3,
	0x27, 0x20, 0x81, 0x50, 0xbd, 0xaa, 0xae, 0xae, 0x19, 0xf7, 0xb4, 0x3d, 0xbb, 0x8e, 0x77, 0xc3,
	0xa5, 0xbb, 0xea, 0xd5, 0xab, 0xf7, 0xfd, 0x5e, 0xbd, 0xa9, 0x1e, 0x28, 0xdb, 0xbe, 0xb3, 0xe2,
	0x07, 0x5e, 0xe4, 0x19, 0xba, 0x1d, 0x50, 0xd7, 0x5e, 0x09, 0x69, 0xb0, 0xeb, 0xec, 0xd0, 0x95,
	0xdd, 0x37, 0xea, 0xff, 0xdf, 0x75, 0xa2, 0x27, 0x83, 0x47, 0x2b, 0x3b, 0x5e, 0x7f, 0xb5, 0xeb,
	0x75, 0xbd, 0x55, 0x44, 0x7c, 0x34, 0x78, 0x8c, 0x33, 0x9c, 0xe0, 0x88, 0x13, 0xa8, 0x5f, 0xea,
	0x7a, 0x5e, 0xb7, 0x47, 0x57, 0x6d, 0xdf, 0x59, 0xb5, 0x5d, 0xd7, 0x8b, 0xec, 0xc8, 0xf1, 0xdc,
	0x90, 0xaf, 0x9a, 0x1f, 0x69, 0x30, 0x77, 0x37, 0x8a, 0xfc, 0xa6, 0xd7, 0xef, 0x7b, 0x2e, 0x09,
	0x7d, 0xe3, 0x12, 0x14, 0x9a, 0x5e, 0x87, 0xd6, 0xb4, 0x25, 0x6d, 0xb9, 0x78, 0xab, 0x34, 0xdc,
	0x6f, 0xe0, 0x9c, 0xe0, 0xd3, 0x78, 0x0d, 0x66, 0xd7, 0x69, 0x18, 0xda, 0x5d, 0x5a, 0xcb, 0x2d,
	0x69, 0xcb, 0xe5, 0x5b, 0x95, 0xe1, 0x7e, 0x23, 0x06, 0x91, 0x78, 0x60, 0x9c, 0x83, 0x5c, 0xcb,
	0xad, 0xe5, 0x91, 0xc4, 0xcc, 0x70, 0xbf, 0x91, 0x6b, 0xb9, 0x24, 0xd7, 0x72, 0x19, 0xf1, 0xdb,
	0x76, 0x64, 0xd7, 0x0a, 0x4b, 0xda, 0x72, 0x95, 0x13, 0x67, 0x73, 0x82, 0x4f, 0xf3, 0x06, 0xcc,
	0xaf, 0xdb, 0xd1, 0xce, 0x93, 0x76, 0x64, 0x47, 0x83, 0x90, 0xd0, 0xa7, 0xc6, 0x32, 0x94, 0x36,
	0x7b, 0xf6, 0x1e, 0x0d, 0xd6, 0x3a, 0x42, 0xa0, 0xea, 0x70, 0xbf, 0x21, 0x61, 0x44, 0x8e, 0xcc,
	0x6f, 0x41, 0x19, 0xf7, 0x3e, 0x70, 0xfc, 0x90, 0x6d, 0xbb, 0x63, 0xf7, 0xe9, 0x83, 0x3d, 0x9f,
	0xaa, 0xdb, 0x62, 0x18, 0x91, 0x23, 0x26, 0x10, 0x62, 0xe5, 0x12, 0x6d, 0x11, 0x03, 0x9f, 0x8c,
	0x0e, 0x7b, 0x33, 0x9a, 0xa8, 0x4c, 0x99, 0xd3, 0x89, 0x61, 0x44, 0x8e, 0xcc, 0xef, 0x6a, 0xa3,
	0xb2, 0x1f, 0x97, 0x21, 0x57, 0xa1, 0x20, 0xb8, 0xe7, 0x97, 0x2b, 0xd7, 0x2e, 0xae, 0x8c, 0x47,
	0xc3, 0x8a, 0x54, 0x9a, 0x20, 0x22, 0xb3, 0x61, 0xfb, 0x89, 0x1d, 0xd0, 0x4f, 0x62, 0xc3, 0x9f,
	0x6b, 0xa3, 0x9b, 0x8f, 0x4b, 0x09, 0x55, 0x82, 0x7c, 0x96, 0x04, 0x9c, 0x5d, 0x40, 0x31, 0x3e,
	0x24, 0xbb, 0x00, 0xd9, 0x05, 0xd4, 0xdc, 0x82, 0xe2, 0xcd, 0x0f, 0xec, 0xa0, 0xc3, 0xc2, 0x4b,
	0x2a, 0x83, 0xe1, 0xb5, 0xd6, 0x21, 0xb9, 0xb5, 0x8e, 0x71, 0x01, 0xf2, 0x1b, 0x83, 0x3e, 0xca,
	0x92, 0xbf, 0x35, 0x3b, 0xdc, 0x6f, 0xb0, 0x29, 0x61, 0x0f, 0xb6, 0xb4, 0x3e, 0x78, 0x26, 0xd8,
	0xe3, 0xd2, 0xfa, 0xe0, 0x19, 0x61, 0x0f, 0xf3, 0x0f, 0x1a, 0x94, 0x91, 0xee, 0x9a, 0xfb, 0xd8,
	0x63, 0x3a, 0xf1, 0x09, 0x67, 0x20, 0x74, 0x12, 0x20, 0x12, 0x0f, 0x0c, 0x13, 0x66, 0xd6, 0xbd,
	0x0e, 0x5d, 0xeb, 0x88, 0xd0, 0x81, 0xe1, 0x7e, 0x43, 0x40, 0x88, 0x78, 0x1f, 0x3d, 0x7c, 0x8c,
	0x55, 0x98, 0x41, 0xc2, 0x61, 0xad, 0x80, 0x8e, 0x3e, 0x7f, 0xd0, 0xd1, 0xb8, 0x4e, 0x04, 0x9a,
	0x48, 0x24, 0x5a, 0x2b, 0x22, 0xd9, 0x38, 0x91, 0x28, 0x26, 0x12, 0x35, 0xdf, 0x86, 0x2a, 0xe2,
	0xdd, 0x73, 0xc2, 0x68, 0xba, 0x10, 0xf8, 0x81, 0xa6, 0x6e, 0x3d, 0xae, 0x00, 0xb8, 0x2e, 0x0c,
	0xcc, 0x88, 0x4e, 0x0e, 0x65, 0xe9, 0x03, 0x92, 0x60, 0x9b, 0x0f, 0xa1, 0x7a, 0x87, 0x46, 0x38,
	0x67, 0x35, 0xe2, 0xa8, 0xee, 0x69, 0x40, 0x71, 0xf3, 0x89, 0xe7, 0xc6, 0x62, 0x95, 0x87, 0xfb,
	0x0d, 0x0e, 0x20, 0xfc, 0x65, 0x0e, 0xa0, 0x12, 0xd3, 0x9d, 0xca, 0x42, 0xc6, 0xbb, 0xaa, 0x2e,
	0x39, 0xd4, 0x65, 0xf1, 0xa0, 0x2e, 0xaa, 0xcc, 0xaa, 0x3a, 0x7f, 0xd6, 0x14, 0xbe, 0x27, 0x9f,
	0x5f, 0x4b, 0x50, 0x11, 0x16, 0x42, 0xf1, 0x59, 0xb0, 0x95, 0x89, 0x0a, 0x32, 0xde, 0x52, 0xd5,
	0x2b, 0x66, 0x07, 0xa3, 0xa2, 0xd7, 0x75, 0x98, 0xc3, 0x49, 0xd3, 0x1b, 0xb8, 0x53, 0x86, 0xdc,
	0x2f, 0xb4, 0x91, 0xbd, 0x27, 0x6f, 0x94, 0x06, 0x14, 0x91, 0xb5, 0xa8, 0x3a, 0x18, 0x2b, 0x5c,
	0x16, 0xfe, 0x32, 0x3f, 0xd4, 0xa0, 0x42, 0x6c, 0xf7, 0xfd, 0xa9, 0xd3, 0x89, 0x69, 0x12, 0x8d,
	0x1d, 0x2f, 0x11, 0x1e, 0x2f, 0xec, 0x69, 0x5c, 0x85, 0xf2, 0x4d, 0x66, 0x59, 0x3c, 0x81, 0xb8,
	0x8c, 0x73, 0xc3, 0xfd, 0x46, 0x02, 0x24, 0xc9, 0xd0, 0xfc, 0x5d, 0x0e, 0xaa, 0xb1, 0x10, 0x58,
	0xa8, 0xae, 0x42, 0xb9, 0x1d, 0xd9, 0x41, 0xc4, 0x80, 0x42, 0x0c, 0xdc, 0x2d, 0x81, 0x24, 0x19,
	0x32, 0xa3, 0xb5, 0xdc, 0x0e, 0xa2, 0x72, 0x59, 0xd0, 0x68, 0x02, 0x44, 0xe2, 0x01, 0xd3, 0x6c,
	0x2b, 0xa4, 0x81, 0x22, 0x10, 0x6a, 0x16, 0xc3, 0x88, 0x1c, 0x31, 0xcd, 0x36, 0xec, 0x3e, 0xaf,
	0xd4, 0xa2, 0x00, 0xb1, 0x39, 0xc1, 0x27, 0x5b, 0x5d, 0xdb, 0xf1, 0x5c, 0xb5, 0x3c, 0xb1, 0x39,
	0xc1, 0x27, 0x5b, 0x5d, 0xb7, 0x83, 0xf7, 0x6b, 0x33, 0x89, 0x55, 0xd8, 0x9c, 0xe0, 0x73, 0x34,
	0x02, 0x67, 0x8f, 0x1a, 0x81, 0xcc, 0x8b, 0x4c, 0xdd, 0xb0, 0x56, 0x5a, 0xd2, 0x96, 0x4b, 0xdc,
	0x8b, 0x08, 0x20, 0xfc, 0x65, 0xfe, 0x3e, 0xa7, 0x78, 0xf1, 0xb8, 0xa2, 0x2c, 0xee, 0x1f, 0xf2,
	0xa9, 0xfd, 0xc3, 0x88, 0x83, 0x0b, 0xd9, 0x0e, 0x36, 0x6e, 0x40, 0x29, 0x16, 0x4f, 0x24, 0x5e,
	0x4a, 0x5d, 0x51, 0x23, 0x80, 0x48, 0x7c, 0x26, 0x06, 0xfa, 0x56, 0xb1, 0x28, 0x3a, 0x16, 0x9f,
	0x4c, 0x8c, 0x07, 0x5e, 0x64, 0xf7, 0x10, 0x65, 0x36, 0x11, 0x43, 0x02, 0x49, 0x32, 0x94, 0xce,
	0x29, 0xa5, 0x39, 0xc7, 0x7c, 0x0f, 0xca, 0x4d, 0xcf, 0xed, 0x38, 0xac, 0x87, 0x94, 0xca, 0x6b,
	0xa9, 0xca, 0x37, 0xa0, 0xf8, 0xd0, 0xee, 0x0d, 0xe2, 0xe0, 0x47, 0x87, 0x20, 0x80, 0xf0, 0x97,
	0xf9, 0xaf, 0x3c, 0xc0, 0x26, 0xf6, 0x2f, 0x18, 0xcf, 0xd9, 0xd4, 0xd4, 0xb3, 0x34, 0x97, 0x79,
	0x96, 0xf2, 0xe6, 0x20, 0x7f, 0xa0, 0x39, 0xb8, 0x0a, 0xe5, 0xf7, 0x3c, 0xc7, 0x7d, 0xe0, 0xf4,
	0x69, 0xa8, 0x3a, 0x43, 0x02, 0x49, 0x32, 0x34, 0x56, 0x00, 0xd0, 0x24, 0x1c, 0xbb, 0x88, 0xd8,
	0xf3, 0xc3, 0xfd, 0x86, 0x02, 0x25, 0xca, 0x58, 0x9e, 0xc7, 0x33, 0x69, 0xe7, 0x31, 0x6b, 0x16,
	0x78, 0x4b, 0x25, 0xac, 0x8f, 0xcd, 0x82, 0x68, 0xb2, 0xc4, 0xdb, 0xb8, 0x09, 0x73, 0xd2, 0xb2,
	0x18, 0x03, 0xa5, 0x49, 0xe7, 0xa4, 0x44, 0x23, 0xa3, 0x3b, 0x64, 0x14, 0x94, 0x0f, 0x8f, 0x02,
	0x38, 0x24, 0x0a, 0x92, 0x86, 0xa4, 0x72, 0xb4, 0x86, 0x64, 0x05, 0x20, 0x29, 0xe2, 0xb5, 0x6a,
	0x62, 0x30, 0xa5, 0xb4, 0x2b, 0x63, 0x76, 0x60, 0x70, 0xdf, 0x4f, 0xdf, 0xa3, 0xfc, 0x50, 0x1b,
	0xd9, 0x7b, 0x5c, 0xa9, 0x7c, 0x43, 0xfc, 0x82, 0x50, 0x9a, 0x94, 0x4b, 0x07, 0xb5, 0x4e, 0x02,
	0x96, 0x24, 0xe8, 0xe6, 0x2f, 0x35, 0x80, 0xcd, 0xb6, 0xd3, 0x75, 0xb7, 0xfc, 0xa9, 0x0f, 0x08,
	0x2c, 0xa3, 0xb9, 0x49, 0x65, 0xf4, 0x2e, 0xb5, 0x3b, 0xa2, 0x79, 0xc4, 0x55, 0x36, 0x27, 0xf8,
	0x94, 0x09, 0x53, 0x48, 0x4d, 0x18, 0x9e, 0x06, 0xc5, 0xf1, 0x34, 0x30, 0xbf, 0x97, 0x4b, 0x44,
	0xfd, 0x4c, 0x1a, 0xfc, 0xe9, 0x65, 0x66, 0xa5, 0x64, 0xdd, 0x73, 0xe9, 0x1e, 0xa6, 0x57, 0x9e,
	0x97, 0x12, 0x04, 0x10, 0xfe, 0x92, 0xbf, 0x1b, 0x66, 0xd3, 0x7e, 0x37, 0xb0, 0xde, 0x7f, 0x2b,
	0xe8, 0x61, 0x45, 0x2b, 0xf3, 0xde, 0x7f, 0x2b, 0xe8, 0x11, 0xf6, 0x30, 0xff, 0x93, 0x07, 0xb0,
	0x4e, 0xae, 0x06, 0x2d, 0x43, 0xe9, 0xbe, 0x4f, 0xb1, 0xc6, 0x88, 0x93, 0x13, 0x29, 0xc4, 0x30,
	0x22, 0x47, 0xc6, 0x1b, 0x50, 0xe1, 0x46, 0x53, 0x2b, 0xd0, 0xc2, 0x70, 0xbf, 0xa1, 0x82, 0x89,
	0x3a, 0x19, 0x2d, 0x70, 0x33, 0x53, 0x15, 0xb8, 0xd9, 0x43, 0x0b, 0xdc, 0x55, 0xf9, 0xfb, 0xba,
	0x4f, 0xc5, 0xd9, 0x80, 0xc4, 0x25, 0x90, 0x24, 0xc3, 0x83, 0xb5, 0xac, 0x3c, 0x75, 0x2d, 0xbb,
	0xc5, 0xbb, 0x1d, 0xe6, 0x15, 0xa4, 0x00, 0x47, 0x3a, 0x11, 0x47, 0xf6, 0x28, 0x65, 0xb7, 0x32,
	0xa9, 0xec, 0xb2, 0x3a, 0x64, 0x7d, 0x8a, 0x3a, 0x64, 0x7d, 0x56, 0x75, 0xc8, 0x4a, 0xad, 0x43,
	0x1e, 0xcc, 0x59, 0x5f, 0xb3, 0x9d, 0x08, 0x21, 0x4c, 0x9b, 0xec, 0x80, 0xe6, 0x61, 0x9a, 0x4b,
	0x0b, 0xd3, 0xa3, 0xe5, 0xb3, 0xf9, 0xeb, 0xdc, 0x08, 0xc7, 0x93, 0x69, 0xab, 0xb8, 0xd8, 0x85,
	0x4c, 0xb1, 0x8b, 0x99, 0x65, 0x28, 0x89, 0x8c, 0x99, 0x89, 0x07, 0xf2, 0x25, 0x28, 0xb0, 0x74,
	0x51, 0x6b, 0x0a, 0x9b, 0x13, 0x7c, 0xb2, 0x92, 0x84, 0xd9, 0x21, 0x72, 0x01, 0x4b, 0x12, 0x3f,
	0x3e, 0xf9, 0x2b, 0x2e, 0x3a, 0xe5, 0x94, 0xa2, 0xf3, 0x14, 0x16, 0xac, 0xa6, 0xed, 0xee, 0xd0,
	0xde, 0x89, 0xf9, 0xe9, 0xaf, 0xda, 0x18, 0xcf, 0x97, 0xc8, 0x53, 0x84, 0x86, 0x83, 0x5e, 0xa4,
	0x7a, 0x8a, 0x43, 0x88, 0x78, 0x9b, 0x14, 0xaa, 0x9b, 0x5e, 0x88, 0xb5, 0x03, 0xab, 0xf8, 0x32,
	0x94, 0xee, 0xd9, 0x91, 0x13, 0x0d, 0x84, 0x72, 0x1a, 0xa7, 0x1e, 0xc3, 0x88, 0x1c, 0xb1, 0xaa,
	0x76, 0xcf, 0x73, 0xbb, 0x1c, 0x35, 0x87, 0xa8, 0x58, 0xd5, 0x24, 0x90, 0x24, 0x43, 0xf3, 0xa3,
	0x1c, 0x80, 0xf5, 0x52, 0x1c, 0xf2, 0x08, 0xf7, 0x45, 0x33, 0xca, 0xe1, 0x3e, 0xc9, 0xad, 0xf9,
	0xc6, 0x5d, 0x28, 0xc5, 0x96, 0xc2, 0xb8, 0x4e, 0xad, 0xa8, 0xaa, 0x2d, 0x85, 0x4e, 0x02, 0x42,
	0xe4, 0xc8, 0x1c, 0x6a, 0x89, 0x31, 0x5e, 0x96, 0x36, 0x22, 0xee, 0x12, 0x66, 0xb2, 0xba, 0x84,
	0xd9, 0x94, 0x84, 0xed, 0x43, 0xc5, 0x6a, 0x7a, 0xee, 0x63, 0x27, 0xe8, 0x9f, 0x44, 0xb2, 0xfe,
	0x45, 0x53, 0xf8, 0xfd, 0x2f, 0x25, 0xea, 0x0d, 0x98, 0xb7, 0x88, 0xf7, 0xc8, 0x8b, 0xee, 0x79,
	0x5d, 0xc7, 0x9d, 0xfe, 0x72, 0x5a, 0xdd, 0xfc, 0x79, 0xbb, 0x9c, 0xfe, 0xad, 0x06, 0x06, 0x97,
	0x8f, 0x9d, 0x0f, 0xc7, 0x5b, 0x64, 0x5f, 0x70, 0x62, 0x24, 0x7e, 0xb9, 0x4b, 0xed, 0x20, 0xfa,
	0xa4, 0x7e, 0xe1, 0x9b, 0x3f, 0x6f, 0x7e, 0x79, 0x07, 0x16, 0xee, 0xd8, 0x7d, 0xba, 0x15, 0xd2,
	0x00, 0xbb, 0xa5, 0xa9, 0x94, 0xfb, 0x7e, 0x6e, 0x6c, 0xf7, 0x31, 0x6a, 0x27, 0xbf, 0x50, 0xe5,
	0x33, 0xbf, 0x50, 0x2d, 0x43, 0xc9, 0x8f, 0x85, 0x2d, 0x24, 0x98, 0xbe, 0x14, 0xd6, 0x3f, 0x70,
	0x8f, 0x59, 0x4c, 0xbf, 0xc7, 0x3c, 0x6a, 0xd7, 0x83, 0xbf, 0x6f, 0x66, 0x93, 0xd3, 0x28, 0xf9,
	0xba, 0xf4, 0xfa, 0xaf, 0x8a, 0x50, 0xc5, 0x1b, 0xab, 0xf5, 0xb0, 0x8b, 0xea, 0x2e, 0x40, 0xe5,
	0xe6, 0x7a, 0x73, 0x7b, 0xcd, 0xdd, 0xb5, 0x7b, 0x6b, 0x1d, 0xfd, 0x94, 0x71, 0x0e, 0x0c, 0x06,
	0x68, 0x6e, 0x6f, 0x2a, 0x9f, 0xc3, 0xf4, 0x45, 0x05, 0xae, 0x7c, 0x61, 0xd2, 0x1b, 0xc6, 0x2b,
	0xa0, 0x0b, 0xb8, 0xbc, 0xca, 0xd3, 0x97, 0x8c, 0x33, 0xb0, 0x20, 0xa0, 0xf1, 0x65, 0xb9, 0x7e,
	0xc5, 0x38, 0x0b, 0xa7, 0x55, 0x54, 0xd4, 0x49, 0x37, 0x15, 0xdc, 0xf8, 0xa7, 0x80, 0xfe, 0xaa,
	0x42, 0x56, 0x36, 0xc7, 0xfa, 0xff, 0x19, 0xa7, 0x61, 0x2e, 0x16, 0x02, 0x4f, 0x2e, 0xfd, 0xb5,
	0x44, 0x2e, 0x4b, 0x95, 0xf7, 0x9a, 0x02, 0x57, 0xe5, 0x7d, 0x33, 0x21, 0x6c, 0x25, 0xf2, 0x7e,
	0x21, 0x91, 0xc1, 0x92, 0xf2, 0xbe, 0x95, 0xc8, 0x6b, 0x29, 0xf2, 0x7e, 0x51, 0xc1, 0x95, 0xf2,
	0x7e, 0x49, 0x21, 0x9b, 0xc8, 0xfb, 0xb6, 0x02, 0x95, 0x2d, 0xb6, 0x7e, 0x5d, 0x11, 0x4d, 0x69,
	0xe8, 0xf4, 0x1b, 0x89, 0x76, 0xe2, 0x5c, 0xd6, 0xdf, 0x31, 0x0c, 0x98, 0x8f, 0x51, 0xf9, 0x71,
	0xa2, 0xbf, 0xab, 0x88, 0x95, 0x54, 0x53, 0xfd, 0xcb, 0xc6, 0x05, 0x38, 0xab, 0x82, 0x65, 0x11,
	0xd3, 0xbf, 0x32, 0xbe, 0x03, 0xf3, 0x5c, 0xff, 0xaa, 0x71, 0x1e, 0xce, 0x30, 0x70, 0x7b, 0x9b,
	0xc5, 0x2a, 0x6a, 0x77, 0xdb, 0xfb, 0xc0, 0xd5, 0x3b, 0xb1, 0x80, 0xed, 0x6d, 0x42, 0x7d, 0x2f,
	0x88, 0x84, 0xed, 0xa8, 0x71, 0x3e, 0x86, 0x6f, 0xf2, 0x05, 0x4e, 0xff, 0xdb, 0x9a, 0x71, 0x86,
	0x8b, 0xd9, 0xde, 0xde, 0x64, 0xa4, 0x5a, 0x6e, 0x47, 0xff, 0x8e, 0x96, 0x60, 0x5b, 0x2a, 0xf6,
	0x8f, 0x15, 0x6c, 0x2b, 0xc6, 0xfe, 0xa9, 0x66, 0xd4, 0xb8, 0x30, 0xb1, 0x8c, 0xac, 0xb3, 0x6a,
	0xef, 0xb9, 0xfa, 0xcf, 0xb4, 0xd7, 0x7f, 0x53, 0x80, 0xd3, 0x71, 0xcc, 0xb6, 0x82, 0xc0, 0x0b,
	0x30, 0x70, 0x75, 0xa8, 0xde, 0x5c, 0x6f, 0xa9, 0x91, 0x8b, 0xa1, 0xdc, 0x6a, 0x6e, 0xb7, 0x07,
	0x3b, 0x34, 0x0c, 0x75, 0xcd, 0x98, 0x07, 0x40, 0xc0, 0xa6, 0x1d, 0xd8, 0x7d, 0x3d, 0xc7, 0xf5,
	0x65, 0x73, 0x4c, 0xb8, 0x0d, 0x2f, 0x6a, 0x3d, 0x63, 0x6e, 0xca, 0x73, 0xd3, 0xa9, 0x0b, 0x4c,
	0x2e, 0xc7, 0xed, 0xea, 0x05, 0xa3, 0x0e, 0xe7, 0x70, 0x69, 0xcb, 0x0d, 0x69, 0xe0, 0xd8, 0x3d,
	0xe7, 0x1b, 0xd4, 0xb2, 0x9d, 0x1e, 0xed, 0xe8, 0x45, 0xb9, 0x76, 0x9b, 0x8e, 0xaf, 0xcd, 0x48,
	0x5e, 0x56, 0x40, 0xc3, 0x27, 0xac, 0xfa, 0xe0, 0x3d, 0x87, 0x3e, 0xcb, 0x43, 0x82, 0x49, 0xb9,
	0x17, 0x46, 0xb4, 0x8f, 0xfa, 0xe8, 0x25, 0xa9, 0x4d, 0xfb, 0x69, 0xaf, 0xe9, 0xb9, 0xae, 0x5e,
	0x96, 0xc2, 0xb3, 0xaa, 0x15, 0xea, 0xc0, 0x83, 0xa3, 0xd5, 0xdc, 0x7e, 0xe8, 0xf8, 0xf7, 0xe8,
	0x2e, 0xed, 0xe9, 0x15, 0x89, 0xc2, 0x49, 0x57, 0xe5, 0x1c, 0x03, 0x5e, 0x9f, 0x93, 0x5b, 0xe2,
	0x4b, 0x03, 0x7d, 0x9e, 0x7b, 0x96, 0x6d, 0x61, 0xbe, 0x90, 0x16, 0x58, 0xe0, 0x11, 0xa2, 0xc0,
	0xef, 0xfb, 0xd4, 0xd5, 0x75, 0x09, 0xe6, 0xf1, 0x28, 0x94, 0x3b, 0x3d, 0x06, 0x16, 0xf6, 0x36,
	0xa4, 0x12, 0x1b, 0x1e, 0xcf, 0xa0, 0x33, 0x3c, 0x55, 0x5a, 0xcd, 0xed, 0xa6, 0xd7, 0xeb, 0xd1,
	0x1d, 0xd6, 0x77, 0xea, 0xaf, 0x48, 0x0b, 0x20, 0x92, 0xd8, 0x7c, 0x56, 0xa2, 0x6e, 0x78, 0x11,
	0xcb, 0x15, 0x66, 0xfd, 0x73, 0x52, 0x83, 0x0d, 0x2f, 0x7a, 0x60, 0x3f, 0xea, 0x51, 0xfd, 0xbc,
	0xe4, 0x8d, 0x73, 0xfc, 0x3e, 0x42, 0x3b, 0x7a, 0x4d, 0x12, 0xc5, 0x8f, 0x83, 0x42, 0xd0, 0x0b,
	0xd7, 0xfe, 0x7d, 0x06, 0x2a, 0x18, 0x3a, 0x6d, 0x1a, 0xec, 0xd2, 0xc0, 0xd8, 0x83, 0x79, 0xcf,
	0x55, 0x0b, 0x9b, 0xb1, 0x34, 0xe1, 0x8b, 0xbc, 0xfc, 0xfc, 0x5e, 0x3f, 0x04, 0x23, 0xf4, 0xcd,
	0x57, 0x3f, 0xfc, 0xd3, 0x3f, 0x7f, 0x94, 0xbb, 0x6c, 0x5e, 0x5c, 0xb5, 0x13, 0x5e, 0xab, 0x63,
	0x8c, 0x38, 0x6b, 0xa5, 0x16, 0xa5, 0xb1, 0x1e, 0xfd, 0xf2, 0x5f, 0x3f, 0x04, 0x23, 0x8b, 0xb5,
	0xca, 0xe8, 0x29, 0x54, 0x3d, 0x37, 0x29, 0xcf, 0xc6, 0xe2, 0x84, 0xbb, 0x60, 0x71, 0x83, 0x52,
	0xcf, 0x5c, 0x0f, 0x7d, 0xf3, 0x0a, 0x32, 0xbd, 0x68, 0x5e, 0x18, 0x67, 0x9a, 0xb0, 0xe8, 0x42,
	0x29, 0x9e, 0x1b, 0x97, 0x27, 0x7f, 0x5d, 0x65, 0xdc, 0xb2, 0x96, 0x43, 0xdf, 0xbc, 0x8c, 0xcc,
	0xce, 0x9b, 0x67, 0x53, 0x99, 0x19, 0x03, 0x98, 0x8b, 0xc7, 0xfc, 0x8c, 0x6c, 0x4c, 0x10, 0x3e,
	0xfe, 0xb0, 0x59, 0xcf, 0x46, 0x08, 0x7d, 0xd3, 0x44, 0x8e, 0x97, 0xcc, 0x7a, 0x2a, 0x47, 0xce,
	0xa5, 0x0f, 0x15, 0xcf, 0x95, 0xe7, 0x55, 0x9a, 0x8a, 0xca, 0xf7, 0xc6, 0x7a, 0xd6, 0x72, 0xe8,
	0x9b, 0x4b, 0xc8, 0xb0, 0x6e, 0xd6, 0xc6, 0x19, 0x4a, 0xfa, 0x21, 0x7a, 0x50, 0x9e, 0x2c, 0x69,
	0x4a, 0x8e, 0x5c, 0xc6, 0xd7, 0xb3, 0x11, 0xb2, 0x7c, 0x98, 0x30, 0xe9, 0x42, 0x99, 0x05, 0x12,
	0xe6, 0xb8, 0x91, 0x76, 0x93, 0x2e, 0x7f, 0x4a, 0xd7, 0x33, 0x56, 0x43, 0xdf, 0x5c, 0x44, 0x5e,
	0x35, 0xf3, 0xdc, 0x81, 0x20, 0xe5, 0xb4, 0x31, 0x35, 0xac, 0x93, 0xca, 0x4a, 0xeb, 0x40, 0x56,
	0x5a, 0x27, 0x95, 0x95, 0xd6, 0x81, 0xac, 0xb4, 0x5e, 0x7c, 0x56, 0x5a, 0x63, 0x59, 0x69, 0xbd,
	0xc8, 0xac, 0xb4, 0x94, 0xac, 0xb4, 0x4e, 0x24, 0x2b, 0xad, 0xf1, 0xac, 0xb4, 0x5e, 0x70, 0x56,
	0x5a, 0xa3, 0x59, 0x69, 0x65, 0x66, 0xa5, 0x75, 0x58, 0x56, 0x5a, 0x47, 0xca, 0x4a, 0x85, 0xc9,
	0x53, 0xa6, 0xa3, 0xec, 0x26, 0x53, 0x79, 0xaa, 0x17, 0xc8, 0xf5, 0x6c, 0x84, 0x0c, 0x3d, 0x13,
	0x1e, 0x7b, 0xcc, 0x9b, 0x4a, 0xab, 0x6a, 0x5c, 0x49, 0xa1, 0x39, 0x7a, 0x1f, 0x5a, 0x3f, 0x0c,
	0x25, 0xc3, 0xa3, 0x2a, 0x27, 0xac, 0x41, 0xd6, 0xe4, 0x1a, 0x64, 0x65, 0xd6, 0x20, 0xeb, 0xf0,
	0x1a, 0x14, 0xd3, 0x76, 0x18, 0x23, 0xd1, 0x63, 0xa7, 0x05, 0x8e, 0x72, 0x7d, 0x54, 0xcf, 0x5a,
	0xce, 0x60, 0x15, 0x53, 0x1f, 0x40, 0xf5, 0xbe, 0x9b, 0xb4, 0xee, 0x69, 0x15, 0x67, 0xf4, 0x92,
	0xa5, 0x7e, 0x08, 0x46, 0x46, 0xe0, 0x28, 0x6c, 0x12, 0xb6, 0xd8, 0xff, 0x4f, 0x66, 0x1b, 0xdf,
	0x21, 0x7c, 0x5a, 0xb6, 0x9c, 0xcd, 0x37, 0x61, 0xfe, 0xbe, 0xab, 0xfe, 0x04, 0x4f, 0x8b, 0x9e,
	0xb1, 0x1f, 0xf8, 0xf5, 0xc3, 0x50, 0x32, 0x6a, 0xac, 0x8a, 0x77, 0xeb, 0xc2, 0xc7, 0x7f, 0x5f,
	0x3c, 0xf5, 0xf1, 0xf3, 0x45, 0xed, 0x8f, 0xcf, 0x17, 0xb5, 0xbf, 0x3d, 0x5f, 0xd4, 0x7e, 0xf2,
	0x8f, 0xc5, 0x53, 0x5f, 0xcf, 0xdb, 0xbe, 0xf3, 0x68, 0x06, 0xff, 0x3f, 0xfb, 0xe6, 0x7f, 0x03,
	0x00, 0x00, 0xff, 0xff, 0x39, 0xcc, 0xa3, 0x57, 0xab, 0x2b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ArenaServerClient is the client API for ArenaServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ArenaServerClient interface {
	OnPMatchStatus(ctx context.Context, in *MatchStatusReq, opts ...grpc.CallOption) (*MatchStatusRsp, error)
	OnPShareStatus(ctx context.Context, in *ShareStatusReq, opts ...grpc.CallOption) (*ShareStatusRsp, error)
	OnPAwardList(ctx context.Context, in *AwardListReq, opts ...grpc.CallOption) (*AwardListRsp, error)
	OnPAward(ctx context.Context, in *GetAwardReq, opts ...grpc.CallOption) (*GetAwardRsp, error)
	OnPAwardCount(ctx context.Context, in *AwardCountReq, opts ...grpc.CallOption) (*AwardCountRsp, error)
	OnPRankList(ctx context.Context, in *RankListReq, opts ...grpc.CallOption) (*RankListRsp, error)
	OnPMatchList(ctx context.Context, in *PMatchListReq, opts ...grpc.CallOption) (*PMatchListRsp, error)
	OnPSignUp(ctx context.Context, in *PSignUpReq, opts ...grpc.CallOption) (*PSignUpRsp, error)
	OnFMatchStatus(ctx context.Context, in *MatchStatusReq, opts ...grpc.CallOption) (*MatchStatusRsp, error)
	OnFShareStatus(ctx context.Context, in *ShareStatusReq, opts ...grpc.CallOption) (*ShareStatusRsp, error)
	OnFAwardList(ctx context.Context, in *AwardListReq, opts ...grpc.CallOption) (*AwardListRsp, error)
	OnFAward(ctx context.Context, in *GetAwardReq, opts ...grpc.CallOption) (*GetAwardRsp, error)
	OnFAwardCount(ctx context.Context, in *AwardCountReq, opts ...grpc.CallOption) (*AwardCountRsp, error)
	OnFRankList(ctx context.Context, in *RankListReq, opts ...grpc.CallOption) (*RankListRsp, error)
	OnFMatchList(ctx context.Context, in *FMatchListReq, opts ...grpc.CallOption) (*FMatchListRsp, error)
	OnWaitMatch(ctx context.Context, in *FWaitMatchReq, opts ...grpc.CallOption) (*FWaitMatchRsp, error)
	OnCancelMatch(ctx context.Context, in *FCancelMatchReq, opts ...grpc.CallOption) (*FCancelMatchRsp, error)
	OnFSignUp(ctx context.Context, in *FSignUpReq, opts ...grpc.CallOption) (*FSignUpRsp, error)
	OnConfirm(ctx context.Context, in *FConfirmReq, opts ...grpc.CallOption) (*FConfirmRsp, error)
	OnRobotLogin(ctx context.Context, in *FRobotLoginReq, opts ...grpc.CallOption) (*FRobotLoginRsp, error)
	OnRobotHeart(ctx context.Context, in *FRobotHeartReq, opts ...grpc.CallOption) (*FRobotLoginRsp, error)
	OnGameUserInfo(ctx context.Context, in *GameUserInfoReq, opts ...grpc.CallOption) (*GameUserInfoRsp, error)
}

type arenaServerClient struct {
	cc *grpc.ClientConn
}

func NewArenaServerClient(cc *grpc.ClientConn) ArenaServerClient {
	return &arenaServerClient{cc}
}

func (c *arenaServerClient) OnPMatchStatus(ctx context.Context, in *MatchStatusReq, opts ...grpc.CallOption) (*MatchStatusRsp, error) {
	out := new(MatchStatusRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onPMatchStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnPShareStatus(ctx context.Context, in *ShareStatusReq, opts ...grpc.CallOption) (*ShareStatusRsp, error) {
	out := new(ShareStatusRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onPShareStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnPAwardList(ctx context.Context, in *AwardListReq, opts ...grpc.CallOption) (*AwardListRsp, error) {
	out := new(AwardListRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onPAwardList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnPAward(ctx context.Context, in *GetAwardReq, opts ...grpc.CallOption) (*GetAwardRsp, error) {
	out := new(GetAwardRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onPAward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnPAwardCount(ctx context.Context, in *AwardCountReq, opts ...grpc.CallOption) (*AwardCountRsp, error) {
	out := new(AwardCountRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onPAwardCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnPRankList(ctx context.Context, in *RankListReq, opts ...grpc.CallOption) (*RankListRsp, error) {
	out := new(RankListRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onPRankList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnPMatchList(ctx context.Context, in *PMatchListReq, opts ...grpc.CallOption) (*PMatchListRsp, error) {
	out := new(PMatchListRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onPMatchList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnPSignUp(ctx context.Context, in *PSignUpReq, opts ...grpc.CallOption) (*PSignUpRsp, error) {
	out := new(PSignUpRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onPSignUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnFMatchStatus(ctx context.Context, in *MatchStatusReq, opts ...grpc.CallOption) (*MatchStatusRsp, error) {
	out := new(MatchStatusRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onFMatchStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnFShareStatus(ctx context.Context, in *ShareStatusReq, opts ...grpc.CallOption) (*ShareStatusRsp, error) {
	out := new(ShareStatusRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onFShareStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnFAwardList(ctx context.Context, in *AwardListReq, opts ...grpc.CallOption) (*AwardListRsp, error) {
	out := new(AwardListRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onFAwardList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnFAward(ctx context.Context, in *GetAwardReq, opts ...grpc.CallOption) (*GetAwardRsp, error) {
	out := new(GetAwardRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onFAward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnFAwardCount(ctx context.Context, in *AwardCountReq, opts ...grpc.CallOption) (*AwardCountRsp, error) {
	out := new(AwardCountRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onFAwardCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnFRankList(ctx context.Context, in *RankListReq, opts ...grpc.CallOption) (*RankListRsp, error) {
	out := new(RankListRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onFRankList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnFMatchList(ctx context.Context, in *FMatchListReq, opts ...grpc.CallOption) (*FMatchListRsp, error) {
	out := new(FMatchListRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onFMatchList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnWaitMatch(ctx context.Context, in *FWaitMatchReq, opts ...grpc.CallOption) (*FWaitMatchRsp, error) {
	out := new(FWaitMatchRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onWaitMatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnCancelMatch(ctx context.Context, in *FCancelMatchReq, opts ...grpc.CallOption) (*FCancelMatchRsp, error) {
	out := new(FCancelMatchRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onCancelMatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnFSignUp(ctx context.Context, in *FSignUpReq, opts ...grpc.CallOption) (*FSignUpRsp, error) {
	out := new(FSignUpRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onFSignUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnConfirm(ctx context.Context, in *FConfirmReq, opts ...grpc.CallOption) (*FConfirmRsp, error) {
	out := new(FConfirmRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/onConfirm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnRobotLogin(ctx context.Context, in *FRobotLoginReq, opts ...grpc.CallOption) (*FRobotLoginRsp, error) {
	out := new(FRobotLoginRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/OnRobotLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnRobotHeart(ctx context.Context, in *FRobotHeartReq, opts ...grpc.CallOption) (*FRobotLoginRsp, error) {
	out := new(FRobotLoginRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/OnRobotHeart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnGameUserInfo(ctx context.Context, in *GameUserInfoReq, opts ...grpc.CallOption) (*GameUserInfoRsp, error) {
	out := new(GameUserInfoRsp)
	err := c.cc.Invoke(ctx, "/arena.service.v1.ArenaServer/OnGameUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArenaServerServer is the server API for ArenaServer service.
type ArenaServerServer interface {
	OnPMatchStatus(context.Context, *MatchStatusReq) (*MatchStatusRsp, error)
	OnPShareStatus(context.Context, *ShareStatusReq) (*ShareStatusRsp, error)
	OnPAwardList(context.Context, *AwardListReq) (*AwardListRsp, error)
	OnPAward(context.Context, *GetAwardReq) (*GetAwardRsp, error)
	OnPAwardCount(context.Context, *AwardCountReq) (*AwardCountRsp, error)
	OnPRankList(context.Context, *RankListReq) (*RankListRsp, error)
	OnPMatchList(context.Context, *PMatchListReq) (*PMatchListRsp, error)
	OnPSignUp(context.Context, *PSignUpReq) (*PSignUpRsp, error)
	OnFMatchStatus(context.Context, *MatchStatusReq) (*MatchStatusRsp, error)
	OnFShareStatus(context.Context, *ShareStatusReq) (*ShareStatusRsp, error)
	OnFAwardList(context.Context, *AwardListReq) (*AwardListRsp, error)
	OnFAward(context.Context, *GetAwardReq) (*GetAwardRsp, error)
	OnFAwardCount(context.Context, *AwardCountReq) (*AwardCountRsp, error)
	OnFRankList(context.Context, *RankListReq) (*RankListRsp, error)
	OnFMatchList(context.Context, *FMatchListReq) (*FMatchListRsp, error)
	OnWaitMatch(context.Context, *FWaitMatchReq) (*FWaitMatchRsp, error)
	OnCancelMatch(context.Context, *FCancelMatchReq) (*FCancelMatchRsp, error)
	OnFSignUp(context.Context, *FSignUpReq) (*FSignUpRsp, error)
	OnConfirm(context.Context, *FConfirmReq) (*FConfirmRsp, error)
	OnRobotLogin(context.Context, *FRobotLoginReq) (*FRobotLoginRsp, error)
	OnRobotHeart(context.Context, *FRobotHeartReq) (*FRobotLoginRsp, error)
	OnGameUserInfo(context.Context, *GameUserInfoReq) (*GameUserInfoRsp, error)
}

// UnimplementedArenaServerServer can be embedded to have forward compatible implementations.
type UnimplementedArenaServerServer struct {
}

func (*UnimplementedArenaServerServer) OnPMatchStatus(ctx context.Context, req *MatchStatusReq) (*MatchStatusRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnPMatchStatus not implemented")
}
func (*UnimplementedArenaServerServer) OnPShareStatus(ctx context.Context, req *ShareStatusReq) (*ShareStatusRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnPShareStatus not implemented")
}
func (*UnimplementedArenaServerServer) OnPAwardList(ctx context.Context, req *AwardListReq) (*AwardListRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnPAwardList not implemented")
}
func (*UnimplementedArenaServerServer) OnPAward(ctx context.Context, req *GetAwardReq) (*GetAwardRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnPAward not implemented")
}
func (*UnimplementedArenaServerServer) OnPAwardCount(ctx context.Context, req *AwardCountReq) (*AwardCountRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnPAwardCount not implemented")
}
func (*UnimplementedArenaServerServer) OnPRankList(ctx context.Context, req *RankListReq) (*RankListRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnPRankList not implemented")
}
func (*UnimplementedArenaServerServer) OnPMatchList(ctx context.Context, req *PMatchListReq) (*PMatchListRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnPMatchList not implemented")
}
func (*UnimplementedArenaServerServer) OnPSignUp(ctx context.Context, req *PSignUpReq) (*PSignUpRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnPSignUp not implemented")
}
func (*UnimplementedArenaServerServer) OnFMatchStatus(ctx context.Context, req *MatchStatusReq) (*MatchStatusRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnFMatchStatus not implemented")
}
func (*UnimplementedArenaServerServer) OnFShareStatus(ctx context.Context, req *ShareStatusReq) (*ShareStatusRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnFShareStatus not implemented")
}
func (*UnimplementedArenaServerServer) OnFAwardList(ctx context.Context, req *AwardListReq) (*AwardListRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnFAwardList not implemented")
}
func (*UnimplementedArenaServerServer) OnFAward(ctx context.Context, req *GetAwardReq) (*GetAwardRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnFAward not implemented")
}
func (*UnimplementedArenaServerServer) OnFAwardCount(ctx context.Context, req *AwardCountReq) (*AwardCountRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnFAwardCount not implemented")
}
func (*UnimplementedArenaServerServer) OnFRankList(ctx context.Context, req *RankListReq) (*RankListRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnFRankList not implemented")
}
func (*UnimplementedArenaServerServer) OnFMatchList(ctx context.Context, req *FMatchListReq) (*FMatchListRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnFMatchList not implemented")
}
func (*UnimplementedArenaServerServer) OnWaitMatch(ctx context.Context, req *FWaitMatchReq) (*FWaitMatchRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnWaitMatch not implemented")
}
func (*UnimplementedArenaServerServer) OnCancelMatch(ctx context.Context, req *FCancelMatchReq) (*FCancelMatchRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnCancelMatch not implemented")
}
func (*UnimplementedArenaServerServer) OnFSignUp(ctx context.Context, req *FSignUpReq) (*FSignUpRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnFSignUp not implemented")
}
func (*UnimplementedArenaServerServer) OnConfirm(ctx context.Context, req *FConfirmReq) (*FConfirmRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnConfirm not implemented")
}
func (*UnimplementedArenaServerServer) OnRobotLogin(ctx context.Context, req *FRobotLoginReq) (*FRobotLoginRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnRobotLogin not implemented")
}
func (*UnimplementedArenaServerServer) OnRobotHeart(ctx context.Context, req *FRobotHeartReq) (*FRobotLoginRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnRobotHeart not implemented")
}
func (*UnimplementedArenaServerServer) OnGameUserInfo(ctx context.Context, req *GameUserInfoReq) (*GameUserInfoRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnGameUserInfo not implemented")
}

func RegisterArenaServerServer(s *grpc.Server, srv ArenaServerServer) {
	s.RegisterService(&_ArenaServer_serviceDesc, srv)
}

func _ArenaServer_OnPMatchStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnPMatchStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnPMatchStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnPMatchStatus(ctx, req.(*MatchStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnPShareStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShareStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnPShareStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnPShareStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnPShareStatus(ctx, req.(*ShareStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnPAwardList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AwardListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnPAwardList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnPAwardList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnPAwardList(ctx, req.(*AwardListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnPAward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAwardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnPAward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnPAward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnPAward(ctx, req.(*GetAwardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnPAwardCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AwardCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnPAwardCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnPAwardCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnPAwardCount(ctx, req.(*AwardCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnPRankList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RankListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnPRankList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnPRankList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnPRankList(ctx, req.(*RankListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnPMatchList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PMatchListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnPMatchList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnPMatchList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnPMatchList(ctx, req.(*PMatchListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnPSignUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PSignUpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnPSignUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnPSignUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnPSignUp(ctx, req.(*PSignUpReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnFMatchStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnFMatchStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnFMatchStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnFMatchStatus(ctx, req.(*MatchStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnFShareStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShareStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnFShareStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnFShareStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnFShareStatus(ctx, req.(*ShareStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnFAwardList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AwardListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnFAwardList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnFAwardList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnFAwardList(ctx, req.(*AwardListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnFAward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAwardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnFAward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnFAward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnFAward(ctx, req.(*GetAwardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnFAwardCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AwardCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnFAwardCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnFAwardCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnFAwardCount(ctx, req.(*AwardCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnFRankList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RankListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnFRankList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnFRankList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnFRankList(ctx, req.(*RankListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnFMatchList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FMatchListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnFMatchList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnFMatchList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnFMatchList(ctx, req.(*FMatchListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnWaitMatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FWaitMatchReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnWaitMatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnWaitMatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnWaitMatch(ctx, req.(*FWaitMatchReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnCancelMatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FCancelMatchReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnCancelMatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnCancelMatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnCancelMatch(ctx, req.(*FCancelMatchReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnFSignUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FSignUpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnFSignUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnFSignUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnFSignUp(ctx, req.(*FSignUpReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnConfirm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FConfirmReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnConfirm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnConfirm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnConfirm(ctx, req.(*FConfirmReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnRobotLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FRobotLoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnRobotLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnRobotLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnRobotLogin(ctx, req.(*FRobotLoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnRobotHeart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FRobotHeartReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnRobotHeart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnRobotHeart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnRobotHeart(ctx, req.(*FRobotHeartReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnGameUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnGameUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arena.service.v1.ArenaServer/OnGameUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnGameUserInfo(ctx, req.(*GameUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _ArenaServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arena.service.v1.ArenaServer",
	HandlerType: (*ArenaServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "onPMatchStatus",
			Handler:    _ArenaServer_OnPMatchStatus_Handler,
		},
		{
			MethodName: "onPShareStatus",
			Handler:    _ArenaServer_OnPShareStatus_Handler,
		},
		{
			MethodName: "onPAwardList",
			Handler:    _ArenaServer_OnPAwardList_Handler,
		},
		{
			MethodName: "onPAward",
			Handler:    _ArenaServer_OnPAward_Handler,
		},
		{
			MethodName: "onPAwardCount",
			Handler:    _ArenaServer_OnPAwardCount_Handler,
		},
		{
			MethodName: "onPRankList",
			Handler:    _ArenaServer_OnPRankList_Handler,
		},
		{
			MethodName: "onPMatchList",
			Handler:    _ArenaServer_OnPMatchList_Handler,
		},
		{
			MethodName: "onPSignUp",
			Handler:    _ArenaServer_OnPSignUp_Handler,
		},
		{
			MethodName: "onFMatchStatus",
			Handler:    _ArenaServer_OnFMatchStatus_Handler,
		},
		{
			MethodName: "onFShareStatus",
			Handler:    _ArenaServer_OnFShareStatus_Handler,
		},
		{
			MethodName: "onFAwardList",
			Handler:    _ArenaServer_OnFAwardList_Handler,
		},
		{
			MethodName: "onFAward",
			Handler:    _ArenaServer_OnFAward_Handler,
		},
		{
			MethodName: "onFAwardCount",
			Handler:    _ArenaServer_OnFAwardCount_Handler,
		},
		{
			MethodName: "onFRankList",
			Handler:    _ArenaServer_OnFRankList_Handler,
		},
		{
			MethodName: "onFMatchList",
			Handler:    _ArenaServer_OnFMatchList_Handler,
		},
		{
			MethodName: "onWaitMatch",
			Handler:    _ArenaServer_OnWaitMatch_Handler,
		},
		{
			MethodName: "onCancelMatch",
			Handler:    _ArenaServer_OnCancelMatch_Handler,
		},
		{
			MethodName: "onFSignUp",
			Handler:    _ArenaServer_OnFSignUp_Handler,
		},
		{
			MethodName: "onConfirm",
			Handler:    _ArenaServer_OnConfirm_Handler,
		},
		{
			MethodName: "OnRobotLogin",
			Handler:    _ArenaServer_OnRobotLogin_Handler,
		},
		{
			MethodName: "OnRobotHeart",
			Handler:    _ArenaServer_OnRobotHeart_Handler,
		},
		{
			MethodName: "OnGameUserInfo",
			Handler:    _ArenaServer_OnGameUserInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *HttpCommonRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpCommonRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpCommonRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if m.En != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.En))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchStatusReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchStatusReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchTips) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchTips) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchTips) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TypeTips) > 0 {
		i -= len(m.TypeTips)
		copy(dAtA[i:], m.TypeTips)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeTips)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.GameType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchStatusRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchStatusRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchStatusRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tips) > 0 {
		for iNdEx := len(m.Tips) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tips[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShareStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShareStatusReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShareStatusReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShareStatusRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShareStatusRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShareStatusRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Core != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Core))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Award) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Award) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Award) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mux != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mux))
		i--
		dAtA[i] = 0x18
	}
	if m.Num != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AwardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AwardInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Awards) > 0 {
		for iNdEx := len(m.Awards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Awards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TypeTips) > 0 {
		i -= len(m.TypeTips)
		copy(dAtA[i:], m.TypeTips)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeTips)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ModeId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ModeId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AwardId) > 0 {
		i -= len(m.AwardId)
		copy(dAtA[i:], m.AwardId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.AwardId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AwardListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AwardListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AwardListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardListRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AwardListRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AwardList) > 0 {
		for iNdEx := len(m.AwardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AwardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetAwardData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAwardData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAwardData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Phone) > 0 {
		i -= len(m.Phone)
		copy(dAtA[i:], m.Phone)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Phone)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AwardId) > 0 {
		i -= len(m.AwardId)
		copy(dAtA[i:], m.AwardId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.AwardId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAwardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAwardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAwardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AwardList) > 0 {
		for iNdEx := len(m.AwardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AwardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetAwardRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAwardRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAwardRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AwardList) > 0 {
		for iNdEx := len(m.AwardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AwardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AwardIdList) > 0 {
		for iNdEx := len(m.AwardIdList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AwardIdList[iNdEx])
			copy(dAtA[i:], m.AwardIdList[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.AwardIdList[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AwardCountReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardCountReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AwardCountReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AwardCountRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardCountRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AwardCountRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RankListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaType))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RankListInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankListInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankListInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stars {
		i--
		if m.Stars {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.AwardList) > 0 {
		for iNdEx := len(m.AwardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AwardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Mark != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mark))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.UserType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserType))
		i--
		dAtA[i] = 0x18
	}
	if m.EndRank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EndRank))
		i--
		dAtA[i] = 0x10
	}
	if m.StartRank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StartRank))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RankListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankListRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankListRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mark != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mark))
		i--
		dAtA[i] = 0x40
	}
	if m.TotalRank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TotalRank))
		i--
		dAtA[i] = 0x38
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x30
	}
	if len(m.RankList) > 0 {
		for iNdEx := len(m.RankList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RankList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ArenaType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaType))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PMatchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PMatchInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PMatchInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AwardCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AwardCount))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Awards) > 0 {
		for iNdEx := len(m.Awards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Awards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.TotalRank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TotalRank))
		i--
		dAtA[i] = 0x50
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x48
	}
	if len(m.ConditionList) > 0 {
		for iNdEx := len(m.ConditionList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConditionList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0x32
	}
	if m.TotalTimes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TotalTimes))
		i--
		dAtA[i] = 0x28
	}
	if m.JoinTimes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.JoinTimes))
		i--
		dAtA[i] = 0x20
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TypeTips) > 0 {
		i -= len(m.TypeTips)
		copy(dAtA[i:], m.TypeTips)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeTips)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PMatchListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PMatchListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PMatchListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PMatchListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PMatchListRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PMatchListRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MatchList) > 0 {
		for iNdEx := len(m.MatchList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PSignUpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PSignUpReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PSignUpReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Head) > 0 {
		i -= len(m.Head)
		copy(dAtA[i:], m.Head)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Head)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PSignUpRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PSignUpRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PSignUpRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x42
	}
	if m.Core != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Core))
		i--
		dAtA[i] = 0x38
	}
	if m.Money != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x30
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FMatchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FMatchInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FMatchInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x58
	}
	if len(m.RankInfoList) > 0 {
		for iNdEx := len(m.RankInfoList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RankInfoList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.ConditionList) > 0 {
		for iNdEx := len(m.ConditionList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConditionList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.MatchTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchTime))
		i--
		dAtA[i] = 0x40
	}
	if m.TotalTimes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TotalTimes))
		i--
		dAtA[i] = 0x38
	}
	if m.JoinTimes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.JoinTimes))
		i--
		dAtA[i] = 0x30
	}
	if m.PlayerTimes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerTimes))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OpenTime) > 0 {
		i -= len(m.OpenTime)
		copy(dAtA[i:], m.OpenTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.OpenTime)))
		i--
		dAtA[i] = 0x22
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TypeTips) > 0 {
		i -= len(m.TypeTips)
		copy(dAtA[i:], m.TypeTips)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeTips)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FMatchListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FMatchListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FMatchListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FMatchListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FMatchListRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FMatchListRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MatchList) > 0 {
		for iNdEx := len(m.MatchList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FWaitMatchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FWaitMatchReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FWaitMatchReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FWaitMatchRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FWaitMatchRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FWaitMatchRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Total != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x40
	}
	if m.Join != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Join))
		i--
		dAtA[i] = 0x38
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x28
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FCancelMatchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FCancelMatchReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FCancelMatchReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FCancelMatchRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FCancelMatchRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FCancelMatchRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x30
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x28
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PositionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x11
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *FSignUpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSignUpReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FSignUpReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x32
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Head) > 0 {
		i -= len(m.Head)
		copy(dAtA[i:], m.Head)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Head)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FSignUpRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSignUpRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FSignUpRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Core != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Core))
		i--
		dAtA[i] = 0x30
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FConfirmReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FConfirmReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FConfirmReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FConfirmRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FConfirmRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FConfirmRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x30
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x28
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FRobotLoginReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FRobotLoginReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FRobotLoginReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FRobotLoginRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FRobotLoginRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FRobotLoginRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Core != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Core))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FRobotJoinMatchRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FRobotJoinMatchRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FRobotJoinMatchRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FRobotHeartReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FRobotHeartReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FRobotHeartReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FRobotHeartRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FRobotHeartRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FRobotHeartRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Core != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Core))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameUserInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameUserInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameUserInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameUserInfoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameUserInfoRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameUserInfoRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tips) > 0 {
		i -= len(m.Tips)
		copy(dAtA[i:], m.Tips)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tips)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.Count != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x28
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x20
	}
	if m.GameType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HttpCommonRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.En != 0 {
		n += 1 + sovApi(uint64(m.En))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchStatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchTips) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameType != 0 {
		n += 1 + sovApi(uint64(m.GameType))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.TypeTips)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchStatusRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Tips) > 0 {
		for _, e := range m.Tips {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShareStatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShareStatusRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Core != 0 {
		n += 1 + sovApi(uint64(m.Core))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Award) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.Mux != 0 {
		n += 1 + sovApi(uint64(m.Mux))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AwardId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ModeId != 0 {
		n += 1 + sovApi(uint64(m.ModeId))
	}
	l = len(m.TypeTips)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Awards) > 0 {
		for _, e := range m.Awards {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.AwardList) > 0 {
		for _, e := range m.AwardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAwardData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AwardId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAwardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if len(m.AwardList) > 0 {
		for _, e := range m.AwardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAwardRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if len(m.AwardIdList) > 0 {
		for _, s := range m.AwardIdList {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.AwardList) > 0 {
		for _, e := range m.AwardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardCountReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardCountRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Count != 0 {
		n += 1 + sovApi(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.ArenaType != 0 {
		n += 1 + sovApi(uint64(m.ArenaType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankListInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartRank != 0 {
		n += 1 + sovApi(uint64(m.StartRank))
	}
	if m.EndRank != 0 {
		n += 1 + sovApi(uint64(m.EndRank))
	}
	if m.UserType != 0 {
		n += 1 + sovApi(uint64(m.UserType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mark != 0 {
		n += 1 + sovApi(uint64(m.Mark))
	}
	if len(m.AwardList) > 0 {
		for _, e := range m.AwardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Stars {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.ArenaType != 0 {
		n += 1 + sovApi(uint64(m.ArenaType))
	}
	if len(m.RankList) > 0 {
		for _, e := range m.RankList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.TotalRank != 0 {
		n += 1 + sovApi(uint64(m.TotalRank))
	}
	if m.Mark != 0 {
		n += 1 + sovApi(uint64(m.Mark))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Value != 0 {
		n += 1 + sovApi(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PMatchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.TypeTips)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.JoinTimes != 0 {
		n += 1 + sovApi(uint64(m.JoinTimes))
	}
	if m.TotalTimes != 0 {
		n += 1 + sovApi(uint64(m.TotalTimes))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if len(m.ConditionList) > 0 {
		for _, e := range m.ConditionList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.TotalRank != 0 {
		n += 1 + sovApi(uint64(m.TotalRank))
	}
	if len(m.Awards) > 0 {
		for _, e := range m.Awards {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.AwardCount != 0 {
		n += 1 + sovApi(uint64(m.AwardCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PMatchListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PMatchListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.MatchList) > 0 {
		for _, e := range m.MatchList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PSignUpReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PSignUpRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Money != 0 {
		n += 1 + sovApi(uint64(m.Money))
	}
	if m.Core != 0 {
		n += 1 + sovApi(uint64(m.Core))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FMatchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.TypeTips)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.OpenTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PlayerTimes != 0 {
		n += 1 + sovApi(uint64(m.PlayerTimes))
	}
	if m.JoinTimes != 0 {
		n += 1 + sovApi(uint64(m.JoinTimes))
	}
	if m.TotalTimes != 0 {
		n += 1 + sovApi(uint64(m.TotalTimes))
	}
	if m.MatchTime != 0 {
		n += 1 + sovApi(uint64(m.MatchTime))
	}
	if len(m.ConditionList) > 0 {
		for _, e := range m.ConditionList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.RankInfoList) > 0 {
		for _, e := range m.RankInfoList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FMatchListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FMatchListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.MatchList) > 0 {
		for _, e := range m.MatchList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FWaitMatchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FWaitMatchRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.Join != 0 {
		n += 1 + sovApi(uint64(m.Join))
	}
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FCancelMatchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FCancelMatchRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Result != 0 {
		n += 1 + sovApi(uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PositionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Latitude != 0 {
		n += 9
	}
	if m.Longitude != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FSignUpReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FSignUpRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Core != 0 {
		n += 1 + sovApi(uint64(m.Core))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FConfirmReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FConfirmRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Result != 0 {
		n += 1 + sovApi(uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FRobotLoginReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FRobotLoginRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Core != 0 {
		n += 1 + sovApi(uint64(m.Core))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FRobotJoinMatchRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FRobotHeartReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FRobotHeartRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Core != 0 {
		n += 1 + sovApi(uint64(m.Core))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameUserInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameUserInfoRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameType != 0 {
		n += 1 + sovApi(uint64(m.GameType))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Count != 0 {
		n += 1 + sovApi(uint64(m.Count))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	l = len(m.Tips)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HttpCommonRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpCommonRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpCommonRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field En", wireType)
			}
			m.En = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.En |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchTips) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchTips: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchTips: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameType", wireType)
			}
			m.GameType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeTips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeTips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchStatusRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchStatusRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchStatusRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tips = append(m.Tips, &MatchTips{})
			if err := m.Tips[len(m.Tips)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShareStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShareStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShareStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShareStatusRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShareStatusRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShareStatusRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			m.Core = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Core |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Award) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Award: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Award: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mux", wireType)
			}
			m.Mux = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mux |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeId", wireType)
			}
			m.ModeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeTips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeTips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Awards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Awards = append(m.Awards, &Award{})
			if err := m.Awards[len(m.Awards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwardList = append(m.AwardList, &AwardInfo{})
			if err := m.AwardList[len(m.AwardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAwardData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAwardData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAwardData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAwardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAwardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAwardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwardList = append(m.AwardList, &GetAwardData{})
			if err := m.AwardList[len(m.AwardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAwardRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAwardRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAwardRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardIdList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwardIdList = append(m.AwardIdList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwardList = append(m.AwardList, &Award{})
			if err := m.AwardList[len(m.AwardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardCountReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardCountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardCountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardCountRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardCountRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardCountRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaType", wireType)
			}
			m.ArenaType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankListInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankListInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankListInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartRank", wireType)
			}
			m.StartRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndRank", wireType)
			}
			m.EndRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserType", wireType)
			}
			m.UserType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			m.Mark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwardList = append(m.AwardList, &Award{})
			if err := m.AwardList[len(m.AwardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stars", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stars = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaType", wireType)
			}
			m.ArenaType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankList = append(m.RankList, &RankListInfo{})
			if err := m.RankList[len(m.RankList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRank", wireType)
			}
			m.TotalRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			m.Mark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PMatchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PMatchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PMatchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeTips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeTips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinTimes", wireType)
			}
			m.JoinTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTimes", wireType)
			}
			m.TotalTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionList = append(m.ConditionList, &Condition{})
			if err := m.ConditionList[len(m.ConditionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRank", wireType)
			}
			m.TotalRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Awards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Awards = append(m.Awards, &Award{})
			if err := m.Awards[len(m.Awards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardCount", wireType)
			}
			m.AwardCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AwardCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PMatchListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PMatchListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PMatchListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PMatchListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PMatchListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PMatchListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchList = append(m.MatchList, &PMatchInfo{})
			if err := m.MatchList[len(m.MatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PSignUpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PSignUpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PSignUpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PSignUpRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PSignUpRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PSignUpRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			m.Core = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Core |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FMatchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FMatchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FMatchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeTips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeTips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerTimes", wireType)
			}
			m.PlayerTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinTimes", wireType)
			}
			m.JoinTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTimes", wireType)
			}
			m.TotalTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchTime", wireType)
			}
			m.MatchTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionList = append(m.ConditionList, &Condition{})
			if err := m.ConditionList[len(m.ConditionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankInfoList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankInfoList = append(m.RankInfoList, &RankListInfo{})
			if err := m.RankInfoList[len(m.RankInfoList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FMatchListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FMatchListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FMatchListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FMatchListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FMatchListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FMatchListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchList = append(m.MatchList, &FMatchInfo{})
			if err := m.MatchList[len(m.MatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FWaitMatchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FWaitMatchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FWaitMatchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FWaitMatchRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FWaitMatchRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FWaitMatchRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			m.Join = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Join |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FCancelMatchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FCancelMatchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FCancelMatchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FCancelMatchRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FCancelMatchRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FCancelMatchRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSignUpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSignUpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSignUpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &PositionInfo{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSignUpRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSignUpRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSignUpRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			m.Core = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Core |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FConfirmReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FConfirmReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FConfirmReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FConfirmRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FConfirmRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FConfirmRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FRobotLoginReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FRobotLoginReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FRobotLoginReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FRobotLoginRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FRobotLoginRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FRobotLoginRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			m.Core = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Core |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FRobotJoinMatchRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FRobotJoinMatchRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FRobotJoinMatchRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FRobotHeartReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FRobotHeartReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FRobotHeartReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FRobotHeartRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FRobotHeartRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FRobotHeartRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			m.Core = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Core |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameUserInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameUserInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameUserInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameUserInfoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameUserInfoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameUserInfoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameType", wireType)
			}
			m.GameType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
