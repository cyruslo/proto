// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

// package 命名使用 {appid}.{version} 的方式, version 形如 v1, v2 ..

package api

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ArenaMsgCode int32

const (
	ArenaMsgCode_AMC_InvalId ArenaMsgCode = 0
	//客户端-公共部分
	ArenaMsgCode_AMC_C_MatchStatus ArenaMsgCode = 1
	ArenaMsgCode_AMC_C_ShareStatus ArenaMsgCode = 2
	ArenaMsgCode_AMC_C_AwardList   ArenaMsgCode = 3
	ArenaMsgCode_AMC_C_GetAward    ArenaMsgCode = 4
	ArenaMsgCode_AMC_C_AwardCount  ArenaMsgCode = 5
	ArenaMsgCode_AMC_C_RankList    ArenaMsgCode = 6
	//客户端-全民赛
	ArenaMsgCode_AMC_C_PMatchList ArenaMsgCode = 30
	ArenaMsgCode_AMC_C_PSignUp    ArenaMsgCode = 31
	//客户端-快速赛
	ArenaMsgCode_AMC_C_FMatchList      ArenaMsgCode = 50
	ArenaMsgCode_AMC_C_FWaitMatch      ArenaMsgCode = 51
	ArenaMsgCode_AMC_C_FCancelMatch    ArenaMsgCode = 52
	ArenaMsgCode_AMC_C_FSignUp         ArenaMsgCode = 53
	ArenaMsgCode_AMC_C_FConfirm        ArenaMsgCode = 54
	ArenaMsgCode_AMC_C_FRobotLogin     ArenaMsgCode = 55
	ArenaMsgCode_AMC_C_FRobotJoinMatch ArenaMsgCode = 56
	ArenaMsgCode_AMC_C_FRobotHeart     ArenaMsgCode = 57
	//客户端-大师赛
	ArenaMsgCode_AMC_C_GMatchDetails ArenaMsgCode = 70
	ArenaMsgCode_AMC_C_GSignUp       ArenaMsgCode = 71
	ArenaMsgCode_AMC_C_GRankList     ArenaMsgCode = 72
	ArenaMsgCode_AMC_C_GWeekRecord   ArenaMsgCode = 73
	ArenaMsgCode_AMC_C_GAwardList    ArenaMsgCode = 74
	ArenaMsgCode_AMC_C_GFamousList   ArenaMsgCode = 75
	ArenaMsgCode_AMC_C_GGetAward     ArenaMsgCode = 76
	ArenaMsgCode_AMC_C_GDailyTask    ArenaMsgCode = 77
	//服务器部分-公共部分
	ArenaMsgCode_AMC_S_GameCountDown ArenaMsgCode = 100
	//服务器部分-全民赛
	ArenaMsgCode_AMC_S_PReportStatus ArenaMsgCode = 130
	ArenaMsgCode_AMC_S_PReportMatch  ArenaMsgCode = 131
	ArenaMsgCode_AMC_S_PGameEnd      ArenaMsgCode = 132
	//服务器部分-快速比赛
	ArenaMsgCode_AMC_S_FReportStatus ArenaMsgCode = 150
	ArenaMsgCode_AMC_S_FReportMatch  ArenaMsgCode = 151
	ArenaMsgCode_AMC_S_FSettlement   ArenaMsgCode = 152
	ArenaMsgCode_AMC_S_FGameEnd      ArenaMsgCode = 153
	ArenaMsgCode_AMC_C_FRobotNameSyn ArenaMsgCode = 154
	//服务器部分-大师赛
	ArenaMsgCode_AMC_S_GReportStatus   ArenaMsgCode = 155
	ArenaMsgCode_AMC_S_GReportMatch    ArenaMsgCode = 156
	ArenaMsgCode_AMC_S_GGameEnd        ArenaMsgCode = 157
	ArenaMsgCode_AMC_S_GGameSettlement ArenaMsgCode = 158
	ArenaMsgCode_AMC_S_GKayValue       ArenaMsgCode = 159
)

var ArenaMsgCode_name = map[int32]string{
	0:   "AMC_InvalId",
	1:   "AMC_C_MatchStatus",
	2:   "AMC_C_ShareStatus",
	3:   "AMC_C_AwardList",
	4:   "AMC_C_GetAward",
	5:   "AMC_C_AwardCount",
	6:   "AMC_C_RankList",
	30:  "AMC_C_PMatchList",
	31:  "AMC_C_PSignUp",
	50:  "AMC_C_FMatchList",
	51:  "AMC_C_FWaitMatch",
	52:  "AMC_C_FCancelMatch",
	53:  "AMC_C_FSignUp",
	54:  "AMC_C_FConfirm",
	55:  "AMC_C_FRobotLogin",
	56:  "AMC_C_FRobotJoinMatch",
	57:  "AMC_C_FRobotHeart",
	70:  "AMC_C_GMatchDetails",
	71:  "AMC_C_GSignUp",
	72:  "AMC_C_GRankList",
	73:  "AMC_C_GWeekRecord",
	74:  "AMC_C_GAwardList",
	75:  "AMC_C_GFamousList",
	76:  "AMC_C_GGetAward",
	77:  "AMC_C_GDailyTask",
	100: "AMC_S_GameCountDown",
	130: "AMC_S_PReportStatus",
	131: "AMC_S_PReportMatch",
	132: "AMC_S_PGameEnd",
	150: "AMC_S_FReportStatus",
	151: "AMC_S_FReportMatch",
	152: "AMC_S_FSettlement",
	153: "AMC_S_FGameEnd",
	154: "AMC_C_FRobotNameSyn",
	155: "AMC_S_GReportStatus",
	156: "AMC_S_GReportMatch",
	157: "AMC_S_GGameEnd",
	158: "AMC_S_GGameSettlement",
	159: "AMC_S_GKayValue",
}

var ArenaMsgCode_value = map[string]int32{
	"AMC_InvalId":           0,
	"AMC_C_MatchStatus":     1,
	"AMC_C_ShareStatus":     2,
	"AMC_C_AwardList":       3,
	"AMC_C_GetAward":        4,
	"AMC_C_AwardCount":      5,
	"AMC_C_RankList":        6,
	"AMC_C_PMatchList":      30,
	"AMC_C_PSignUp":         31,
	"AMC_C_FMatchList":      50,
	"AMC_C_FWaitMatch":      51,
	"AMC_C_FCancelMatch":    52,
	"AMC_C_FSignUp":         53,
	"AMC_C_FConfirm":        54,
	"AMC_C_FRobotLogin":     55,
	"AMC_C_FRobotJoinMatch": 56,
	"AMC_C_FRobotHeart":     57,
	"AMC_C_GMatchDetails":   70,
	"AMC_C_GSignUp":         71,
	"AMC_C_GRankList":       72,
	"AMC_C_GWeekRecord":     73,
	"AMC_C_GAwardList":      74,
	"AMC_C_GFamousList":     75,
	"AMC_C_GGetAward":       76,
	"AMC_C_GDailyTask":      77,
	"AMC_S_GameCountDown":   100,
	"AMC_S_PReportStatus":   130,
	"AMC_S_PReportMatch":    131,
	"AMC_S_PGameEnd":        132,
	"AMC_S_FReportStatus":   150,
	"AMC_S_FReportMatch":    151,
	"AMC_S_FSettlement":     152,
	"AMC_S_FGameEnd":        153,
	"AMC_C_FRobotNameSyn":   154,
	"AMC_S_GReportStatus":   155,
	"AMC_S_GReportMatch":    156,
	"AMC_S_GGameEnd":        157,
	"AMC_S_GGameSettlement": 158,
	"AMC_S_GKayValue":       159,
}

func (x ArenaMsgCode) String() string {
	return proto.EnumName(ArenaMsgCode_name, int32(x))
}

func (ArenaMsgCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

type ArenaMsgErrorCode int32

const (
	ArenaMsgErrorCode_AMEC_InvalId           ArenaMsgErrorCode = 0
	ArenaMsgErrorCode_AMEC_Sucess            ArenaMsgErrorCode = 1
	ArenaMsgErrorCode_AMEC_Param             ArenaMsgErrorCode = 2
	ArenaMsgErrorCode_AMEC_PlayerNotExist    ArenaMsgErrorCode = 3
	ArenaMsgErrorCode_AMEC_PlayerNotGameing  ArenaMsgErrorCode = 4
	ArenaMsgErrorCode_AMEC_UnserializeFailed ArenaMsgErrorCode = 5
	ArenaMsgErrorCode_AMEC_DeserializeFailed ArenaMsgErrorCode = 6
	ArenaMsgErrorCode_AMEC_FreshUserMoney    ArenaMsgErrorCode = 7
	ArenaMsgErrorCode_AMEC_SystemError       ArenaMsgErrorCode = 8
	ArenaMsgErrorCode_AMEC_SqlConn           ArenaMsgErrorCode = 9
	ArenaMsgErrorCode_AMEC_Infos             ArenaMsgErrorCode = 10
	ArenaMsgErrorCode_AMEC_VipLevel          ArenaMsgErrorCode = 11
	ArenaMsgErrorCode_AMEC_Money             ArenaMsgErrorCode = 12
	ArenaMsgErrorCode_AMEC_Share             ArenaMsgErrorCode = 13
	ArenaMsgErrorCode_AMEC_JoinTime          ArenaMsgErrorCode = 14
	ArenaMsgErrorCode_AMEC_MatchNotExist     ArenaMsgErrorCode = 15
	ArenaMsgErrorCode_AMEC_MatchNotOpen      ArenaMsgErrorCode = 16
	ArenaMsgErrorCode_AMEC_SignUpFailed      ArenaMsgErrorCode = 17
	ArenaMsgErrorCode_AMEC_SignUpSucess      ArenaMsgErrorCode = 18
	ArenaMsgErrorCode_AMEC_NoAward           ArenaMsgErrorCode = 19
	ArenaMsgErrorCode_AMEC_Collection        ArenaMsgErrorCode = 20
	ArenaMsgErrorCode_AMEC_AwardSucess       ArenaMsgErrorCode = 21
	ArenaMsgErrorCode_AMEC_NotWaiting        ArenaMsgErrorCode = 22
	ArenaMsgErrorCode_AMEC_NotTable          ArenaMsgErrorCode = 23
	ArenaMsgErrorCode_AMEC_TableStarted      ArenaMsgErrorCode = 24
	ArenaMsgErrorCode_AMEC_PhoneFailed       ArenaMsgErrorCode = 25
)

var ArenaMsgErrorCode_name = map[int32]string{
	0:  "AMEC_InvalId",
	1:  "AMEC_Sucess",
	2:  "AMEC_Param",
	3:  "AMEC_PlayerNotExist",
	4:  "AMEC_PlayerNotGameing",
	5:  "AMEC_UnserializeFailed",
	6:  "AMEC_DeserializeFailed",
	7:  "AMEC_FreshUserMoney",
	8:  "AMEC_SystemError",
	9:  "AMEC_SqlConn",
	10: "AMEC_Infos",
	11: "AMEC_VipLevel",
	12: "AMEC_Money",
	13: "AMEC_Share",
	14: "AMEC_JoinTime",
	15: "AMEC_MatchNotExist",
	16: "AMEC_MatchNotOpen",
	17: "AMEC_SignUpFailed",
	18: "AMEC_SignUpSucess",
	19: "AMEC_NoAward",
	20: "AMEC_Collection",
	21: "AMEC_AwardSucess",
	22: "AMEC_NotWaiting",
	23: "AMEC_NotTable",
	24: "AMEC_TableStarted",
	25: "AMEC_PhoneFailed",
}

var ArenaMsgErrorCode_value = map[string]int32{
	"AMEC_InvalId":           0,
	"AMEC_Sucess":            1,
	"AMEC_Param":             2,
	"AMEC_PlayerNotExist":    3,
	"AMEC_PlayerNotGameing":  4,
	"AMEC_UnserializeFailed": 5,
	"AMEC_DeserializeFailed": 6,
	"AMEC_FreshUserMoney":    7,
	"AMEC_SystemError":       8,
	"AMEC_SqlConn":           9,
	"AMEC_Infos":             10,
	"AMEC_VipLevel":          11,
	"AMEC_Money":             12,
	"AMEC_Share":             13,
	"AMEC_JoinTime":          14,
	"AMEC_MatchNotExist":     15,
	"AMEC_MatchNotOpen":      16,
	"AMEC_SignUpFailed":      17,
	"AMEC_SignUpSucess":      18,
	"AMEC_NoAward":           19,
	"AMEC_Collection":        20,
	"AMEC_AwardSucess":       21,
	"AMEC_NotWaiting":        22,
	"AMEC_NotTable":          23,
	"AMEC_TableStarted":      24,
	"AMEC_PhoneFailed":       25,
}

func (x ArenaMsgErrorCode) String() string {
	return proto.EnumName(ArenaMsgErrorCode_name, int32(x))
}

func (ArenaMsgErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}

type SignUpCore int32

const (
	SignUpCore_SC_Success SignUpCore = 0
	SignUpCore_SC_Refresh SignUpCore = 1
)

var SignUpCore_name = map[int32]string{
	0: "SC_Success",
	1: "SC_Refresh",
}

var SignUpCore_value = map[string]int32{
	"SC_Success": 0,
	"SC_Refresh": 1,
}

func (x SignUpCore) String() string {
	return proto.EnumName(SignUpCore_name, int32(x))
}

func (SignUpCore) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}

type AwardCode int32

const (
	AwardCode_AC_Success  AwardCode = 0
	AwardCode_Ac_NotExist AwardCode = 1
)

var AwardCode_name = map[int32]string{
	0: "AC_Success",
	1: "Ac_NotExist",
}

var AwardCode_value = map[string]int32{
	"AC_Success":  0,
	"Ac_NotExist": 1,
}

func (x AwardCode) String() string {
	return proto.EnumName(AwardCode_name, int32(x))
}

func (AwardCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}

//比赛列表
type ConditionType int32

const (
	ConditionType_No_z1          ConditionType = 0
	ConditionType_CTYPE_Money    ConditionType = 1
	ConditionType_CTYPE_VipLevel ConditionType = 2
	ConditionType_CTYPE_Share    ConditionType = 3
)

var ConditionType_name = map[int32]string{
	0: "No_z1",
	1: "CTYPE_Money",
	2: "CTYPE_VipLevel",
	3: "CTYPE_Share",
}

var ConditionType_value = map[string]int32{
	"No_z1":          0,
	"CTYPE_Money":    1,
	"CTYPE_VipLevel": 2,
	"CTYPE_Share":    3,
}

func (x ConditionType) String() string {
	return proto.EnumName(ConditionType_name, int32(x))
}

func (ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}

type MatchStatus int32

const (
	MatchStatus_No_z               MatchStatus = 0
	MatchStatus_MSTATUS_NotStart   MatchStatus = 1
	MatchStatus_MSTATUS_NotSignUp  MatchStatus = 2
	MatchStatus_MSTATUS_Continue   MatchStatus = 3
	MatchStatus_MSTATUS_AlmostOver MatchStatus = 4
	MatchStatus_MSTATUS_WaitAward  MatchStatus = 5
	MatchStatus_MSTATUS_End        MatchStatus = 6
	MatchStatus_MSTATUS_NotJoin    MatchStatus = 7
)

var MatchStatus_name = map[int32]string{
	0: "No_z",
	1: "MSTATUS_NotStart",
	2: "MSTATUS_NotSignUp",
	3: "MSTATUS_Continue",
	4: "MSTATUS_AlmostOver",
	5: "MSTATUS_WaitAward",
	6: "MSTATUS_End",
	7: "MSTATUS_NotJoin",
}

var MatchStatus_value = map[string]int32{
	"No_z":               0,
	"MSTATUS_NotStart":   1,
	"MSTATUS_NotSignUp":  2,
	"MSTATUS_Continue":   3,
	"MSTATUS_AlmostOver": 4,
	"MSTATUS_WaitAward":  5,
	"MSTATUS_End":        6,
	"MSTATUS_NotJoin":    7,
}

func (x MatchStatus) String() string {
	return proto.EnumName(MatchStatus_name, int32(x))
}

func (MatchStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}

type AwardUserType int32

const (
	AwardUserType_No_z2        AwardUserType = 0
	AwardUserType_AUT_User     AwardUserType = 1
	AwardUserType_AUT_ScoreTip AwardUserType = 2
)

var AwardUserType_name = map[int32]string{
	0: "No_z2",
	1: "AUT_User",
	2: "AUT_ScoreTip",
}

var AwardUserType_value = map[string]int32{
	"No_z2":        0,
	"AUT_User":     1,
	"AUT_ScoreTip": 2,
}

func (x AwardUserType) String() string {
	return proto.EnumName(AwardUserType_name, int32(x))
}

func (AwardUserType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}

type Areantype int32

const (
	Areantype_No_z3      Areantype = 0
	Areantype_AT_Current Areantype = 1
	Areantype_AT_Before  Areantype = 2
	Areantype_AT_Day     Areantype = 3
)

var Areantype_name = map[int32]string{
	0: "No_z3",
	1: "AT_Current",
	2: "AT_Before",
	3: "AT_Day",
}

var Areantype_value = map[string]int32{
	"No_z3":      0,
	"AT_Current": 1,
	"AT_Before":  2,
	"AT_Day":     3,
}

func (x Areantype) String() string {
	return proto.EnumName(Areantype_name, int32(x))
}

func (Areantype) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}

//------------------------- 客户端部分-全名赛 ------------------------------------
type TimeType int32

const (
	TimeType_No_z4       TimeType = 0
	TimeType_TTYPE_Start TimeType = 1
	TimeType_TTYPE_Award TimeType = 2
)

var TimeType_name = map[int32]string{
	0: "No_z4",
	1: "TTYPE_Start",
	2: "TTYPE_Award",
}

var TimeType_value = map[string]int32{
	"No_z4":       0,
	"TTYPE_Start": 1,
	"TTYPE_Award": 2,
}

func (x TimeType) String() string {
	return proto.EnumName(TimeType_name, int32(x))
}

func (TimeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}

type FWaitMatchStatus int32

const (
	FWaitMatchStatus_WMS_NotJoin FWaitMatchStatus = 0
	FWaitMatchStatus_WMS_Waitng  FWaitMatchStatus = 1
	FWaitMatchStatus_WMS_Confirm FWaitMatchStatus = 2
	FWaitMatchStatus_WMS_Start   FWaitMatchStatus = 3
)

var FWaitMatchStatus_name = map[int32]string{
	0: "WMS_NotJoin",
	1: "WMS_Waitng",
	2: "WMS_Confirm",
	3: "WMS_Start",
}

var FWaitMatchStatus_value = map[string]int32{
	"WMS_NotJoin": 0,
	"WMS_Waitng":  1,
	"WMS_Confirm": 2,
	"WMS_Start":   3,
}

func (x FWaitMatchStatus) String() string {
	return proto.EnumName(FWaitMatchStatus_name, int32(x))
}

func (FWaitMatchStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}

//AMC_S_ReportStatus
type GameStatus int32

const (
	GameStatus_No_z5    GameStatus = 0
	GameStatus_GS_Enter GameStatus = 1
	GameStatus_GS_Leave GameStatus = 2
)

var GameStatus_name = map[int32]string{
	0: "No_z5",
	1: "GS_Enter",
	2: "GS_Leave",
}

var GameStatus_value = map[string]int32{
	"No_z5":    0,
	"GS_Enter": 1,
	"GS_Leave": 2,
}

func (x GameStatus) String() string {
	return proto.EnumName(GameStatus_name, int32(x))
}

func (GameStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}

//---------------------- 大厅部分 ----------------------
type HallMsgCode int32

const (
	HallMsgCode_HMC_Invalid HallMsgCode = 0
	HallMsgCode_HMC_CHat    HallMsgCode = 1
)

var HallMsgCode_name = map[int32]string{
	0: "HMC_Invalid",
	1: "HMC_CHat",
}

var HallMsgCode_value = map[string]int32{
	"HMC_Invalid": 0,
	"HMC_CHat":    1,
}

func (x HallMsgCode) String() string {
	return proto.EnumName(HallMsgCode_name, int32(x))
}

func (HallMsgCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}

//------------------------- 客户端部分-大师赛 ------------------------------------
type HttpCommonRsp struct {
	En                   int32    `protobuf:"varint,1,opt,name=En,proto3" json:"En,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HttpCommonRsp) Reset()         { *m = HttpCommonRsp{} }
func (m *HttpCommonRsp) String() string { return proto.CompactTextString(m) }
func (*HttpCommonRsp) ProtoMessage()    {}
func (*HttpCommonRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *HttpCommonRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpCommonRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpCommonRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpCommonRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpCommonRsp.Merge(m, src)
}
func (m *HttpCommonRsp) XXX_Size() int {
	return m.Size()
}
func (m *HttpCommonRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpCommonRsp.DiscardUnknown(m)
}

var xxx_messageInfo_HttpCommonRsp proto.InternalMessageInfo

type GAward struct {
	Id                   int32    `protobuf:"varint,1,opt,name=Id,proto3" json:"Id"`
	Num                  int64    `protobuf:"varint,2,opt,name=Num,proto3" json:"Num"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GAward) Reset()         { *m = GAward{} }
func (m *GAward) String() string { return proto.CompactTextString(m) }
func (*GAward) ProtoMessage()    {}
func (*GAward) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *GAward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GAward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GAward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GAward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GAward.Merge(m, src)
}
func (m *GAward) XXX_Size() int {
	return m.Size()
}
func (m *GAward) XXX_DiscardUnknown() {
	xxx_messageInfo_GAward.DiscardUnknown(m)
}

var xxx_messageInfo_GAward proto.InternalMessageInfo

type GRank struct {
	Rank                 int32    `protobuf:"varint,1,opt,name=Rank,proto3" json:"Rank"`
	PlayerId             int64    `protobuf:"varint,2,opt,name=PlayerId,proto3" json:"PlayerId"`
	Mark                 int64    `protobuf:"varint,3,opt,name=Mark,proto3" json:"Mark"`
	RankStart            int32    `protobuf:"varint,4,opt,name=RankStart,proto3" json:"RankStart"`
	RankEnd              int32    `protobuf:"varint,5,opt,name=RankEnd,proto3" json:"RankEnd"`
	NickName             string   `protobuf:"bytes,6,opt,name=NickName,proto3" json:"NickName"`
	Avatar               string   `protobuf:"bytes,7,opt,name=Avatar,proto3" json:"Avatar"`
	Awards               *GAward  `protobuf:"bytes,8,opt,name=Awards,proto3" json:"Awards"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GRank) Reset()         { *m = GRank{} }
func (m *GRank) String() string { return proto.CompactTextString(m) }
func (*GRank) ProtoMessage()    {}
func (*GRank) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *GRank) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GRank) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GRank.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GRank) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GRank.Merge(m, src)
}
func (m *GRank) XXX_Size() int {
	return m.Size()
}
func (m *GRank) XXX_DiscardUnknown() {
	xxx_messageInfo_GRank.DiscardUnknown(m)
}

var xxx_messageInfo_GRank proto.InternalMessageInfo

type GDailyTaskReq struct {
	MatchId              int32    `protobuf:"varint,1,opt,name=MatchId,proto3" json:"MatchId"`
	PlayerId             int64    `protobuf:"varint,2,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GDailyTaskReq) Reset()         { *m = GDailyTaskReq{} }
func (m *GDailyTaskReq) String() string { return proto.CompactTextString(m) }
func (*GDailyTaskReq) ProtoMessage()    {}
func (*GDailyTaskReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *GDailyTaskReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GDailyTaskReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GDailyTaskReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GDailyTaskReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GDailyTaskReq.Merge(m, src)
}
func (m *GDailyTaskReq) XXX_Size() int {
	return m.Size()
}
func (m *GDailyTaskReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GDailyTaskReq.DiscardUnknown(m)
}

var xxx_messageInfo_GDailyTaskReq proto.InternalMessageInfo

type GDailyTaskRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	TargetScore          int32    `protobuf:"varint,3,opt,name=TargetScore,proto3" json:"TargetScore"`
	AwardType            int32    `protobuf:"varint,4,opt,name=AwardType,proto3" json:"AwardType"`
	AwardNum             int32    `protobuf:"varint,5,opt,name=AwardNum,proto3" json:"AwardNum"`
	FinishStatus         int32    `protobuf:"varint,6,opt,name=FinishStatus,proto3" json:"FinishStatus"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GDailyTaskRsp) Reset()         { *m = GDailyTaskRsp{} }
func (m *GDailyTaskRsp) String() string { return proto.CompactTextString(m) }
func (*GDailyTaskRsp) ProtoMessage()    {}
func (*GDailyTaskRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *GDailyTaskRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GDailyTaskRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GDailyTaskRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GDailyTaskRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GDailyTaskRsp.Merge(m, src)
}
func (m *GDailyTaskRsp) XXX_Size() int {
	return m.Size()
}
func (m *GDailyTaskRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GDailyTaskRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GDailyTaskRsp proto.InternalMessageInfo

type GRankListReq struct {
	MatchId              int32    `protobuf:"varint,1,opt,name=MatchId,proto3" json:"MatchId"`
	PlayerId             int64    `protobuf:"varint,2,opt,name=PlayerId,proto3" json:"PlayerId"`
	Type                 int32    `protobuf:"varint,3,opt,name=Type,proto3" json:"Type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GRankListReq) Reset()         { *m = GRankListReq{} }
func (m *GRankListReq) String() string { return proto.CompactTextString(m) }
func (*GRankListReq) ProtoMessage()    {}
func (*GRankListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *GRankListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GRankListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GRankListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GRankListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GRankListReq.Merge(m, src)
}
func (m *GRankListReq) XXX_Size() int {
	return m.Size()
}
func (m *GRankListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GRankListReq.DiscardUnknown(m)
}

var xxx_messageInfo_GRankListReq proto.InternalMessageInfo

type GRankListRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	Type                 int32    `protobuf:"varint,3,opt,name=Type,proto3" json:"Type"`
	SelfRank             int32    `protobuf:"varint,4,opt,name=SelfRank,proto3" json:"SelfRank"`
	FristDay             string   `protobuf:"bytes,5,opt,name=FristDay,proto3" json:"FristDay"`
	LastDay              string   `protobuf:"bytes,6,opt,name=LastDay,proto3" json:"LastDay"`
	CurDay               string   `protobuf:"bytes,7,opt,name=CurDay,proto3" json:"CurDay"`
	Ranklist             []*GRank `protobuf:"bytes,8,rep,name=Ranklist,proto3" json:"Ranklist,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GRankListRsp) Reset()         { *m = GRankListRsp{} }
func (m *GRankListRsp) String() string { return proto.CompactTextString(m) }
func (*GRankListRsp) ProtoMessage()    {}
func (*GRankListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *GRankListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GRankListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GRankListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GRankListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GRankListRsp.Merge(m, src)
}
func (m *GRankListRsp) XXX_Size() int {
	return m.Size()
}
func (m *GRankListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GRankListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GRankListRsp proto.InternalMessageInfo

type GWeekRecordReq struct {
	MatchId              int32    `protobuf:"varint,1,opt,name=MatchId,proto3" json:"MatchId"`
	PlayerId             int64    `protobuf:"varint,2,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GWeekRecordReq) Reset()         { *m = GWeekRecordReq{} }
func (m *GWeekRecordReq) String() string { return proto.CompactTextString(m) }
func (*GWeekRecordReq) ProtoMessage()    {}
func (*GWeekRecordReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *GWeekRecordReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GWeekRecordReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GWeekRecordReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GWeekRecordReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GWeekRecordReq.Merge(m, src)
}
func (m *GWeekRecordReq) XXX_Size() int {
	return m.Size()
}
func (m *GWeekRecordReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GWeekRecordReq.DiscardUnknown(m)
}

var xxx_messageInfo_GWeekRecordReq proto.InternalMessageInfo

type WeekRecord struct {
	WeekOne              int32    `protobuf:"varint,1,opt,name=WeekOne,proto3" json:"WeekOne"`
	Mark                 int64    `protobuf:"varint,2,opt,name=Mark,proto3" json:"Mark"`
	Status               int32    `protobuf:"varint,3,opt,name=Status,proto3" json:"Status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WeekRecord) Reset()         { *m = WeekRecord{} }
func (m *WeekRecord) String() string { return proto.CompactTextString(m) }
func (*WeekRecord) ProtoMessage()    {}
func (*WeekRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *WeekRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeekRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeekRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeekRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeekRecord.Merge(m, src)
}
func (m *WeekRecord) XXX_Size() int {
	return m.Size()
}
func (m *WeekRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_WeekRecord.DiscardUnknown(m)
}

var xxx_messageInfo_WeekRecord proto.InternalMessageInfo

type GWeekRecordRsp struct {
	Code                 int32         `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string        `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	WeekOne              int32         `protobuf:"varint,3,opt,name=WeekOne,proto3" json:"WeekOne"`
	WeekRank             int32         `protobuf:"varint,4,opt,name=WeekRank,proto3" json:"WeekRank"`
	WeekMark             int64         `protobuf:"varint,5,opt,name=WeekMark,proto3" json:"WeekMark"`
	WeekRecords          []*WeekRecord `protobuf:"bytes,6,rep,name=WeekRecords,proto3" json:"WeekRecords,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GWeekRecordRsp) Reset()         { *m = GWeekRecordRsp{} }
func (m *GWeekRecordRsp) String() string { return proto.CompactTextString(m) }
func (*GWeekRecordRsp) ProtoMessage()    {}
func (*GWeekRecordRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *GWeekRecordRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GWeekRecordRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GWeekRecordRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GWeekRecordRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GWeekRecordRsp.Merge(m, src)
}
func (m *GWeekRecordRsp) XXX_Size() int {
	return m.Size()
}
func (m *GWeekRecordRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GWeekRecordRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GWeekRecordRsp proto.InternalMessageInfo

type GConditions struct {
	Id                   int32    `protobuf:"varint,1,opt,name=Id,proto3" json:"Id"`
	Num                  int64    `protobuf:"varint,2,opt,name=Num,proto3" json:"Num"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GConditions) Reset()         { *m = GConditions{} }
func (m *GConditions) String() string { return proto.CompactTextString(m) }
func (*GConditions) ProtoMessage()    {}
func (*GConditions) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *GConditions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GConditions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GConditions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GConditions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GConditions.Merge(m, src)
}
func (m *GConditions) XXX_Size() int {
	return m.Size()
}
func (m *GConditions) XXX_DiscardUnknown() {
	xxx_messageInfo_GConditions.DiscardUnknown(m)
}

var xxx_messageInfo_GConditions proto.InternalMessageInfo

type GMatchDetailsReq struct {
	PlayerId             int64    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GMatchDetailsReq) Reset()         { *m = GMatchDetailsReq{} }
func (m *GMatchDetailsReq) String() string { return proto.CompactTextString(m) }
func (*GMatchDetailsReq) ProtoMessage()    {}
func (*GMatchDetailsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *GMatchDetailsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GMatchDetailsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GMatchDetailsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GMatchDetailsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GMatchDetailsReq.Merge(m, src)
}
func (m *GMatchDetailsReq) XXX_Size() int {
	return m.Size()
}
func (m *GMatchDetailsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GMatchDetailsReq.DiscardUnknown(m)
}

var xxx_messageInfo_GMatchDetailsReq proto.InternalMessageInfo

type GMatchDetailsRsp struct {
	Code                 int32          `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string         `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	MatchId              int32          `protobuf:"varint,3,opt,name=MatchId,proto3" json:"MatchId"`
	StartTime            string         `protobuf:"bytes,4,opt,name=StartTime,proto3" json:"StartTime"`
	EndTime              string         `protobuf:"bytes,5,opt,name=EndTime,proto3" json:"EndTime"`
	WeekMark             int64          `protobuf:"varint,6,opt,name=WeekMark,proto3" json:"WeekMark"`
	DayMark              int64          `protobuf:"varint,7,opt,name=DayMark,proto3" json:"DayMark"`
	Rank                 int32          `protobuf:"varint,8,opt,name=Rank,proto3" json:"Rank"`
	TotalRank            int32          `protobuf:"varint,9,opt,name=TotalRank,proto3" json:"TotalRank"`
	Condition            []*GConditions `protobuf:"bytes,10,rep,name=Condition,proto3" json:"Condition,omitempty"`
	Cost                 *GConditions   `protobuf:"bytes,11,opt,name=Cost,proto3" json:"Cost"`
	Additional           int32          `protobuf:"varint,12,opt,name=Additional,proto3" json:"Additional"`
	MatchStatus          int32          `protobuf:"varint,13,opt,name=MatchStatus,proto3" json:"MatchStatus"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GMatchDetailsRsp) Reset()         { *m = GMatchDetailsRsp{} }
func (m *GMatchDetailsRsp) String() string { return proto.CompactTextString(m) }
func (*GMatchDetailsRsp) ProtoMessage()    {}
func (*GMatchDetailsRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *GMatchDetailsRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GMatchDetailsRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GMatchDetailsRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GMatchDetailsRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GMatchDetailsRsp.Merge(m, src)
}
func (m *GMatchDetailsRsp) XXX_Size() int {
	return m.Size()
}
func (m *GMatchDetailsRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GMatchDetailsRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GMatchDetailsRsp proto.InternalMessageInfo

type GSignUpReq struct {
	MatchId              int32    `protobuf:"varint,1,opt,name=MatchId,proto3" json:"MatchId"`
	PlayerId             int64    `protobuf:"varint,2,opt,name=PlayerId,proto3" json:"PlayerId"`
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name"`
	Icon                 string   `protobuf:"bytes,4,opt,name=Icon,proto3" json:"Icon"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GSignUpReq) Reset()         { *m = GSignUpReq{} }
func (m *GSignUpReq) String() string { return proto.CompactTextString(m) }
func (*GSignUpReq) ProtoMessage()    {}
func (*GSignUpReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *GSignUpReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GSignUpReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GSignUpReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GSignUpReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GSignUpReq.Merge(m, src)
}
func (m *GSignUpReq) XXX_Size() int {
	return m.Size()
}
func (m *GSignUpReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GSignUpReq.DiscardUnknown(m)
}

var xxx_messageInfo_GSignUpReq proto.InternalMessageInfo

type GSignUpRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	MatchId              int32    `protobuf:"varint,4,opt,name=MatchId,proto3" json:"MatchId"`
	GameUrl              string   `protobuf:"bytes,5,opt,name=GameUrl,proto3" json:"GameUrl"`
	ArenaUrl             string   `protobuf:"bytes,6,opt,name=ArenaUrl,proto3" json:"ArenaUrl"`
	Status               int32    `protobuf:"varint,7,opt,name=Status,proto3" json:"Status"`
	Msg                  string   `protobuf:"bytes,8,opt,name=Msg,proto3" json:"Msg"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GSignUpRsp) Reset()         { *m = GSignUpRsp{} }
func (m *GSignUpRsp) String() string { return proto.CompactTextString(m) }
func (*GSignUpRsp) ProtoMessage()    {}
func (*GSignUpRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *GSignUpRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GSignUpRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GSignUpRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GSignUpRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GSignUpRsp.Merge(m, src)
}
func (m *GSignUpRsp) XXX_Size() int {
	return m.Size()
}
func (m *GSignUpRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GSignUpRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GSignUpRsp proto.InternalMessageInfo

type GFamousListReq struct {
	MatchId              int32    `protobuf:"varint,1,opt,name=MatchId,proto3" json:"Msg"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GFamousListReq) Reset()         { *m = GFamousListReq{} }
func (m *GFamousListReq) String() string { return proto.CompactTextString(m) }
func (*GFamousListReq) ProtoMessage()    {}
func (*GFamousListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *GFamousListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GFamousListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GFamousListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GFamousListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GFamousListReq.Merge(m, src)
}
func (m *GFamousListReq) XXX_Size() int {
	return m.Size()
}
func (m *GFamousListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GFamousListReq.DiscardUnknown(m)
}

var xxx_messageInfo_GFamousListReq proto.InternalMessageInfo

type Famous struct {
	Date                 string   `protobuf:"bytes,1,opt,name=date,proto3" json:"date"`
	Avatar               string   `protobuf:"bytes,2,opt,name=Avatar,proto3" json:"Avatar"`
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name"`
	Mark                 int64    `protobuf:"varint,4,opt,name=Mark,proto3" json:"Mark"`
	PlayerId             int64    `protobuf:"varint,5,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Famous) Reset()         { *m = Famous{} }
func (m *Famous) String() string { return proto.CompactTextString(m) }
func (*Famous) ProtoMessage()    {}
func (*Famous) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *Famous) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Famous) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Famous.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Famous) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Famous.Merge(m, src)
}
func (m *Famous) XXX_Size() int {
	return m.Size()
}
func (m *Famous) XXX_DiscardUnknown() {
	xxx_messageInfo_Famous.DiscardUnknown(m)
}

var xxx_messageInfo_Famous proto.InternalMessageInfo

type GFamousListRsp struct {
	Code                 int32     `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string    `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	FamousList           []*Famous `protobuf:"bytes,3,rep,name=FamousList,proto3" json:"FamousList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GFamousListRsp) Reset()         { *m = GFamousListRsp{} }
func (m *GFamousListRsp) String() string { return proto.CompactTextString(m) }
func (*GFamousListRsp) ProtoMessage()    {}
func (*GFamousListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *GFamousListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GFamousListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GFamousListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GFamousListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GFamousListRsp.Merge(m, src)
}
func (m *GFamousListRsp) XXX_Size() int {
	return m.Size()
}
func (m *GFamousListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GFamousListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GFamousListRsp proto.InternalMessageInfo

//------------------------- 客户端部分-公用部分 ------------------------------------
//AMC_C_MatchStatus:游戏的开启状态
type MatchStatusReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchStatusReq) Reset()         { *m = MatchStatusReq{} }
func (m *MatchStatusReq) String() string { return proto.CompactTextString(m) }
func (*MatchStatusReq) ProtoMessage()    {}
func (*MatchStatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{18}
}
func (m *MatchStatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchStatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchStatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchStatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchStatusReq.Merge(m, src)
}
func (m *MatchStatusReq) XXX_Size() int {
	return m.Size()
}
func (m *MatchStatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchStatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_MatchStatusReq proto.InternalMessageInfo

type MatchTips struct {
	GameType             int32    `protobuf:"varint,1,opt,name=GameType,proto3" json:"GameType,omitempty"`
	Type                 int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	TypeTips             string   `protobuf:"bytes,3,opt,name=TypeTips,proto3" json:"TypeTips,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchTips) Reset()         { *m = MatchTips{} }
func (m *MatchTips) String() string { return proto.CompactTextString(m) }
func (*MatchTips) ProtoMessage()    {}
func (*MatchTips) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{19}
}
func (m *MatchTips) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchTips) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchTips.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchTips) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchTips.Merge(m, src)
}
func (m *MatchTips) XXX_Size() int {
	return m.Size()
}
func (m *MatchTips) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchTips.DiscardUnknown(m)
}

var xxx_messageInfo_MatchTips proto.InternalMessageInfo

type MatchStatusRsp struct {
	Code                 int32        `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string       `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	Tips                 []*MatchTips `protobuf:"bytes,3,rep,name=Tips,proto3" json:"Tips,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MatchStatusRsp) Reset()         { *m = MatchStatusRsp{} }
func (m *MatchStatusRsp) String() string { return proto.CompactTextString(m) }
func (*MatchStatusRsp) ProtoMessage()    {}
func (*MatchStatusRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{20}
}
func (m *MatchStatusRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchStatusRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchStatusRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchStatusRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchStatusRsp.Merge(m, src)
}
func (m *MatchStatusRsp) XXX_Size() int {
	return m.Size()
}
func (m *MatchStatusRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchStatusRsp.DiscardUnknown(m)
}

var xxx_messageInfo_MatchStatusRsp proto.InternalMessageInfo

//AMC_C_ShareStatus:用户分享
type ShareStatusReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Type                 int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	Status               bool     `protobuf:"varint,4,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShareStatusReq) Reset()         { *m = ShareStatusReq{} }
func (m *ShareStatusReq) String() string { return proto.CompactTextString(m) }
func (*ShareStatusReq) ProtoMessage()    {}
func (*ShareStatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{21}
}
func (m *ShareStatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShareStatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShareStatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShareStatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShareStatusReq.Merge(m, src)
}
func (m *ShareStatusReq) XXX_Size() int {
	return m.Size()
}
func (m *ShareStatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ShareStatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_ShareStatusReq proto.InternalMessageInfo

type ShareStatusRsp struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Type                 int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	Core                 int32    `protobuf:"varint,4,opt,name=Core,proto3" json:"Core,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShareStatusRsp) Reset()         { *m = ShareStatusRsp{} }
func (m *ShareStatusRsp) String() string { return proto.CompactTextString(m) }
func (*ShareStatusRsp) ProtoMessage()    {}
func (*ShareStatusRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{22}
}
func (m *ShareStatusRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShareStatusRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShareStatusRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShareStatusRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShareStatusRsp.Merge(m, src)
}
func (m *ShareStatusRsp) XXX_Size() int {
	return m.Size()
}
func (m *ShareStatusRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ShareStatusRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ShareStatusRsp proto.InternalMessageInfo

//AMC_C_AwardList:奖励列表
type AwardListReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AwardListReq) Reset()         { *m = AwardListReq{} }
func (m *AwardListReq) String() string { return proto.CompactTextString(m) }
func (*AwardListReq) ProtoMessage()    {}
func (*AwardListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{23}
}
func (m *AwardListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardListReq.Merge(m, src)
}
func (m *AwardListReq) XXX_Size() int {
	return m.Size()
}
func (m *AwardListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardListReq.DiscardUnknown(m)
}

var xxx_messageInfo_AwardListReq proto.InternalMessageInfo

type GAwardListReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GAwardListReq) Reset()         { *m = GAwardListReq{} }
func (m *GAwardListReq) String() string { return proto.CompactTextString(m) }
func (*GAwardListReq) ProtoMessage()    {}
func (*GAwardListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{24}
}
func (m *GAwardListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GAwardListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GAwardListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GAwardListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GAwardListReq.Merge(m, src)
}
func (m *GAwardListReq) XXX_Size() int {
	return m.Size()
}
func (m *GAwardListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GAwardListReq.DiscardUnknown(m)
}

var xxx_messageInfo_GAwardListReq proto.InternalMessageInfo

type GAwardInfo struct {
	Id                   string    `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id"`
	TypeTips             string    `protobuf:"bytes,2,opt,name=TypeTips,proto3" json:"TypeTips"`
	Awards               []*GAward `protobuf:"bytes,3,rep,name=Awards,proto3" json:"Awards,omitempty"`
	Date                 string    `protobuf:"bytes,4,opt,name=Date,proto3" json:"Date"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GAwardInfo) Reset()         { *m = GAwardInfo{} }
func (m *GAwardInfo) String() string { return proto.CompactTextString(m) }
func (*GAwardInfo) ProtoMessage()    {}
func (*GAwardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{25}
}
func (m *GAwardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GAwardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GAwardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GAwardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GAwardInfo.Merge(m, src)
}
func (m *GAwardInfo) XXX_Size() int {
	return m.Size()
}
func (m *GAwardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GAwardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GAwardInfo proto.InternalMessageInfo

type GAwardListRsp struct {
	Code                 int32         `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string        `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	AwardList            []*GAwardInfo `protobuf:"bytes,3,rep,name=AwardList,proto3" json:"AwardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GAwardListRsp) Reset()         { *m = GAwardListRsp{} }
func (m *GAwardListRsp) String() string { return proto.CompactTextString(m) }
func (*GAwardListRsp) ProtoMessage()    {}
func (*GAwardListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{26}
}
func (m *GAwardListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GAwardListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GAwardListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GAwardListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GAwardListRsp.Merge(m, src)
}
func (m *GAwardListRsp) XXX_Size() int {
	return m.Size()
}
func (m *GAwardListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GAwardListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GAwardListRsp proto.InternalMessageInfo

type GGetAwardReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	Ids                  []string `protobuf:"bytes,2,rep,name=Ids,proto3" json:"Ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GGetAwardReq) Reset()         { *m = GGetAwardReq{} }
func (m *GGetAwardReq) String() string { return proto.CompactTextString(m) }
func (*GGetAwardReq) ProtoMessage()    {}
func (*GGetAwardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{27}
}
func (m *GGetAwardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GGetAwardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GGetAwardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GGetAwardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GGetAwardReq.Merge(m, src)
}
func (m *GGetAwardReq) XXX_Size() int {
	return m.Size()
}
func (m *GGetAwardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GGetAwardReq.DiscardUnknown(m)
}

var xxx_messageInfo_GGetAwardReq proto.InternalMessageInfo

type AwardRsp struct {
	Ids                  string   `protobuf:"bytes,1,opt,name=Ids,proto3" json:"Ids"`
	Status               int32    `protobuf:"varint,2,opt,name=Status,proto3" json:"Status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AwardRsp) Reset()         { *m = AwardRsp{} }
func (m *AwardRsp) String() string { return proto.CompactTextString(m) }
func (*AwardRsp) ProtoMessage()    {}
func (*AwardRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{28}
}
func (m *AwardRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardRsp.Merge(m, src)
}
func (m *AwardRsp) XXX_Size() int {
	return m.Size()
}
func (m *AwardRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AwardRsp proto.InternalMessageInfo

type GGetAwardRsp struct {
	Code                 int32       `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string      `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	PlayerId             int32       `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	AwardRsps            []*AwardRsp `protobuf:"bytes,4,rep,name=AwardRsps,proto3" json:"AwardRsps,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GGetAwardRsp) Reset()         { *m = GGetAwardRsp{} }
func (m *GGetAwardRsp) String() string { return proto.CompactTextString(m) }
func (*GGetAwardRsp) ProtoMessage()    {}
func (*GGetAwardRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{29}
}
func (m *GGetAwardRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GGetAwardRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GGetAwardRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GGetAwardRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GGetAwardRsp.Merge(m, src)
}
func (m *GGetAwardRsp) XXX_Size() int {
	return m.Size()
}
func (m *GGetAwardRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GGetAwardRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GGetAwardRsp proto.InternalMessageInfo

type AwardInfo struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	TypeTips             string   `protobuf:"bytes,2,opt,name=TypeTips,proto3" json:"TypeTips,omitempty"`
	Id                   int32    `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	MoneyId              int32    `protobuf:"varint,4,opt,name=MoneyId,proto3" json:"MoneyId,omitempty"`
	Money                int64    `protobuf:"varint,5,opt,name=Money,proto3" json:"Money,omitempty"`
	Date                 string   `protobuf:"bytes,6,opt,name=Date,proto3" json:"Date,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AwardInfo) Reset()         { *m = AwardInfo{} }
func (m *AwardInfo) String() string { return proto.CompactTextString(m) }
func (*AwardInfo) ProtoMessage()    {}
func (*AwardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{30}
}
func (m *AwardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardInfo.Merge(m, src)
}
func (m *AwardInfo) XXX_Size() int {
	return m.Size()
}
func (m *AwardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AwardInfo proto.InternalMessageInfo

type AwardListRsp struct {
	AwardList            []*AwardInfo `protobuf:"bytes,1,rep,name=AwardList,proto3" json:"AwardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AwardListRsp) Reset()         { *m = AwardListRsp{} }
func (m *AwardListRsp) String() string { return proto.CompactTextString(m) }
func (*AwardListRsp) ProtoMessage()    {}
func (*AwardListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{31}
}
func (m *AwardListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardListRsp.Merge(m, src)
}
func (m *AwardListRsp) XXX_Size() int {
	return m.Size()
}
func (m *AwardListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AwardListRsp proto.InternalMessageInfo

//AMC_C_GetAward:領取奖励
type GetAwardData struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	Date                 string   `protobuf:"bytes,3,opt,name=Date,proto3" json:"Date,omitempty"`
	MoneyId              int32    `protobuf:"varint,4,opt,name=MoneyId,proto3" json:"MoneyId,omitempty"`
	Money                int64    `protobuf:"varint,5,opt,name=Money,proto3" json:"Money,omitempty"`
	Phone                string   `protobuf:"bytes,6,opt,name=Phone,proto3" json:"Phone,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAwardData) Reset()         { *m = GetAwardData{} }
func (m *GetAwardData) String() string { return proto.CompactTextString(m) }
func (*GetAwardData) ProtoMessage()    {}
func (*GetAwardData) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{32}
}
func (m *GetAwardData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAwardData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAwardData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAwardData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAwardData.Merge(m, src)
}
func (m *GetAwardData) XXX_Size() int {
	return m.Size()
}
func (m *GetAwardData) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAwardData.DiscardUnknown(m)
}

var xxx_messageInfo_GetAwardData proto.InternalMessageInfo

type GetAwardReq struct {
	PlayerId             int32           `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	AwardList            []*GetAwardData `protobuf:"bytes,2,rep,name=AwardList,proto3" json:"AwardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetAwardReq) Reset()         { *m = GetAwardReq{} }
func (m *GetAwardReq) String() string { return proto.CompactTextString(m) }
func (*GetAwardReq) ProtoMessage()    {}
func (*GetAwardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{33}
}
func (m *GetAwardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAwardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAwardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAwardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAwardReq.Merge(m, src)
}
func (m *GetAwardReq) XXX_Size() int {
	return m.Size()
}
func (m *GetAwardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAwardReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetAwardReq proto.InternalMessageInfo

type GetAwardRsp struct {
	PlayerId             int32           `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	AwardList            []*GetAwardData `protobuf:"bytes,2,rep,name=AwardList,proto3" json:"AwardList,omitempty"`
	Code                 int32           `protobuf:"varint,4,opt,name=Code,proto3" json:"Code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetAwardRsp) Reset()         { *m = GetAwardRsp{} }
func (m *GetAwardRsp) String() string { return proto.CompactTextString(m) }
func (*GetAwardRsp) ProtoMessage()    {}
func (*GetAwardRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{34}
}
func (m *GetAwardRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAwardRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAwardRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAwardRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAwardRsp.Merge(m, src)
}
func (m *GetAwardRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetAwardRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAwardRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetAwardRsp proto.InternalMessageInfo

//AMC_C_AwardCount:奖励数量
type AwardCountReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AwardCountReq) Reset()         { *m = AwardCountReq{} }
func (m *AwardCountReq) String() string { return proto.CompactTextString(m) }
func (*AwardCountReq) ProtoMessage()    {}
func (*AwardCountReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{35}
}
func (m *AwardCountReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardCountReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardCountReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardCountReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardCountReq.Merge(m, src)
}
func (m *AwardCountReq) XXX_Size() int {
	return m.Size()
}
func (m *AwardCountReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardCountReq.DiscardUnknown(m)
}

var xxx_messageInfo_AwardCountReq proto.InternalMessageInfo

type AwardCountRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId"`
	Count                int32    `protobuf:"varint,4,opt,name=Count,proto3" json:"Count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AwardCountRsp) Reset()         { *m = AwardCountRsp{} }
func (m *AwardCountRsp) String() string { return proto.CompactTextString(m) }
func (*AwardCountRsp) ProtoMessage()    {}
func (*AwardCountRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{36}
}
func (m *AwardCountRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardCountRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardCountRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardCountRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardCountRsp.Merge(m, src)
}
func (m *AwardCountRsp) XXX_Size() int {
	return m.Size()
}
func (m *AwardCountRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardCountRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AwardCountRsp proto.InternalMessageInfo

type Condition struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Value                int32    `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Condition) Reset()         { *m = Condition{} }
func (m *Condition) String() string { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()    {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{37}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

type RankListReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Type                 int32    `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Areantype            int32    `protobuf:"varint,3,opt,name=Areantype,proto3" json:"Areantype,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RankListReq) Reset()         { *m = RankListReq{} }
func (m *RankListReq) String() string { return proto.CompactTextString(m) }
func (*RankListReq) ProtoMessage()    {}
func (*RankListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{38}
}
func (m *RankListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankListReq.Merge(m, src)
}
func (m *RankListReq) XXX_Size() int {
	return m.Size()
}
func (m *RankListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RankListReq.DiscardUnknown(m)
}

var xxx_messageInfo_RankListReq proto.InternalMessageInfo

type RankListInfo struct {
	StartRank            int32    `protobuf:"varint,1,opt,name=StartRank,proto3" json:"StartRank,omitempty"`
	EndRank              int32    `protobuf:"varint,2,opt,name=EndRank,proto3" json:"EndRank,omitempty"`
	UserType             int32    `protobuf:"varint,3,opt,name=UserType,proto3" json:"UserType,omitempty"`
	Name                 string   `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	Icon                 string   `protobuf:"bytes,5,opt,name=Icon,proto3" json:"Icon,omitempty"`
	Mark                 int32    `protobuf:"varint,6,opt,name=Mark,proto3" json:"Mark,omitempty"`
	AwardId              int32    `protobuf:"varint,7,opt,name=AwardId,proto3" json:"AwardId,omitempty"`
	Award                int64    `protobuf:"varint,8,opt,name=Award,proto3" json:"Award,omitempty"`
	Multiple             int32    `protobuf:"varint,9,opt,name=Multiple,proto3" json:"Multiple,omitempty"`
	Stars                bool     `protobuf:"varint,10,opt,name=Stars,proto3" json:"Stars,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RankListInfo) Reset()         { *m = RankListInfo{} }
func (m *RankListInfo) String() string { return proto.CompactTextString(m) }
func (*RankListInfo) ProtoMessage()    {}
func (*RankListInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{39}
}
func (m *RankListInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankListInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankListInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankListInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankListInfo.Merge(m, src)
}
func (m *RankListInfo) XXX_Size() int {
	return m.Size()
}
func (m *RankListInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RankListInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RankListInfo proto.InternalMessageInfo

type RankListRsp struct {
	Type                 int32           `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	TypeTip              string          `protobuf:"bytes,2,opt,name=TypeTip,proto3" json:"TypeTip,omitempty"`
	Areantype            int32           `protobuf:"varint,3,opt,name=Areantype,proto3" json:"Areantype,omitempty"`
	RankList             []*RankListInfo `protobuf:"bytes,4,rep,name=RankList,proto3" json:"RankList,omitempty"`
	Rank                 int32           `protobuf:"varint,5,opt,name=Rank,proto3" json:"Rank,omitempty"`
	TotalRank            int32           `protobuf:"varint,6,opt,name=TotalRank,proto3" json:"TotalRank,omitempty"`
	Mark                 int32           `protobuf:"varint,7,opt,name=Mark,proto3" json:"Mark,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RankListRsp) Reset()         { *m = RankListRsp{} }
func (m *RankListRsp) String() string { return proto.CompactTextString(m) }
func (*RankListRsp) ProtoMessage()    {}
func (*RankListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{40}
}
func (m *RankListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankListRsp.Merge(m, src)
}
func (m *RankListRsp) XXX_Size() int {
	return m.Size()
}
func (m *RankListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RankListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RankListRsp proto.InternalMessageInfo

//AMC_C_P_MatchList:全民比赛列表
type PMatchInfo struct {
	Type                 int32        `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	TypeTips             string       `protobuf:"bytes,2,opt,name=TypeTips,proto3" json:"TypeTips,omitempty"`
	Id                   int32        `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	JoinTimes            int32        `protobuf:"varint,4,opt,name=JoinTimes,proto3" json:"JoinTimes,omitempty"`
	TotalTimes           int32        `protobuf:"varint,5,opt,name=TotalTimes,proto3" json:"TotalTimes,omitempty"`
	TimeStatus           int32        `protobuf:"varint,6,opt,name=TimeStatus,proto3" json:"TimeStatus,omitempty"`
	Hour                 int32        `protobuf:"varint,7,opt,name=Hour,proto3" json:"Hour,omitempty"`
	Minute               int32        `protobuf:"varint,8,opt,name=Minute,proto3" json:"Minute,omitempty"`
	Status               int32        `protobuf:"varint,9,opt,name=Status,proto3" json:"Status,omitempty"`
	ConditionList        []*Condition `protobuf:"bytes,10,rep,name=ConditionList,proto3" json:"ConditionList,omitempty"`
	Rank                 int32        `protobuf:"varint,11,opt,name=Rank,proto3" json:"Rank,omitempty"`
	TotalRank            int32        `protobuf:"varint,12,opt,name=TotalRank,proto3" json:"TotalRank,omitempty"`
	Award                int64        `protobuf:"varint,13,opt,name=Award,proto3" json:"Award,omitempty"`
	Multiple             int32        `protobuf:"varint,14,opt,name=Multiple,proto3" json:"Multiple,omitempty"`
	AwardCount           int32        `protobuf:"varint,15,opt,name=AwardCount,proto3" json:"AwardCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PMatchInfo) Reset()         { *m = PMatchInfo{} }
func (m *PMatchInfo) String() string { return proto.CompactTextString(m) }
func (*PMatchInfo) ProtoMessage()    {}
func (*PMatchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{41}
}
func (m *PMatchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PMatchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PMatchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PMatchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PMatchInfo.Merge(m, src)
}
func (m *PMatchInfo) XXX_Size() int {
	return m.Size()
}
func (m *PMatchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PMatchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PMatchInfo proto.InternalMessageInfo

type PMatchListReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PMatchListReq) Reset()         { *m = PMatchListReq{} }
func (m *PMatchListReq) String() string { return proto.CompactTextString(m) }
func (*PMatchListReq) ProtoMessage()    {}
func (*PMatchListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{42}
}
func (m *PMatchListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PMatchListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PMatchListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PMatchListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PMatchListReq.Merge(m, src)
}
func (m *PMatchListReq) XXX_Size() int {
	return m.Size()
}
func (m *PMatchListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PMatchListReq.DiscardUnknown(m)
}

var xxx_messageInfo_PMatchListReq proto.InternalMessageInfo

type PMatchListRsp struct {
	MatchList            []*PMatchInfo `protobuf:"bytes,1,rep,name=MatchList,proto3" json:"MatchList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PMatchListRsp) Reset()         { *m = PMatchListRsp{} }
func (m *PMatchListRsp) String() string { return proto.CompactTextString(m) }
func (*PMatchListRsp) ProtoMessage()    {}
func (*PMatchListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{43}
}
func (m *PMatchListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PMatchListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PMatchListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PMatchListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PMatchListRsp.Merge(m, src)
}
func (m *PMatchListRsp) XXX_Size() int {
	return m.Size()
}
func (m *PMatchListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PMatchListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PMatchListRsp proto.InternalMessageInfo

//AMC_C_PSignUp
type PSignUpReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Head                 string   `protobuf:"bytes,3,opt,name=Head,proto3" json:"Head,omitempty"`
	Type                 int32    `protobuf:"varint,4,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,5,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PSignUpReq) Reset()         { *m = PSignUpReq{} }
func (m *PSignUpReq) String() string { return proto.CompactTextString(m) }
func (*PSignUpReq) ProtoMessage()    {}
func (*PSignUpReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{44}
}
func (m *PSignUpReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PSignUpReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PSignUpReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PSignUpReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PSignUpReq.Merge(m, src)
}
func (m *PSignUpReq) XXX_Size() int {
	return m.Size()
}
func (m *PSignUpReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PSignUpReq.DiscardUnknown(m)
}

var xxx_messageInfo_PSignUpReq proto.InternalMessageInfo

type PSignUpRsp struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Type                 int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Money                int64    `protobuf:"varint,3,opt,name=money,proto3" json:"money,omitempty"`
	Core                 int32    `protobuf:"varint,4,opt,name=core,proto3" json:"core,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PSignUpRsp) Reset()         { *m = PSignUpRsp{} }
func (m *PSignUpRsp) String() string { return proto.CompactTextString(m) }
func (*PSignUpRsp) ProtoMessage()    {}
func (*PSignUpRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{45}
}
func (m *PSignUpRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PSignUpRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PSignUpRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PSignUpRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PSignUpRsp.Merge(m, src)
}
func (m *PSignUpRsp) XXX_Size() int {
	return m.Size()
}
func (m *PSignUpRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PSignUpRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PSignUpRsp proto.InternalMessageInfo

//------------------------- 客户端部分-快速比赛 ------------------------------------
//AMC_C_F_MatchList:快速比赛列表
type FMatchInfo struct {
	Type                 int32        `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	TypeTips             string       `protobuf:"bytes,2,opt,name=TypeTips,proto3" json:"TypeTips,omitempty"`
	Id                   int32        `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	OpenTime             string       `protobuf:"bytes,4,opt,name=OpenTime,proto3" json:"OpenTime,omitempty"`
	PlayerTimes          int32        `protobuf:"varint,5,opt,name=PlayerTimes,proto3" json:"PlayerTimes,omitempty"`
	JoinTimes            int32        `protobuf:"varint,6,opt,name=JoinTimes,proto3" json:"JoinTimes,omitempty"`
	TotalTimes           int32        `protobuf:"varint,7,opt,name=TotalTimes,proto3" json:"TotalTimes,omitempty"`
	MatchTime            int32        `protobuf:"varint,8,opt,name=MatchTime,proto3" json:"MatchTime,omitempty"`
	ConditionList        []*Condition `protobuf:"bytes,9,rep,name=ConditionList,proto3" json:"ConditionList,omitempty"`
	AwardList            []int64      `protobuf:"varint,10,rep,packed,name=AwardList,proto3" json:"AwardList,omitempty"`
	Status               int32        `protobuf:"varint,11,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *FMatchInfo) Reset()         { *m = FMatchInfo{} }
func (m *FMatchInfo) String() string { return proto.CompactTextString(m) }
func (*FMatchInfo) ProtoMessage()    {}
func (*FMatchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{46}
}
func (m *FMatchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FMatchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FMatchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FMatchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FMatchInfo.Merge(m, src)
}
func (m *FMatchInfo) XXX_Size() int {
	return m.Size()
}
func (m *FMatchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FMatchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FMatchInfo proto.InternalMessageInfo

type FMatchListReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FMatchListReq) Reset()         { *m = FMatchListReq{} }
func (m *FMatchListReq) String() string { return proto.CompactTextString(m) }
func (*FMatchListReq) ProtoMessage()    {}
func (*FMatchListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{47}
}
func (m *FMatchListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FMatchListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FMatchListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FMatchListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FMatchListReq.Merge(m, src)
}
func (m *FMatchListReq) XXX_Size() int {
	return m.Size()
}
func (m *FMatchListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FMatchListReq.DiscardUnknown(m)
}

var xxx_messageInfo_FMatchListReq proto.InternalMessageInfo

type FMatchListRsp struct {
	MatchList            []*FMatchInfo `protobuf:"bytes,1,rep,name=MatchList,proto3" json:"MatchList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FMatchListRsp) Reset()         { *m = FMatchListRsp{} }
func (m *FMatchListRsp) String() string { return proto.CompactTextString(m) }
func (*FMatchListRsp) ProtoMessage()    {}
func (*FMatchListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{48}
}
func (m *FMatchListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FMatchListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FMatchListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FMatchListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FMatchListRsp.Merge(m, src)
}
func (m *FMatchListRsp) XXX_Size() int {
	return m.Size()
}
func (m *FMatchListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FMatchListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FMatchListRsp proto.InternalMessageInfo

//AMC_C_FSignUp
type PositionInfo struct {
	Latitude             float64  `protobuf:"fixed64,1,opt,name=Latitude,proto3" json:"Latitude,omitempty"`
	Longitude            float64  `protobuf:"fixed64,2,opt,name=Longitude,proto3" json:"Longitude,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PositionInfo) Reset()         { *m = PositionInfo{} }
func (m *PositionInfo) String() string { return proto.CompactTextString(m) }
func (*PositionInfo) ProtoMessage()    {}
func (*PositionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{49}
}
func (m *PositionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionInfo.Merge(m, src)
}
func (m *PositionInfo) XXX_Size() int {
	return m.Size()
}
func (m *PositionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PositionInfo proto.InternalMessageInfo

type FSignUpReq struct {
	PlayerId             int32         `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Name                 string        `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Head                 string        `protobuf:"bytes,3,opt,name=Head,proto3" json:"Head,omitempty"`
	Type                 int32         `protobuf:"varint,4,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32         `protobuf:"varint,5,opt,name=Id,proto3" json:"Id,omitempty"`
	Ip                   string        `protobuf:"bytes,6,opt,name=Ip,proto3" json:"Ip,omitempty"`
	Position             *PositionInfo `protobuf:"bytes,7,opt,name=Position,proto3" json:"Position,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FSignUpReq) Reset()         { *m = FSignUpReq{} }
func (m *FSignUpReq) String() string { return proto.CompactTextString(m) }
func (*FSignUpReq) ProtoMessage()    {}
func (*FSignUpReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{50}
}
func (m *FSignUpReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FSignUpReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FSignUpReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FSignUpReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FSignUpReq.Merge(m, src)
}
func (m *FSignUpReq) XXX_Size() int {
	return m.Size()
}
func (m *FSignUpReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FSignUpReq.DiscardUnknown(m)
}

var xxx_messageInfo_FSignUpReq proto.InternalMessageInfo

type FSignUpRsp struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Type                 int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Money                int64    `protobuf:"varint,3,opt,name=money,proto3" json:"money,omitempty"`
	Core                 int32    `protobuf:"varint,4,opt,name=core,proto3" json:"core,omitempty"`
	Url                  string   `protobuf:"bytes,5,opt,name=Url,proto3" json:"Url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FSignUpRsp) Reset()         { *m = FSignUpRsp{} }
func (m *FSignUpRsp) String() string { return proto.CompactTextString(m) }
func (*FSignUpRsp) ProtoMessage()    {}
func (*FSignUpRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{51}
}
func (m *FSignUpRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FSignUpRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FSignUpRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FSignUpRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FSignUpRsp.Merge(m, src)
}
func (m *FSignUpRsp) XXX_Size() int {
	return m.Size()
}
func (m *FSignUpRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FSignUpRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FSignUpRsp proto.InternalMessageInfo

//AMC_C_FWaitMatch:等待比赛开始
type FWaitMatchReq struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FWaitMatchReq) Reset()         { *m = FWaitMatchReq{} }
func (m *FWaitMatchReq) String() string { return proto.CompactTextString(m) }
func (*FWaitMatchReq) ProtoMessage()    {}
func (*FWaitMatchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{52}
}
func (m *FWaitMatchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FWaitMatchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FWaitMatchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FWaitMatchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FWaitMatchReq.Merge(m, src)
}
func (m *FWaitMatchReq) XXX_Size() int {
	return m.Size()
}
func (m *FWaitMatchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FWaitMatchReq.DiscardUnknown(m)
}

var xxx_messageInfo_FWaitMatchReq proto.InternalMessageInfo

type FWaitMatchRsp struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Status               int32    `protobuf:"varint,4,opt,name=Status,proto3" json:"Status,omitempty"`
	Join                 int32    `protobuf:"varint,5,opt,name=Join,proto3" json:"Join,omitempty"`
	Total                int32    `protobuf:"varint,6,opt,name=Total,proto3" json:"Total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FWaitMatchRsp) Reset()         { *m = FWaitMatchRsp{} }
func (m *FWaitMatchRsp) String() string { return proto.CompactTextString(m) }
func (*FWaitMatchRsp) ProtoMessage()    {}
func (*FWaitMatchRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{53}
}
func (m *FWaitMatchRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FWaitMatchRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FWaitMatchRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FWaitMatchRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FWaitMatchRsp.Merge(m, src)
}
func (m *FWaitMatchRsp) XXX_Size() int {
	return m.Size()
}
func (m *FWaitMatchRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FWaitMatchRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FWaitMatchRsp proto.InternalMessageInfo

//AMC_C_FCancelMatch:取消报名
type FCancelMatchReq struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FCancelMatchReq) Reset()         { *m = FCancelMatchReq{} }
func (m *FCancelMatchReq) String() string { return proto.CompactTextString(m) }
func (*FCancelMatchReq) ProtoMessage()    {}
func (*FCancelMatchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{54}
}
func (m *FCancelMatchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FCancelMatchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FCancelMatchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FCancelMatchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FCancelMatchReq.Merge(m, src)
}
func (m *FCancelMatchReq) XXX_Size() int {
	return m.Size()
}
func (m *FCancelMatchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FCancelMatchReq.DiscardUnknown(m)
}

var xxx_messageInfo_FCancelMatchReq proto.InternalMessageInfo

type FCancelMatchRsp struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Result               int32    `protobuf:"varint,4,opt,name=Result,proto3" json:"Result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FCancelMatchRsp) Reset()         { *m = FCancelMatchRsp{} }
func (m *FCancelMatchRsp) String() string { return proto.CompactTextString(m) }
func (*FCancelMatchRsp) ProtoMessage()    {}
func (*FCancelMatchRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{55}
}
func (m *FCancelMatchRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FCancelMatchRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FCancelMatchRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FCancelMatchRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FCancelMatchRsp.Merge(m, src)
}
func (m *FCancelMatchRsp) XXX_Size() int {
	return m.Size()
}
func (m *FCancelMatchRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FCancelMatchRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FCancelMatchRsp proto.InternalMessageInfo

//AMC_C_FConfirm
type FConfirmReq struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FConfirmReq) Reset()         { *m = FConfirmReq{} }
func (m *FConfirmReq) String() string { return proto.CompactTextString(m) }
func (*FConfirmReq) ProtoMessage()    {}
func (*FConfirmReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{56}
}
func (m *FConfirmReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FConfirmReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FConfirmReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FConfirmReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FConfirmReq.Merge(m, src)
}
func (m *FConfirmReq) XXX_Size() int {
	return m.Size()
}
func (m *FConfirmReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FConfirmReq.DiscardUnknown(m)
}

var xxx_messageInfo_FConfirmReq proto.InternalMessageInfo

type FConfirmRsp struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Result               int32    `protobuf:"varint,4,opt,name=Result,proto3" json:"Result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FConfirmRsp) Reset()         { *m = FConfirmRsp{} }
func (m *FConfirmRsp) String() string { return proto.CompactTextString(m) }
func (*FConfirmRsp) ProtoMessage()    {}
func (*FConfirmRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{57}
}
func (m *FConfirmRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FConfirmRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FConfirmRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FConfirmRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FConfirmRsp.Merge(m, src)
}
func (m *FConfirmRsp) XXX_Size() int {
	return m.Size()
}
func (m *FConfirmRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FConfirmRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FConfirmRsp proto.InternalMessageInfo

type FRobotLoginReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FRobotLoginReq) Reset()         { *m = FRobotLoginReq{} }
func (m *FRobotLoginReq) String() string { return proto.CompactTextString(m) }
func (*FRobotLoginReq) ProtoMessage()    {}
func (*FRobotLoginReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{58}
}
func (m *FRobotLoginReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FRobotLoginReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FRobotLoginReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FRobotLoginReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FRobotLoginReq.Merge(m, src)
}
func (m *FRobotLoginReq) XXX_Size() int {
	return m.Size()
}
func (m *FRobotLoginReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FRobotLoginReq.DiscardUnknown(m)
}

var xxx_messageInfo_FRobotLoginReq proto.InternalMessageInfo

type FRobotLoginRsp struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Core                 int32    `protobuf:"varint,2,opt,name=Core,proto3" json:"Core,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FRobotLoginRsp) Reset()         { *m = FRobotLoginRsp{} }
func (m *FRobotLoginRsp) String() string { return proto.CompactTextString(m) }
func (*FRobotLoginRsp) ProtoMessage()    {}
func (*FRobotLoginRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{59}
}
func (m *FRobotLoginRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FRobotLoginRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FRobotLoginRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FRobotLoginRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FRobotLoginRsp.Merge(m, src)
}
func (m *FRobotLoginRsp) XXX_Size() int {
	return m.Size()
}
func (m *FRobotLoginRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FRobotLoginRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FRobotLoginRsp proto.InternalMessageInfo

type FRobotJoinMatchRsp struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Type                 int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	Difficulty           int32    `protobuf:"varint,4,opt,name=Difficulty,proto3" json:"Difficulty,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FRobotJoinMatchRsp) Reset()         { *m = FRobotJoinMatchRsp{} }
func (m *FRobotJoinMatchRsp) String() string { return proto.CompactTextString(m) }
func (*FRobotJoinMatchRsp) ProtoMessage()    {}
func (*FRobotJoinMatchRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{60}
}
func (m *FRobotJoinMatchRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FRobotJoinMatchRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FRobotJoinMatchRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FRobotJoinMatchRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FRobotJoinMatchRsp.Merge(m, src)
}
func (m *FRobotJoinMatchRsp) XXX_Size() int {
	return m.Size()
}
func (m *FRobotJoinMatchRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FRobotJoinMatchRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FRobotJoinMatchRsp proto.InternalMessageInfo

type FRobotHeartReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FRobotHeartReq) Reset()         { *m = FRobotHeartReq{} }
func (m *FRobotHeartReq) String() string { return proto.CompactTextString(m) }
func (*FRobotHeartReq) ProtoMessage()    {}
func (*FRobotHeartReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{61}
}
func (m *FRobotHeartReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FRobotHeartReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FRobotHeartReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FRobotHeartReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FRobotHeartReq.Merge(m, src)
}
func (m *FRobotHeartReq) XXX_Size() int {
	return m.Size()
}
func (m *FRobotHeartReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FRobotHeartReq.DiscardUnknown(m)
}

var xxx_messageInfo_FRobotHeartReq proto.InternalMessageInfo

type FRobotHeartRsp struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Core                 int32    `protobuf:"varint,2,opt,name=Core,proto3" json:"Core,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FRobotHeartRsp) Reset()         { *m = FRobotHeartRsp{} }
func (m *FRobotHeartRsp) String() string { return proto.CompactTextString(m) }
func (*FRobotHeartRsp) ProtoMessage()    {}
func (*FRobotHeartRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{62}
}
func (m *FRobotHeartRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FRobotHeartRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FRobotHeartRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FRobotHeartRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FRobotHeartRsp.Merge(m, src)
}
func (m *FRobotHeartRsp) XXX_Size() int {
	return m.Size()
}
func (m *FRobotHeartRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FRobotHeartRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FRobotHeartRsp proto.InternalMessageInfo

// redis消息封装
// 消息协议
type Message struct {
	// 玩家ID
	PlayerId int64 `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	// 操作码
	Ops int32 `protobuf:"varint,2,opt,name=Ops,proto3" json:"Ops,omitempty"`
	// 数据
	Data []byte `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
	//长度
	Size_                int32    `protobuf:"varint,4,opt,name=Size,proto3" json:"Size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{63}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

type ReportStatusReq struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	ServerId             int64    `protobuf:"varint,2,opt,name=ServerId,proto3" json:"ServerId,omitempty"`
	Id                   int64    `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	PlayerId             int64    `protobuf:"varint,4,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Status               int32    `protobuf:"varint,5,opt,name=Status,proto3" json:"Status,omitempty"`
	TableId              int64    `protobuf:"varint,6,opt,name=TableId,proto3" json:"TableId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportStatusReq) Reset()         { *m = ReportStatusReq{} }
func (m *ReportStatusReq) String() string { return proto.CompactTextString(m) }
func (*ReportStatusReq) ProtoMessage()    {}
func (*ReportStatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{64}
}
func (m *ReportStatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportStatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportStatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportStatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportStatusReq.Merge(m, src)
}
func (m *ReportStatusReq) XXX_Size() int {
	return m.Size()
}
func (m *ReportStatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportStatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReportStatusReq proto.InternalMessageInfo

//AMC_S_GameCountDown:比赛倒计时
type GameCountDown struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int64    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	TableId              int64    `protobuf:"varint,3,opt,name=TableId,proto3" json:"TableId,omitempty"`
	Sce                  int32    `protobuf:"varint,4,opt,name=Sce,proto3" json:"Sce,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameCountDown) Reset()         { *m = GameCountDown{} }
func (m *GameCountDown) String() string { return proto.CompactTextString(m) }
func (*GameCountDown) ProtoMessage()    {}
func (*GameCountDown) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{65}
}
func (m *GameCountDown) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameCountDown) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameCountDown.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameCountDown) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameCountDown.Merge(m, src)
}
func (m *GameCountDown) XXX_Size() int {
	return m.Size()
}
func (m *GameCountDown) XXX_DiscardUnknown() {
	xxx_messageInfo_GameCountDown.DiscardUnknown(m)
}

var xxx_messageInfo_GameCountDown proto.InternalMessageInfo

//---------------------- 游戏服务器-大师赛 ----------------------
type GReportMatchReq struct {
	PlayerId             int64    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Type                 int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int64    `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	MaxMark              int64    `protobuf:"varint,4,opt,name=MaxMark,proto3" json:"MaxMark,omitempty"`
	Bullet               int32    `protobuf:"varint,5,opt,name=Bullet,proto3" json:"Bullet,omitempty"`
	ReportType           int32    `protobuf:"varint,6,opt,name=ReportType,proto3" json:"ReportType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GReportMatchReq) Reset()         { *m = GReportMatchReq{} }
func (m *GReportMatchReq) String() string { return proto.CompactTextString(m) }
func (*GReportMatchReq) ProtoMessage()    {}
func (*GReportMatchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{66}
}
func (m *GReportMatchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GReportMatchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GReportMatchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GReportMatchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GReportMatchReq.Merge(m, src)
}
func (m *GReportMatchReq) XXX_Size() int {
	return m.Size()
}
func (m *GReportMatchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GReportMatchReq.DiscardUnknown(m)
}

var xxx_messageInfo_GReportMatchReq proto.InternalMessageInfo

type GReportMatch struct {
	PlayerId             int64    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Type                 int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int64    `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	MaxMark              int32    `protobuf:"varint,4,opt,name=MaxMark,proto3" json:"MaxMark,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GReportMatch) Reset()         { *m = GReportMatch{} }
func (m *GReportMatch) String() string { return proto.CompactTextString(m) }
func (*GReportMatch) ProtoMessage()    {}
func (*GReportMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{67}
}
func (m *GReportMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GReportMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GReportMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GReportMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GReportMatch.Merge(m, src)
}
func (m *GReportMatch) XXX_Size() int {
	return m.Size()
}
func (m *GReportMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_GReportMatch.DiscardUnknown(m)
}

var xxx_messageInfo_GReportMatch proto.InternalMessageInfo

type GReportMatchRsp struct {
	Infos                []*GReportMatch `protobuf:"bytes,3,rep,name=Infos,proto3" json:"Infos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GReportMatchRsp) Reset()         { *m = GReportMatchRsp{} }
func (m *GReportMatchRsp) String() string { return proto.CompactTextString(m) }
func (*GReportMatchRsp) ProtoMessage()    {}
func (*GReportMatchRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{68}
}
func (m *GReportMatchRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GReportMatchRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GReportMatchRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GReportMatchRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GReportMatchRsp.Merge(m, src)
}
func (m *GReportMatchRsp) XXX_Size() int {
	return m.Size()
}
func (m *GReportMatchRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GReportMatchRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GReportMatchRsp proto.InternalMessageInfo

type GGameEnd struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GGameEnd) Reset()         { *m = GGameEnd{} }
func (m *GGameEnd) String() string { return proto.CompactTextString(m) }
func (*GGameEnd) ProtoMessage()    {}
func (*GGameEnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{69}
}
func (m *GGameEnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GGameEnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GGameEnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GGameEnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GGameEnd.Merge(m, src)
}
func (m *GGameEnd) XXX_Size() int {
	return m.Size()
}
func (m *GGameEnd) XXX_DiscardUnknown() {
	xxx_messageInfo_GGameEnd.DiscardUnknown(m)
}

var xxx_messageInfo_GGameEnd proto.InternalMessageInfo

type GGameCountDown struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int64    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	Sce                  int32    `protobuf:"varint,4,opt,name=Sce,proto3" json:"Sce,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GGameCountDown) Reset()         { *m = GGameCountDown{} }
func (m *GGameCountDown) String() string { return proto.CompactTextString(m) }
func (*GGameCountDown) ProtoMessage()    {}
func (*GGameCountDown) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{70}
}
func (m *GGameCountDown) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GGameCountDown) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GGameCountDown.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GGameCountDown) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GGameCountDown.Merge(m, src)
}
func (m *GGameCountDown) XXX_Size() int {
	return m.Size()
}
func (m *GGameCountDown) XXX_DiscardUnknown() {
	xxx_messageInfo_GGameCountDown.DiscardUnknown(m)
}

var xxx_messageInfo_GGameCountDown proto.InternalMessageInfo

type GameSettlement struct {
	Rank                 int32    `protobuf:"varint,1,opt,name=Rank,proto3" json:"Rank,omitempty"`
	Total                int32    `protobuf:"varint,2,opt,name=Total,proto3" json:"Total,omitempty"`
	VipAddition          int32    `protobuf:"varint,3,opt,name=VipAddition,proto3" json:"VipAddition,omitempty"`
	ChallengeAddition    int32    `protobuf:"varint,4,opt,name=ChallengeAddition,proto3" json:"ChallengeAddition,omitempty"`
	CurMark              int64    `protobuf:"varint,5,opt,name=CurMark,proto3" json:"CurMark,omitempty"`
	MaxMark              int64    `protobuf:"varint,6,opt,name=MaxMark,proto3" json:"MaxMark,omitempty"`
	Type                 int32    `protobuf:"varint,7,opt,name=Type,proto3" json:"Type,omitempty"`
	PlayerId             int64    `protobuf:"varint,8,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameSettlement) Reset()         { *m = GameSettlement{} }
func (m *GameSettlement) String() string { return proto.CompactTextString(m) }
func (*GameSettlement) ProtoMessage()    {}
func (*GameSettlement) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{71}
}
func (m *GameSettlement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameSettlement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameSettlement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameSettlement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameSettlement.Merge(m, src)
}
func (m *GameSettlement) XXX_Size() int {
	return m.Size()
}
func (m *GameSettlement) XXX_DiscardUnknown() {
	xxx_messageInfo_GameSettlement.DiscardUnknown(m)
}

var xxx_messageInfo_GameSettlement proto.InternalMessageInfo

type UpdateKeyValue struct {
	Key                  string   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateKeyValue) Reset()         { *m = UpdateKeyValue{} }
func (m *UpdateKeyValue) String() string { return proto.CompactTextString(m) }
func (*UpdateKeyValue) ProtoMessage()    {}
func (*UpdateKeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{72}
}
func (m *UpdateKeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateKeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateKeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateKeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateKeyValue.Merge(m, src)
}
func (m *UpdateKeyValue) XXX_Size() int {
	return m.Size()
}
func (m *UpdateKeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateKeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateKeyValue proto.InternalMessageInfo

//---------------------- 游戏服务器-全民赛 ----------------------
//AMC_S_P_ReportMatch
type PReportMatchReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Type                 int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	MaxMark              int32    `protobuf:"varint,4,opt,name=MaxMark,proto3" json:"MaxMark,omitempty"`
	Score                int32    `protobuf:"varint,5,opt,name=Score,proto3" json:"Score,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PReportMatchReq) Reset()         { *m = PReportMatchReq{} }
func (m *PReportMatchReq) String() string { return proto.CompactTextString(m) }
func (*PReportMatchReq) ProtoMessage()    {}
func (*PReportMatchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{73}
}
func (m *PReportMatchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PReportMatchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PReportMatchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PReportMatchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PReportMatchReq.Merge(m, src)
}
func (m *PReportMatchReq) XXX_Size() int {
	return m.Size()
}
func (m *PReportMatchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PReportMatchReq.DiscardUnknown(m)
}

var xxx_messageInfo_PReportMatchReq proto.InternalMessageInfo

type PReportMatch struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Type                 int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	MaxMark              int32    `protobuf:"varint,4,opt,name=MaxMark,proto3" json:"MaxMark,omitempty"`
	Name                 string   `protobuf:"bytes,5,opt,name=Name,proto3" json:"Name,omitempty"`
	Head                 string   `protobuf:"bytes,6,opt,name=Head,proto3" json:"Head,omitempty"`
	RankIdx              int32    `protobuf:"varint,7,opt,name=RankIdx,proto3" json:"RankIdx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PReportMatch) Reset()         { *m = PReportMatch{} }
func (m *PReportMatch) String() string { return proto.CompactTextString(m) }
func (*PReportMatch) ProtoMessage()    {}
func (*PReportMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{74}
}
func (m *PReportMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PReportMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PReportMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PReportMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PReportMatch.Merge(m, src)
}
func (m *PReportMatch) XXX_Size() int {
	return m.Size()
}
func (m *PReportMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_PReportMatch.DiscardUnknown(m)
}

var xxx_messageInfo_PReportMatch proto.InternalMessageInfo

type PReportMatchRsp struct {
	Infos                []*PReportMatch `protobuf:"bytes,1,rep,name=Infos,proto3" json:"Infos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PReportMatchRsp) Reset()         { *m = PReportMatchRsp{} }
func (m *PReportMatchRsp) String() string { return proto.CompactTextString(m) }
func (*PReportMatchRsp) ProtoMessage()    {}
func (*PReportMatchRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{75}
}
func (m *PReportMatchRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PReportMatchRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PReportMatchRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PReportMatchRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PReportMatchRsp.Merge(m, src)
}
func (m *PReportMatchRsp) XXX_Size() int {
	return m.Size()
}
func (m *PReportMatchRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PReportMatchRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PReportMatchRsp proto.InternalMessageInfo

//AMC_S_P_GameEnd:比赛结束
type PGameEnd struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PGameEnd) Reset()         { *m = PGameEnd{} }
func (m *PGameEnd) String() string { return proto.CompactTextString(m) }
func (*PGameEnd) ProtoMessage()    {}
func (*PGameEnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{76}
}
func (m *PGameEnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PGameEnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PGameEnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PGameEnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PGameEnd.Merge(m, src)
}
func (m *PGameEnd) XXX_Size() int {
	return m.Size()
}
func (m *PGameEnd) XXX_DiscardUnknown() {
	xxx_messageInfo_PGameEnd.DiscardUnknown(m)
}

var xxx_messageInfo_PGameEnd proto.InternalMessageInfo

//AMC_S_F_ReportMatch
type FReportMatchReq struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Type                 int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	ServerId             int32    `protobuf:"varint,3,opt,name=ServerId,proto3" json:"ServerId,omitempty"`
	TableId              int32    `protobuf:"varint,4,opt,name=TableId,proto3" json:"TableId,omitempty"`
	Mark                 int32    `protobuf:"varint,5,opt,name=Mark,proto3" json:"Mark,omitempty"`
	Score                int32    `protobuf:"varint,6,opt,name=Score,proto3" json:"Score,omitempty"`
	RatioChange          bool     `protobuf:"varint,7,opt,name=RatioChange,proto3" json:"RatioChange,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FReportMatchReq) Reset()         { *m = FReportMatchReq{} }
func (m *FReportMatchReq) String() string { return proto.CompactTextString(m) }
func (*FReportMatchReq) ProtoMessage()    {}
func (*FReportMatchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{77}
}
func (m *FReportMatchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FReportMatchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FReportMatchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FReportMatchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FReportMatchReq.Merge(m, src)
}
func (m *FReportMatchReq) XXX_Size() int {
	return m.Size()
}
func (m *FReportMatchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FReportMatchReq.DiscardUnknown(m)
}

var xxx_messageInfo_FReportMatchReq proto.InternalMessageInfo

type FReportMatch struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Type                 int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	TableId              int32    `protobuf:"varint,3,opt,name=TableId,proto3" json:"TableId,omitempty"`
	MaxMark              int32    `protobuf:"varint,4,opt,name=MaxMark,proto3" json:"MaxMark,omitempty"`
	RankIdx              int32    `protobuf:"varint,5,opt,name=RankIdx,proto3" json:"RankIdx,omitempty"`
	BulletCount          int32    `protobuf:"varint,6,opt,name=BulletCount,proto3" json:"BulletCount,omitempty"`
	BulletTotal          int32    `protobuf:"varint,7,opt,name=BulletTotal,proto3" json:"BulletTotal,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FReportMatch) Reset()         { *m = FReportMatch{} }
func (m *FReportMatch) String() string { return proto.CompactTextString(m) }
func (*FReportMatch) ProtoMessage()    {}
func (*FReportMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{78}
}
func (m *FReportMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FReportMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FReportMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FReportMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FReportMatch.Merge(m, src)
}
func (m *FReportMatch) XXX_Size() int {
	return m.Size()
}
func (m *FReportMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_FReportMatch.DiscardUnknown(m)
}

var xxx_messageInfo_FReportMatch proto.InternalMessageInfo

type FReportMatchRsp struct {
	Infos                []*FReportMatch `protobuf:"bytes,1,rep,name=Infos,proto3" json:"Infos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *FReportMatchRsp) Reset()         { *m = FReportMatchRsp{} }
func (m *FReportMatchRsp) String() string { return proto.CompactTextString(m) }
func (*FReportMatchRsp) ProtoMessage()    {}
func (*FReportMatchRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{79}
}
func (m *FReportMatchRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FReportMatchRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FReportMatchRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FReportMatchRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FReportMatchRsp.Merge(m, src)
}
func (m *FReportMatchRsp) XXX_Size() int {
	return m.Size()
}
func (m *FReportMatchRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FReportMatchRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FReportMatchRsp proto.InternalMessageInfo

type FSettlementNotice struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32    `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	TableId              []int32  `protobuf:"varint,3,rep,packed,name=TableId,proto3" json:"TableId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FSettlementNotice) Reset()         { *m = FSettlementNotice{} }
func (m *FSettlementNotice) String() string { return proto.CompactTextString(m) }
func (*FSettlementNotice) ProtoMessage()    {}
func (*FSettlementNotice) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{80}
}
func (m *FSettlementNotice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FSettlementNotice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FSettlementNotice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FSettlementNotice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FSettlementNotice.Merge(m, src)
}
func (m *FSettlementNotice) XXX_Size() int {
	return m.Size()
}
func (m *FSettlementNotice) XXX_DiscardUnknown() {
	xxx_messageInfo_FSettlementNotice.DiscardUnknown(m)
}

var xxx_messageInfo_FSettlementNotice proto.InternalMessageInfo

//AMC_S_F_GameEnd:比赛结束
type FPlayerResult struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Rank                 int32    `protobuf:"varint,2,opt,name=Rank,proto3" json:"Rank,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Mark                 int32    `protobuf:"varint,4,opt,name=Mark,proto3" json:"Mark,omitempty"`
	Award                int64    `protobuf:"varint,5,opt,name=Award,proto3" json:"Award,omitempty"`
	Date                 string   `protobuf:"bytes,6,opt,name=Date,proto3" json:"Date,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FPlayerResult) Reset()         { *m = FPlayerResult{} }
func (m *FPlayerResult) String() string { return proto.CompactTextString(m) }
func (*FPlayerResult) ProtoMessage()    {}
func (*FPlayerResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{81}
}
func (m *FPlayerResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FPlayerResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FPlayerResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FPlayerResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FPlayerResult.Merge(m, src)
}
func (m *FPlayerResult) XXX_Size() int {
	return m.Size()
}
func (m *FPlayerResult) XXX_DiscardUnknown() {
	xxx_messageInfo_FPlayerResult.DiscardUnknown(m)
}

var xxx_messageInfo_FPlayerResult proto.InternalMessageInfo

type FGameEnd struct {
	Type                 int32            `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Id                   int32            `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	TableId              []int32          `protobuf:"varint,3,rep,packed,name=TableId,proto3" json:"TableId,omitempty"`
	PlayerResultList     []*FPlayerResult `protobuf:"bytes,4,rep,name=PlayerResultList,proto3" json:"PlayerResultList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *FGameEnd) Reset()         { *m = FGameEnd{} }
func (m *FGameEnd) String() string { return proto.CompactTextString(m) }
func (*FGameEnd) ProtoMessage()    {}
func (*FGameEnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{82}
}
func (m *FGameEnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FGameEnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FGameEnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FGameEnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FGameEnd.Merge(m, src)
}
func (m *FGameEnd) XXX_Size() int {
	return m.Size()
}
func (m *FGameEnd) XXX_DiscardUnknown() {
	xxx_messageInfo_FGameEnd.DiscardUnknown(m)
}

var xxx_messageInfo_FGameEnd proto.InternalMessageInfo

type FRobotNameSynReq struct {
	Type                 int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	ServerId             int32    `protobuf:"varint,2,opt,name=ServerId,proto3" json:"ServerId,omitempty"`
	PlayerId             int32    `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FRobotNameSynReq) Reset()         { *m = FRobotNameSynReq{} }
func (m *FRobotNameSynReq) String() string { return proto.CompactTextString(m) }
func (*FRobotNameSynReq) ProtoMessage()    {}
func (*FRobotNameSynReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{83}
}
func (m *FRobotNameSynReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FRobotNameSynReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FRobotNameSynReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FRobotNameSynReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FRobotNameSynReq.Merge(m, src)
}
func (m *FRobotNameSynReq) XXX_Size() int {
	return m.Size()
}
func (m *FRobotNameSynReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FRobotNameSynReq.DiscardUnknown(m)
}

var xxx_messageInfo_FRobotNameSynReq proto.InternalMessageInfo

type FRobotNameSynRsp struct {
	PlayerId             int32    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FRobotNameSynRsp) Reset()         { *m = FRobotNameSynRsp{} }
func (m *FRobotNameSynRsp) String() string { return proto.CompactTextString(m) }
func (*FRobotNameSynRsp) ProtoMessage()    {}
func (*FRobotNameSynRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{84}
}
func (m *FRobotNameSynRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FRobotNameSynRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FRobotNameSynRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FRobotNameSynRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FRobotNameSynRsp.Merge(m, src)
}
func (m *FRobotNameSynRsp) XXX_Size() int {
	return m.Size()
}
func (m *FRobotNameSynRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FRobotNameSynRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FRobotNameSynRsp proto.InternalMessageInfo

type Chat struct {
	SectionWords         string   `protobuf:"bytes,1,opt,name=SectionWords,proto3" json:"SectionWords,omitempty"`
	FilterWords          string   `protobuf:"bytes,2,opt,name=FilterWords,proto3" json:"FilterWords,omitempty"`
	GameID               int32    `protobuf:"varint,3,opt,name=GameID,proto3" json:"GameID,omitempty"`
	ContentType          int32    `protobuf:"varint,4,opt,name=ContentType,proto3" json:"ContentType,omitempty"`
	Delaysec             int32    `protobuf:"varint,5,opt,name=Delaysec,proto3" json:"Delaysec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Chat) Reset()         { *m = Chat{} }
func (m *Chat) String() string { return proto.CompactTextString(m) }
func (*Chat) ProtoMessage()    {}
func (*Chat) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{85}
}
func (m *Chat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Chat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Chat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Chat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chat.Merge(m, src)
}
func (m *Chat) XXX_Size() int {
	return m.Size()
}
func (m *Chat) XXX_DiscardUnknown() {
	xxx_messageInfo_Chat.DiscardUnknown(m)
}

var xxx_messageInfo_Chat proto.InternalMessageInfo

//大厅显示用户的奖励数量HMC_AbyGameInfo
type AbyGameInfo struct {
	GameType             int32    `protobuf:"varint,1,opt,name=GameType,proto3" json:"GameType,omitempty"`
	PlayerId             int32    `protobuf:"varint,2,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Count                int32    `protobuf:"varint,3,opt,name=Count,proto3" json:"Count,omitempty"`
	Status               int32    `protobuf:"varint,4,opt,name=Status,proto3" json:"Status,omitempty"`
	Tips                 string   `protobuf:"bytes,5,opt,name=Tips,proto3" json:"Tips,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AbyGameInfo) Reset()         { *m = AbyGameInfo{} }
func (m *AbyGameInfo) String() string { return proto.CompactTextString(m) }
func (*AbyGameInfo) ProtoMessage()    {}
func (*AbyGameInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{86}
}
func (m *AbyGameInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AbyGameInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AbyGameInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AbyGameInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AbyGameInfo.Merge(m, src)
}
func (m *AbyGameInfo) XXX_Size() int {
	return m.Size()
}
func (m *AbyGameInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AbyGameInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AbyGameInfo proto.InternalMessageInfo

type RewardFish struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id" validate:"required"`
	Num                  int32    `protobuf:"varint,2,opt,name=num,proto3" json:"num" validate:"required"`
	CaptureNum           int32    `protobuf:"varint,3,opt,name=capture_num,json=captureNum,proto3" json:"capture_num" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RewardFish) Reset()         { *m = RewardFish{} }
func (m *RewardFish) String() string { return proto.CompactTextString(m) }
func (*RewardFish) ProtoMessage()    {}
func (*RewardFish) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{87}
}
func (m *RewardFish) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardFish) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardFish.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardFish) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardFish.Merge(m, src)
}
func (m *RewardFish) XXX_Size() int {
	return m.Size()
}
func (m *RewardFish) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardFish.DiscardUnknown(m)
}

var xxx_messageInfo_RewardFish proto.InternalMessageInfo

type RewardTaskGetReq struct {
	UserId               int32    `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RewardTaskGetReq) Reset()         { *m = RewardTaskGetReq{} }
func (m *RewardTaskGetReq) String() string { return proto.CompactTextString(m) }
func (*RewardTaskGetReq) ProtoMessage()    {}
func (*RewardTaskGetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{88}
}
func (m *RewardTaskGetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardTaskGetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardTaskGetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardTaskGetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardTaskGetReq.Merge(m, src)
}
func (m *RewardTaskGetReq) XXX_Size() int {
	return m.Size()
}
func (m *RewardTaskGetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardTaskGetReq.DiscardUnknown(m)
}

var xxx_messageInfo_RewardTaskGetReq proto.InternalMessageInfo

type RewardTaskGetRsp struct {
	Code                 int32         `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string        `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	TaskId               int32         `protobuf:"varint,3,opt,name=task_id,json=taskId,proto3" json:"task_id" validate:"required"`
	Reward               int32         `protobuf:"varint,4,opt,name=reward,proto3" json:"reward" validate:"required"`
	Clock                int64         `protobuf:"varint,5,opt,name=clock,proto3" json:"clock" validate:"required"`
	TaskStatus           int32         `protobuf:"varint,6,opt,name=task_status,json=taskStatus,proto3" json:"TaskStatus" validate:"required"`
	RewardFish           []*RewardFish `protobuf:"bytes,7,rep,name=reward_fish,json=rewardFish,proto3" json:"reward_fish" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RewardTaskGetRsp) Reset()         { *m = RewardTaskGetRsp{} }
func (m *RewardTaskGetRsp) String() string { return proto.CompactTextString(m) }
func (*RewardTaskGetRsp) ProtoMessage()    {}
func (*RewardTaskGetRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{89}
}
func (m *RewardTaskGetRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardTaskGetRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardTaskGetRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardTaskGetRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardTaskGetRsp.Merge(m, src)
}
func (m *RewardTaskGetRsp) XXX_Size() int {
	return m.Size()
}
func (m *RewardTaskGetRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardTaskGetRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RewardTaskGetRsp proto.InternalMessageInfo

type RewardTaskUpdateReq struct {
	UserId               int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId" validate:"required"`
	TaskId               int32         `protobuf:"varint,2,opt,name=task_id,json=taskId,proto3" json:"task_id" validate:"required"`
	Reward               int32         `protobuf:"varint,3,opt,name=reward,proto3" json:"reward" validate:"required"`
	Clock                int64         `protobuf:"varint,4,opt,name=clock,proto3" json:"clock" validate:"required"`
	TaskStatus           int32         `protobuf:"varint,5,opt,name=task_status,json=taskStatus,proto3" json:"TaskStatus" validate:"required"`
	RewardFish           []*RewardFish `protobuf:"bytes,6,rep,name=reward_fish,json=rewardFish,proto3" json:"reward_fish" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RewardTaskUpdateReq) Reset()         { *m = RewardTaskUpdateReq{} }
func (m *RewardTaskUpdateReq) String() string { return proto.CompactTextString(m) }
func (*RewardTaskUpdateReq) ProtoMessage()    {}
func (*RewardTaskUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{90}
}
func (m *RewardTaskUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardTaskUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardTaskUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardTaskUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardTaskUpdateReq.Merge(m, src)
}
func (m *RewardTaskUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *RewardTaskUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardTaskUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_RewardTaskUpdateReq proto.InternalMessageInfo

type ReportStatusReqV2 struct {
	UserId               int32    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"UserId" validate:"required"`
	Status               int32    `protobuf:"varint,2,opt,name=status,proto3" json:"Status" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportStatusReqV2) Reset()         { *m = ReportStatusReqV2{} }
func (m *ReportStatusReqV2) String() string { return proto.CompactTextString(m) }
func (*ReportStatusReqV2) ProtoMessage()    {}
func (*ReportStatusReqV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{91}
}
func (m *ReportStatusReqV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportStatusReqV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportStatusReqV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportStatusReqV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportStatusReqV2.Merge(m, src)
}
func (m *ReportStatusReqV2) XXX_Size() int {
	return m.Size()
}
func (m *ReportStatusReqV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportStatusReqV2.DiscardUnknown(m)
}

var xxx_messageInfo_ReportStatusReqV2 proto.InternalMessageInfo

type CommonResp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonResp) Reset()         { *m = CommonResp{} }
func (m *CommonResp) String() string { return proto.CompactTextString(m) }
func (*CommonResp) ProtoMessage()    {}
func (*CommonResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{92}
}
func (m *CommonResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonResp.Merge(m, src)
}
func (m *CommonResp) XXX_Size() int {
	return m.Size()
}
func (m *CommonResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonResp.DiscardUnknown(m)
}

var xxx_messageInfo_CommonResp proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("arenaServer.service.v1.ArenaMsgCode", ArenaMsgCode_name, ArenaMsgCode_value)
	proto.RegisterEnum("arenaServer.service.v1.ArenaMsgErrorCode", ArenaMsgErrorCode_name, ArenaMsgErrorCode_value)
	proto.RegisterEnum("arenaServer.service.v1.SignUpCore", SignUpCore_name, SignUpCore_value)
	proto.RegisterEnum("arenaServer.service.v1.AwardCode", AwardCode_name, AwardCode_value)
	proto.RegisterEnum("arenaServer.service.v1.ConditionType", ConditionType_name, ConditionType_value)
	proto.RegisterEnum("arenaServer.service.v1.MatchStatus", MatchStatus_name, MatchStatus_value)
	proto.RegisterEnum("arenaServer.service.v1.AwardUserType", AwardUserType_name, AwardUserType_value)
	proto.RegisterEnum("arenaServer.service.v1.Areantype", Areantype_name, Areantype_value)
	proto.RegisterEnum("arenaServer.service.v1.TimeType", TimeType_name, TimeType_value)
	proto.RegisterEnum("arenaServer.service.v1.FWaitMatchStatus", FWaitMatchStatus_name, FWaitMatchStatus_value)
	proto.RegisterEnum("arenaServer.service.v1.GameStatus", GameStatus_name, GameStatus_value)
	proto.RegisterEnum("arenaServer.service.v1.HallMsgCode", HallMsgCode_name, HallMsgCode_value)
	proto.RegisterType((*HttpCommonRsp)(nil), "arenaServer.service.v1.HttpCommonRsp")
	proto.RegisterType((*GAward)(nil), "arenaServer.service.v1.GAward")
	proto.RegisterType((*GRank)(nil), "arenaServer.service.v1.GRank")
	proto.RegisterType((*GDailyTaskReq)(nil), "arenaServer.service.v1.GDailyTaskReq")
	proto.RegisterType((*GDailyTaskRsp)(nil), "arenaServer.service.v1.GDailyTaskRsp")
	proto.RegisterType((*GRankListReq)(nil), "arenaServer.service.v1.GRankListReq")
	proto.RegisterType((*GRankListRsp)(nil), "arenaServer.service.v1.GRankListRsp")
	proto.RegisterType((*GWeekRecordReq)(nil), "arenaServer.service.v1.GWeekRecordReq")
	proto.RegisterType((*WeekRecord)(nil), "arenaServer.service.v1.WeekRecord")
	proto.RegisterType((*GWeekRecordRsp)(nil), "arenaServer.service.v1.GWeekRecordRsp")
	proto.RegisterType((*GConditions)(nil), "arenaServer.service.v1.GConditions")
	proto.RegisterType((*GMatchDetailsReq)(nil), "arenaServer.service.v1.GMatchDetailsReq")
	proto.RegisterType((*GMatchDetailsRsp)(nil), "arenaServer.service.v1.GMatchDetailsRsp")
	proto.RegisterType((*GSignUpReq)(nil), "arenaServer.service.v1.GSignUpReq")
	proto.RegisterType((*GSignUpRsp)(nil), "arenaServer.service.v1.GSignUpRsp")
	proto.RegisterType((*GFamousListReq)(nil), "arenaServer.service.v1.GFamousListReq")
	proto.RegisterType((*Famous)(nil), "arenaServer.service.v1.Famous")
	proto.RegisterType((*GFamousListRsp)(nil), "arenaServer.service.v1.GFamousListRsp")
	proto.RegisterType((*MatchStatusReq)(nil), "arenaServer.service.v1.MatchStatusReq")
	proto.RegisterType((*MatchTips)(nil), "arenaServer.service.v1.MatchTips")
	proto.RegisterType((*MatchStatusRsp)(nil), "arenaServer.service.v1.MatchStatusRsp")
	proto.RegisterType((*ShareStatusReq)(nil), "arenaServer.service.v1.ShareStatusReq")
	proto.RegisterType((*ShareStatusRsp)(nil), "arenaServer.service.v1.ShareStatusRsp")
	proto.RegisterType((*AwardListReq)(nil), "arenaServer.service.v1.AwardListReq")
	proto.RegisterType((*GAwardListReq)(nil), "arenaServer.service.v1.GAwardListReq")
	proto.RegisterType((*GAwardInfo)(nil), "arenaServer.service.v1.GAwardInfo")
	proto.RegisterType((*GAwardListRsp)(nil), "arenaServer.service.v1.GAwardListRsp")
	proto.RegisterType((*GGetAwardReq)(nil), "arenaServer.service.v1.GGetAwardReq")
	proto.RegisterType((*AwardRsp)(nil), "arenaServer.service.v1.AwardRsp")
	proto.RegisterType((*GGetAwardRsp)(nil), "arenaServer.service.v1.GGetAwardRsp")
	proto.RegisterType((*AwardInfo)(nil), "arenaServer.service.v1.AwardInfo")
	proto.RegisterType((*AwardListRsp)(nil), "arenaServer.service.v1.AwardListRsp")
	proto.RegisterType((*GetAwardData)(nil), "arenaServer.service.v1.GetAwardData")
	proto.RegisterType((*GetAwardReq)(nil), "arenaServer.service.v1.GetAwardReq")
	proto.RegisterType((*GetAwardRsp)(nil), "arenaServer.service.v1.GetAwardRsp")
	proto.RegisterType((*AwardCountReq)(nil), "arenaServer.service.v1.AwardCountReq")
	proto.RegisterType((*AwardCountRsp)(nil), "arenaServer.service.v1.AwardCountRsp")
	proto.RegisterType((*Condition)(nil), "arenaServer.service.v1.Condition")
	proto.RegisterType((*RankListReq)(nil), "arenaServer.service.v1.RankListReq")
	proto.RegisterType((*RankListInfo)(nil), "arenaServer.service.v1.RankListInfo")
	proto.RegisterType((*RankListRsp)(nil), "arenaServer.service.v1.RankListRsp")
	proto.RegisterType((*PMatchInfo)(nil), "arenaServer.service.v1.PMatchInfo")
	proto.RegisterType((*PMatchListReq)(nil), "arenaServer.service.v1.PMatchListReq")
	proto.RegisterType((*PMatchListRsp)(nil), "arenaServer.service.v1.PMatchListRsp")
	proto.RegisterType((*PSignUpReq)(nil), "arenaServer.service.v1.PSignUpReq")
	proto.RegisterType((*PSignUpRsp)(nil), "arenaServer.service.v1.PSignUpRsp")
	proto.RegisterType((*FMatchInfo)(nil), "arenaServer.service.v1.FMatchInfo")
	proto.RegisterType((*FMatchListReq)(nil), "arenaServer.service.v1.FMatchListReq")
	proto.RegisterType((*FMatchListRsp)(nil), "arenaServer.service.v1.FMatchListRsp")
	proto.RegisterType((*PositionInfo)(nil), "arenaServer.service.v1.PositionInfo")
	proto.RegisterType((*FSignUpReq)(nil), "arenaServer.service.v1.FSignUpReq")
	proto.RegisterType((*FSignUpRsp)(nil), "arenaServer.service.v1.FSignUpRsp")
	proto.RegisterType((*FWaitMatchReq)(nil), "arenaServer.service.v1.FWaitMatchReq")
	proto.RegisterType((*FWaitMatchRsp)(nil), "arenaServer.service.v1.FWaitMatchRsp")
	proto.RegisterType((*FCancelMatchReq)(nil), "arenaServer.service.v1.FCancelMatchReq")
	proto.RegisterType((*FCancelMatchRsp)(nil), "arenaServer.service.v1.FCancelMatchRsp")
	proto.RegisterType((*FConfirmReq)(nil), "arenaServer.service.v1.FConfirmReq")
	proto.RegisterType((*FConfirmRsp)(nil), "arenaServer.service.v1.FConfirmRsp")
	proto.RegisterType((*FRobotLoginReq)(nil), "arenaServer.service.v1.FRobotLoginReq")
	proto.RegisterType((*FRobotLoginRsp)(nil), "arenaServer.service.v1.FRobotLoginRsp")
	proto.RegisterType((*FRobotJoinMatchRsp)(nil), "arenaServer.service.v1.FRobotJoinMatchRsp")
	proto.RegisterType((*FRobotHeartReq)(nil), "arenaServer.service.v1.FRobotHeartReq")
	proto.RegisterType((*FRobotHeartRsp)(nil), "arenaServer.service.v1.FRobotHeartRsp")
	proto.RegisterType((*Message)(nil), "arenaServer.service.v1.Message")
	proto.RegisterType((*ReportStatusReq)(nil), "arenaServer.service.v1.ReportStatusReq")
	proto.RegisterType((*GameCountDown)(nil), "arenaServer.service.v1.GameCountDown")
	proto.RegisterType((*GReportMatchReq)(nil), "arenaServer.service.v1.GReportMatchReq")
	proto.RegisterType((*GReportMatch)(nil), "arenaServer.service.v1.GReportMatch")
	proto.RegisterType((*GReportMatchRsp)(nil), "arenaServer.service.v1.GReportMatchRsp")
	proto.RegisterType((*GGameEnd)(nil), "arenaServer.service.v1.GGameEnd")
	proto.RegisterType((*GGameCountDown)(nil), "arenaServer.service.v1.GGameCountDown")
	proto.RegisterType((*GameSettlement)(nil), "arenaServer.service.v1.GameSettlement")
	proto.RegisterType((*UpdateKeyValue)(nil), "arenaServer.service.v1.UpdateKeyValue")
	proto.RegisterType((*PReportMatchReq)(nil), "arenaServer.service.v1.PReportMatchReq")
	proto.RegisterType((*PReportMatch)(nil), "arenaServer.service.v1.PReportMatch")
	proto.RegisterType((*PReportMatchRsp)(nil), "arenaServer.service.v1.PReportMatchRsp")
	proto.RegisterType((*PGameEnd)(nil), "arenaServer.service.v1.PGameEnd")
	proto.RegisterType((*FReportMatchReq)(nil), "arenaServer.service.v1.FReportMatchReq")
	proto.RegisterType((*FReportMatch)(nil), "arenaServer.service.v1.FReportMatch")
	proto.RegisterType((*FReportMatchRsp)(nil), "arenaServer.service.v1.FReportMatchRsp")
	proto.RegisterType((*FSettlementNotice)(nil), "arenaServer.service.v1.FSettlementNotice")
	proto.RegisterType((*FPlayerResult)(nil), "arenaServer.service.v1.FPlayerResult")
	proto.RegisterType((*FGameEnd)(nil), "arenaServer.service.v1.FGameEnd")
	proto.RegisterType((*FRobotNameSynReq)(nil), "arenaServer.service.v1.FRobotNameSynReq")
	proto.RegisterType((*FRobotNameSynRsp)(nil), "arenaServer.service.v1.FRobotNameSynRsp")
	proto.RegisterType((*Chat)(nil), "arenaServer.service.v1.Chat")
	proto.RegisterType((*AbyGameInfo)(nil), "arenaServer.service.v1.AbyGameInfo")
	proto.RegisterType((*RewardFish)(nil), "arenaServer.service.v1.RewardFish")
	proto.RegisterType((*RewardTaskGetReq)(nil), "arenaServer.service.v1.RewardTaskGetReq")
	proto.RegisterType((*RewardTaskGetRsp)(nil), "arenaServer.service.v1.RewardTaskGetRsp")
	proto.RegisterType((*RewardTaskUpdateReq)(nil), "arenaServer.service.v1.RewardTaskUpdateReq")
	proto.RegisterType((*ReportStatusReqV2)(nil), "arenaServer.service.v1.ReportStatusReqV2")
	proto.RegisterType((*CommonResp)(nil), "arenaServer.service.v1.CommonResp")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 4646 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x3c, 0x4d, 0x6f, 0x1c, 0x47,
	0x76, 0xea, 0xf9, 0x9e, 0x37, 0xfc, 0x68, 0xb5, 0x64, 0x79, 0x34, 0x2b, 0x73, 0xe4, 0x5a, 0x6b,
	0xc1, 0xd0, 0x5e, 0x29, 0x96, 0x6c, 0xef, 0xca, 0x1b, 0x6c, 0x4c, 0x0e, 0x39, 0x23, 0xda, 0xa2,
	0x44, 0xd7, 0x50, 0x36, 0x92, 0x00, 0x99, 0xb4, 0x38, 0x45, 0xb2, 0xa1, 0x61, 0xf7, 0xb8, 0xbb,
	0x47, 0x6b, 0x1a, 0x58, 0x24, 0xb6, 0x03, 0x18, 0x58, 0x2c, 0x10, 0xe4, 0xcb, 0xd9, 0xcd, 0x26,
	0x59, 0x20, 0xc9, 0x29, 0x97, 0x04, 0x01, 0x12, 0x04, 0xc8, 0xe6, 0x14, 0x20, 0x58, 0x20, 0x97,
	0x05, 0xf6, 0x90, 0x1b, 0x91, 0x75, 0x92, 0x0b, 0x0f, 0x39, 0xe4, 0x17, 0x04, 0xaf, 0xbe, 0x67,
	0xc8, 0x19, 0x92, 0x12, 0xe5, 0x4b, 0xb3, 0xea, 0xf5, 0xab, 0xaa, 0xf7, 0x5d, 0xaf, 0x5e, 0xd7,
	0x10, 0xca, 0x7e, 0x3f, 0xb8, 0xde, 0x8f, 0xa3, 0x34, 0xf2, 0x2e, 0xf9, 0x31, 0x0b, 0xfd, 0x36,
	0x8b, 0x1f, 0xb3, 0xf8, 0x7a, 0xc2, 0xe2, 0xc7, 0xc1, 0x26, 0xbb, 0xfe, 0xf8, 0xd5, 0xda, 0xd7,
	0xb7, 0x83, 0x74, 0x67, 0xf0, 0xf0, 0xfa, 0x66, 0xb4, 0x7b, 0x63, 0x3b, 0xda, 0x8e, 0x6e, 0x70,
	0xf4, 0x87, 0x83, 0x2d, 0xde, 0xe3, 0x1d, 0xde, 0x12, 0xd3, 0xd4, 0xae, 0x6c, 0x47, 0xd1, 0x76,
	0x8f, 0xdd, 0xf0, 0xfb, 0xc1, 0x0d, 0x3f, 0x0c, 0xa3, 0xd4, 0x4f, 0x83, 0x28, 0x4c, 0xc4, 0x5b,
	0x72, 0x0b, 0xa6, 0xef, 0xa4, 0x69, 0xbf, 0x11, 0xed, 0xee, 0x46, 0x21, 0x4d, 0xfa, 0xde, 0x0c,
	0x64, 0x56, 0xc2, 0xaa, 0x73, 0xd5, 0x99, 0xcf, 0xd3, 0xcc, 0x4a, 0xe8, 0x79, 0x90, 0x5b, 0xf6,
	0x53, 0xbf, 0x9a, 0xb9, 0xea, 0xcc, 0x4f, 0x51, 0xde, 0x26, 0xdf, 0x82, 0x42, 0x6b, 0xf1, 0x3b,
	0x7e, 0xdc, 0xf5, 0x2e, 0x41, 0x66, 0xb5, 0x2b, 0xb0, 0x97, 0x0a, 0x07, 0xfb, 0xf5, 0xcc, 0x6a,
	0x97, 0x66, 0x56, 0xbb, 0xde, 0x65, 0xc8, 0xde, 0x1b, 0xec, 0xf2, 0x41, 0xd9, 0xa5, 0xe2, 0xc1,
	0x7e, 0x1d, 0xbb, 0x14, 0x1f, 0xe4, 0xe7, 0x19, 0xc8, 0xb7, 0xa8, 0x1f, 0x3e, 0xf2, 0xae, 0x40,
	0x0e, 0xff, 0xca, 0xe1, 0xa5, 0x83, 0xfd, 0x3a, 0xef, 0x53, 0xfe, 0xf4, 0xe6, 0xa1, 0xb4, 0xde,
	0xf3, 0xf7, 0x58, 0xbc, 0xda, 0x95, 0xf3, 0x4c, 0x1d, 0xec, 0xd7, 0x35, 0x8c, 0xea, 0x16, 0xce,
	0xb3, 0xe6, 0xc7, 0x8f, 0xaa, 0x59, 0x8e, 0xc5, 0xe7, 0xc1, 0x3e, 0xe5, 0x4f, 0xef, 0x65, 0x28,
	0xe3, 0x7c, 0xed, 0xd4, 0x8f, 0xd3, 0x6a, 0x8e, 0x2f, 0x35, 0x7d, 0xb0, 0x5f, 0x37, 0x40, 0x6a,
	0x9a, 0xde, 0x35, 0x28, 0x62, 0x67, 0x25, 0xec, 0x56, 0xf3, 0x1c, 0xb5, 0x72, 0xb0, 0x5f, 0x57,
	0x20, 0xaa, 0x1a, 0x48, 0xdb, 0xbd, 0x60, 0xf3, 0xd1, 0x3d, 0x7f, 0x97, 0x55, 0x0b, 0x57, 0x9d,
	0xf9, 0xb2, 0xa0, 0x4d, 0xc1, 0xa8, 0x6e, 0x79, 0x04, 0x0a, 0x8b, 0x8f, 0xfd, 0xd4, 0x8f, 0xab,
	0x45, 0x8e, 0x07, 0x07, 0xfb, 0x75, 0x09, 0xa1, 0xf2, 0xaf, 0xb7, 0x04, 0x05, 0x2e, 0xcd, 0xa4,
	0x5a, 0xba, 0xea, 0xcc, 0x57, 0x6e, 0xce, 0x5d, 0x3f, 0x5a, 0xf3, 0xd7, 0x85, 0xd0, 0xe5, 0x1c,
	0x7c, 0x04, 0x95, 0x7f, 0xc9, 0x6f, 0xc1, 0x74, 0x6b, 0xd9, 0x0f, 0x7a, 0x7b, 0x1b, 0x7e, 0xf2,
	0x88, 0xb2, 0x0f, 0x90, 0x93, 0x35, 0x3f, 0xdd, 0xdc, 0xd1, 0xea, 0xe1, 0x9c, 0x48, 0x10, 0x55,
	0x8d, 0x93, 0x4b, 0x99, 0xfc, 0x51, 0x66, 0x68, 0x89, 0xa4, 0x8f, 0x72, 0x6f, 0x44, 0x5d, 0x66,
	0xeb, 0x0f, 0xfb, 0x94, 0x3f, 0x39, 0x01, 0x2c, 0x49, 0xfc, 0x6d, 0xc6, 0x27, 0x2e, 0x4b, 0x02,
	0x04, 0x88, 0xaa, 0x86, 0xf7, 0x2a, 0x54, 0x36, 0xfc, 0x78, 0x9b, 0xa5, 0xed, 0xcd, 0x28, 0x66,
	0x5c, 0x87, 0xf9, 0xa5, 0xd9, 0x83, 0xfd, 0xba, 0x0d, 0xa6, 0x76, 0x07, 0x35, 0xca, 0xb9, 0xde,
	0xd8, 0xeb, 0x33, 0x5b, 0xa3, 0x1a, 0x48, 0x4d, 0x13, 0x19, 0xe4, 0x1d, 0x34, 0x47, 0xa1, 0x52,
	0xce, 0xa0, 0x82, 0x51, 0xdd, 0xf2, 0x5e, 0x83, 0xa9, 0x66, 0x10, 0x06, 0xc9, 0x4e, 0x3b, 0xf5,
	0xd3, 0x41, 0xc2, 0x15, 0x9b, 0x5f, 0x72, 0x0f, 0xf6, 0xeb, 0x43, 0x70, 0x3a, 0xd4, 0x23, 0xdf,
	0x85, 0x29, 0x6e, 0xcd, 0x77, 0x83, 0x24, 0x7d, 0x16, 0x72, 0x47, 0x29, 0x73, 0x46, 0xb3, 0x46,
	0xca, 0x9c, 0x47, 0xfe, 0x24, 0xff, 0x9e, 0xb1, 0xd7, 0x3f, 0x2b, 0xa5, 0x4c, 0x5c, 0x13, 0x69,
	0x6f, 0xb3, 0xde, 0x16, 0xf7, 0xdd, 0x9c, 0x11, 0xa9, 0x82, 0x51, 0xdd, 0x42, 0xcc, 0x66, 0x1c,
	0x24, 0xe9, 0xb2, 0xbf, 0xc7, 0x85, 0x2f, 0xfd, 0x44, 0xc1, 0xa8, 0x6e, 0x21, 0x61, 0x77, 0x7d,
	0x81, 0x58, 0x30, 0x84, 0x49, 0x10, 0x55, 0x0d, 0x74, 0xa7, 0xc6, 0x20, 0x46, 0x2c, 0xcb, 0x9d,
	0x04, 0x84, 0xca, 0xbf, 0xde, 0x6d, 0x28, 0xe1, 0xe2, 0xbd, 0x20, 0x49, 0xab, 0xa5, 0xab, 0xd9,
	0xf9, 0xca, 0xcd, 0x17, 0xc6, 0x3a, 0x94, 0xa0, 0x57, 0xa1, 0x13, 0x1f, 0x66, 0x5a, 0xef, 0x33,
	0xf6, 0x88, 0xb2, 0xcd, 0x28, 0xee, 0x3e, 0x13, 0x37, 0x1a, 0x00, 0x98, 0x15, 0x70, 0x7a, 0xec,
	0xdd, 0x0f, 0x99, 0x3d, 0xbd, 0x04, 0x51, 0xd5, 0xd0, 0x11, 0x2e, 0x73, 0x64, 0x84, 0x23, 0x50,
	0x90, 0x26, 0x2b, 0xf4, 0xc5, 0x85, 0x22, 0x8d, 0x55, 0xfe, 0x25, 0x9f, 0x67, 0x86, 0x59, 0x3b,
	0x2b, 0x4b, 0xb1, 0x18, 0xc8, 0x4e, 0x60, 0x60, 0x1e, 0x4a, 0x7c, 0xf1, 0x11, 0x93, 0x51, 0x30,
	0xaa, 0x5b, 0x0a, 0x93, 0xb3, 0x9b, 0x37, 0x92, 0x54, 0x30, 0xaa, 0x5b, 0xde, 0x32, 0x54, 0x0c,
	0x43, 0xe8, 0xae, 0xa8, 0x6a, 0x32, 0x4e, 0xd5, 0x16, 0xef, 0xf6, 0x30, 0xf2, 0x16, 0x54, 0x5a,
	0x8d, 0x28, 0xec, 0x06, 0x7c, 0x57, 0x7c, 0x92, 0x0d, 0xed, 0x57, 0xc0, 0x6d, 0x71, 0x3b, 0x58,
	0x66, 0xa9, 0x1f, 0xf4, 0x12, 0x34, 0x1b, 0xdb, 0x1e, 0x9c, 0x89, 0xf6, 0xf0, 0x1f, 0xb9, 0xd1,
	0xe1, 0x67, 0xa8, 0x1a, 0x65, 0xba, 0xd9, 0x09, 0xa6, 0xfb, 0x32, 0x94, 0xf9, 0xde, 0xb7, 0x11,
	0xec, 0x8a, 0x68, 0x5a, 0x16, 0xd1, 0x54, 0x03, 0xa9, 0x69, 0xe2, 0x9c, 0x2b, 0x61, 0x97, 0xa3,
	0xe6, 0xcd, 0xd2, 0x12, 0x44, 0x55, 0x63, 0x48, 0x89, 0x85, 0x89, 0x4a, 0xbc, 0x06, 0xc5, 0x65,
	0x7f, 0x8f, 0x23, 0x16, 0x39, 0x22, 0x9f, 0x50, 0x82, 0xa8, 0x6a, 0xe8, 0x54, 0xa1, 0x74, 0x64,
	0xaa, 0xf0, 0x32, 0x94, 0x37, 0xa2, 0xd4, 0xef, 0x71, 0x94, 0xb2, 0xd9, 0x10, 0x34, 0x90, 0x9a,
	0xa6, 0xb7, 0x08, 0x65, 0xad, 0xef, 0x2a, 0x70, 0xa3, 0xf9, 0xea, 0xd8, 0xf8, 0x60, 0x2c, 0x83,
	0x9a, 0x51, 0xde, 0x22, 0xaa, 0x27, 0x49, 0xab, 0x15, 0xbe, 0x5d, 0x9f, 0x64, 0xb4, 0xd2, 0x61,
	0x92, 0x52, 0xfe, 0xf4, 0xae, 0x03, 0x2c, 0x76, 0xc5, 0x4b, 0xbf, 0x57, 0x9d, 0xe2, 0x34, 0xcf,
	0x1c, 0xec, 0xd7, 0x2d, 0x28, 0xb5, 0xda, 0xb8, 0x4d, 0x72, 0x85, 0x49, 0x47, 0x9f, 0x36, 0xdb,
	0xa4, 0x05, 0xa6, 0x76, 0x87, 0xfc, 0xd0, 0x01, 0x68, 0xb5, 0x83, 0xed, 0xf0, 0x41, 0xff, 0x59,
	0x6d, 0x4c, 0x3c, 0x01, 0xca, 0x72, 0x43, 0xe0, 0x0c, 0xf2, 0xe4, 0x87, 0x3f, 0xf1, 0xed, 0xea,
	0x66, 0x14, 0x4a, 0x8b, 0xe2, 0x6f, 0xb1, 0x4f, 0xf9, 0x93, 0xfc, 0x7d, 0xc6, 0xd0, 0x76, 0x56,
	0xf6, 0x6e, 0x53, 0x9e, 0x35, 0x31, 0xe6, 0x08, 0xca, 0x2d, 0x51, 0xe4, 0x26, 0x88, 0xe2, 0x1a,
	0x14, 0x5b, 0xfe, 0x2e, 0x7b, 0x10, 0xf7, 0x6c, 0x63, 0x97, 0x20, 0xaa, 0x1a, 0x3c, 0xc3, 0x40,
	0x03, 0x40, 0x3c, 0x2b, 0x19, 0x54, 0x30, 0xaa, 0x5b, 0x56, 0xa0, 0x2e, 0x8e, 0x0b, 0xd4, 0x18,
	0x68, 0xd6, 0x92, 0x6d, 0x6e, 0xe8, 0x65, 0x11, 0x68, 0xd6, 0x92, 0x6d, 0x8a, 0x0f, 0x72, 0x0b,
	0x66, 0x5a, 0x4d, 0x7f, 0x37, 0x1a, 0x24, 0x2a, 0xd9, 0x78, 0x71, 0x54, 0xa7, 0x7a, 0x80, 0x82,
	0x93, 0xbf, 0x73, 0xa0, 0x20, 0x06, 0xa1, 0x94, 0xbb, 0x7e, 0x2a, 0xa4, 0x2c, 0x55, 0x82, 0x7d,
	0xca, 0x9f, 0x56, 0xa6, 0x9a, 0x19, 0x9b, 0xa9, 0x1e, 0xab, 0x72, 0xee, 0xc8, 0xb9, 0x23, 0x77,
	0x29, 0x5b, 0x3d, 0xf9, 0x89, 0x21, 0xf1, 0x8f, 0x9d, 0x61, 0x46, 0xcf, 0xca, 0x40, 0xbe, 0x0d,
	0x60, 0x66, 0xad, 0x66, 0xb9, 0xeb, 0x8f, 0xcd, 0xb5, 0x05, 0x26, 0xb5, 0x46, 0x90, 0x37, 0x61,
	0xc6, 0x76, 0xb6, 0x23, 0xc2, 0xfc, 0x58, 0x93, 0x23, 0xef, 0x43, 0x99, 0x8f, 0xdd, 0x08, 0xfa,
	0x89, 0x57, 0x83, 0x12, 0x1a, 0x0f, 0x4f, 0xb1, 0xc4, 0x49, 0x4b, 0xf7, 0xf1, 0xbc, 0xc5, 0xe1,
	0x19, 0x0e, 0x17, 0x09, 0x57, 0x0d, 0x4a, 0xf8, 0x17, 0xc7, 0x0a, 0xd1, 0x53, 0xdd, 0x27, 0xdf,
	0x77, 0x86, 0xa9, 0x3a, 0x2b, 0x61, 0xbd, 0x0e, 0x39, 0xb9, 0x1e, 0x8a, 0xe9, 0xc5, 0x71, 0x62,
	0xd2, 0x4c, 0x51, 0x8e, 0x4e, 0x76, 0x60, 0xa6, 0xbd, 0xe3, 0xc7, 0xcc, 0xc8, 0xa8, 0x36, 0x2a,
	0x23, 0xcb, 0x11, 0x8f, 0x62, 0x76, 0x86, 0xef, 0xc0, 0x59, 0x71, 0x00, 0x5d, 0xc5, 0x23, 0xa6,
	0x72, 0x1a, 0xb4, 0xab, 0x92, 0xce, 0x68, 0xba, 0xc3, 0x2b, 0x25, 0xfd, 0xa7, 0x5e, 0xc9, 0x43,
	0xb9, 0xc5, 0xf2, 0x48, 0x41, 0x79, 0x9b, 0x2c, 0xc0, 0x14, 0x3f, 0x20, 0x28, 0x8f, 0x9b, 0xb0,
	0x06, 0xb9, 0x0d, 0xd3, 0xad, 0x21, 0xe4, 0x93, 0x9b, 0xc7, 0x5f, 0x63, 0xac, 0xe6, 0x63, 0x57,
	0xc3, 0xad, 0xc8, 0xca, 0x42, 0xca, 0x43, 0x59, 0xc8, 0xbc, 0x65, 0x08, 0x19, 0x13, 0x6a, 0x14,
	0xcc, 0x98, 0x85, 0xf7, 0x86, 0x3e, 0x53, 0x1e, 0x63, 0xe7, 0x62, 0x55, 0x75, 0x8e, 0x44, 0xdb,
	0x59, 0xc6, 0x18, 0x61, 0x85, 0xed, 0x65, 0x1e, 0x23, 0xf0, 0x49, 0x3e, 0x77, 0x86, 0x58, 0x3c,
	0x2b, 0x5b, 0x7b, 0x4b, 0x1e, 0xe8, 0x2c, 0xbf, 0x24, 0x93, 0xe9, 0x45, 0x29, 0x51, 0x33, 0x88,
	0xbc, 0x0d, 0x53, 0xad, 0x16, 0x4b, 0x05, 0x2f, 0xa7, 0x91, 0xbc, 0xe7, 0x42, 0x76, 0xb5, 0x8b,
	0xd2, 0xcc, 0xce, 0x97, 0x29, 0x36, 0xc9, 0xaa, 0x3c, 0x31, 0x22, 0x7b, 0x97, 0xc5, 0x5b, 0xc7,
	0x44, 0xe3, 0xd5, 0x6e, 0xc2, 0xd1, 0xac, 0x60, 0x9e, 0x19, 0x9b, 0x75, 0xff, 0x8b, 0x63, 0xd3,
	0xf5, 0xe5, 0x6f, 0x74, 0xdf, 0x96, 0x82, 0xa5, 0x49, 0x1f, 0xdd, 0x07, 0x05, 0x7b, 0x75, 0x9c,
	0x60, 0x15, 0x22, 0x35, 0x43, 0xc8, 0xef, 0x39, 0x72, 0x02, 0x6e, 0x95, 0xca, 0x87, 0x9c, 0x31,
	0xa1, 0x29, 0x33, 0x1c, 0x9a, 0x0e, 0xf9, 0x57, 0x15, 0x8a, 0x6b, 0x51, 0xc8, 0xf6, 0xd4, 0xb6,
	0x4b, 0x55, 0xd7, 0xbb, 0x08, 0x79, 0xde, 0x14, 0x1b, 0x03, 0x15, 0x1d, 0x59, 0x7a, 0x92, 0x15,
	0x16, 0x69, 0x81, 0xf7, 0x6d, 0x7f, 0x4c, 0xfa, 0xde, 0xaf, 0xda, 0xa6, 0xe3, 0x4c, 0x8e, 0x55,
	0x47, 0x5a, 0xce, 0xf7, 0x51, 0x45, 0x52, 0x43, 0xcb, 0x7e, 0xea, 0x1f, 0xc9, 0xa5, 0xe0, 0x24,
	0x63, 0x47, 0x0a, 0x4e, 0x59, 0xd6, 0x50, 0x76, 0x6a, 0xee, 0x2e, 0x42, 0x7e, 0x7d, 0x27, 0x0a,
	0x15, 0x7b, 0xa2, 0x43, 0x76, 0xa1, 0x62, 0xdb, 0xf1, 0xa4, 0x90, 0xb6, 0x64, 0xb3, 0x9e, 0xe1,
	0xac, 0xbf, 0x34, 0xd6, 0x6b, 0x2c, 0x0e, 0x6d, 0xee, 0x3f, 0x76, 0xac, 0xf5, 0x8e, 0x09, 0xa1,
	0x67, 0xb0, 0x9e, 0x08, 0xb1, 0x5d, 0x2b, 0xc4, 0x76, 0x19, 0x86, 0x4d, 0x8e, 0xd0, 0x88, 0x06,
	0xe1, 0x29, 0xc3, 0xe6, 0x8f, 0x9d, 0xa1, 0xb1, 0x5f, 0xbe, 0x83, 0xd5, 0x21, 0xcf, 0x97, 0x96,
	0x79, 0x64, 0xf9, 0x60, 0xbf, 0x2e, 0x00, 0x54, 0xfc, 0x21, 0xaf, 0x5b, 0xa7, 0x8d, 0x23, 0x4d,
	0xeb, 0x22, 0xe4, 0xdf, 0xf3, 0x7b, 0x03, 0xb5, 0x33, 0x89, 0x0e, 0xf9, 0x0d, 0xa8, 0xd8, 0x45,
	0xa5, 0x63, 0x76, 0xb6, 0xd4, 0xda, 0xd9, 0xb0, 0xed, 0x5d, 0x81, 0xf2, 0x62, 0xcc, 0xfc, 0x30,
	0xd5, 0x45, 0x1c, 0x6a, 0x00, 0xe4, 0x77, 0x32, 0x30, 0xa5, 0x66, 0xe7, 0x8e, 0x7d, 0x45, 0x1e,
	0x01, 0x4d, 0x35, 0x96, 0x1a, 0x00, 0x1a, 0xf6, 0x4a, 0xd8, 0xe5, 0xef, 0xc4, 0x1a, 0xaa, 0x8b,
	0x64, 0x3d, 0x48, 0x58, 0x6c, 0x4a, 0x45, 0x54, 0xf7, 0x91, 0x2c, 0x9e, 0x2a, 0xe6, 0x84, 0x8b,
	0xf0, 0x04, 0xd1, 0x93, 0x67, 0x82, 0xbc, 0x80, 0x61, 0x1b, 0x61, 0xfa, 0x98, 0x98, 0x97, 0xa9,
	0x62, 0x15, 0x8a, 0xc2, 0x57, 0xbb, 0x22, 0x51, 0xa6, 0xaa, 0x8b, 0xd2, 0xe2, 0x4d, 0x9e, 0x1f,
	0x67, 0xa9, 0xe8, 0x20, 0x1d, 0x6b, 0x83, 0x5e, 0x1a, 0xf4, 0x7b, 0x4c, 0x1c, 0xff, 0xa8, 0xee,
	0xe3, 0x08, 0x64, 0x25, 0xa9, 0x02, 0xcf, 0x1e, 0x44, 0x87, 0xfc, 0xc2, 0xb1, 0x04, 0x9c, 0xf4,
	0x8f, 0xd4, 0x4c, 0x15, 0x8a, 0x32, 0x94, 0xc9, 0xc8, 0xa6, 0xba, 0x93, 0xc5, 0xeb, 0xbd, 0x25,
	0xea, 0x4f, 0xdc, 0x4d, 0x72, 0x93, 0xdd, 0xc4, 0xd6, 0x02, 0xd5, 0xa3, 0x90, 0x1a, 0x2e, 0xee,
	0xbc, 0xa0, 0x46, 0x16, 0xcb, 0xad, 0x33, 0xae, 0x10, 0x96, 0x75, 0xa8, 0x55, 0x52, 0x2c, 0x1a,
	0x29, 0x92, 0x7f, 0xce, 0x02, 0xac, 0x8b, 0x63, 0xc0, 0x59, 0x44, 0xef, 0x2b, 0x50, 0x7e, 0x3b,
	0x0a, 0x42, 0x3c, 0xdf, 0x27, 0xd2, 0x7f, 0x0d, 0xc0, 0x9b, 0x03, 0xe0, 0xd4, 0x88, 0xd7, 0x82,
	0x70, 0x0b, 0xc2, 0xdf, 0x07, 0xbb, 0xcc, 0x2e, 0xad, 0x52, 0x0b, 0x82, 0xd4, 0xdd, 0x89, 0x06,
	0xb1, 0x62, 0x00, 0xdb, 0x98, 0xf9, 0xad, 0x05, 0xe1, 0x20, 0x65, 0xe2, 0xd8, 0x4f, 0x65, 0xcf,
	0xca, 0x08, 0x85, 0xb2, 0xd5, 0xd1, 0xa9, 0x05, 0xd3, 0xda, 0xd7, 0xb8, 0xf4, 0x61, 0xf2, 0x7e,
	0xa0, 0x91, 0xe9, 0xf0, 0x38, 0x2d, 0xff, 0xca, 0x38, 0xf9, 0x4f, 0x8d, 0xca, 0x5f, 0xdb, 0xe5,
	0xf4, 0x38, 0xbb, 0x9c, 0x19, 0xb1, 0xcb, 0x39, 0x00, 0x13, 0xb9, 0xaa, 0xb3, 0x42, 0x20, 0x06,
	0x42, 0x5e, 0x86, 0x69, 0xa1, 0xbc, 0x93, 0x64, 0x9e, 0xef, 0x0e, 0x21, 0x27, 0x7d, 0xcc, 0xa8,
	0x74, 0x5f, 0x6e, 0x8b, 0x63, 0x33, 0x2a, 0x63, 0x23, 0xd4, 0x0c, 0x22, 0x29, 0xc0, 0xba, 0x29,
	0x1e, 0x1c, 0x13, 0x80, 0xb8, 0xa7, 0x67, 0x86, 0x3d, 0xfd, 0x0e, 0xf3, 0xbb, 0x6a, 0x83, 0xc4,
	0xb6, 0x36, 0xc0, 0xdc, 0xa1, 0x8d, 0x35, 0xaf, 0x8c, 0x8c, 0x6c, 0x99, 0x55, 0x9f, 0x20, 0xa1,
	0xbf, 0x08, 0xf9, 0x5d, 0xbe, 0xd1, 0x66, 0x85, 0x16, 0x76, 0x55, 0x1a, 0xb1, 0x69, 0xa5, 0xf5,
	0xd8, 0x26, 0xff, 0x93, 0x01, 0x68, 0x9e, 0x9d, 0x6f, 0xd4, 0xa0, 0x74, 0xbf, 0xcf, 0x42, 0x53,
	0x42, 0xa3, 0xba, 0xef, 0x5d, 0x85, 0x8a, 0x20, 0xda, 0x76, 0x0d, 0x1b, 0x34, 0xec, 0x59, 0x85,
	0xc9, 0x9e, 0x55, 0x3c, 0xe4, 0x59, 0x57, 0xf4, 0xc9, 0x72, 0x57, 0x39, 0x8a, 0x01, 0x1c, 0xf6,
	0x89, 0xf2, 0x13, 0xfa, 0xc4, 0x15, 0x7b, 0xf7, 0x47, 0xc7, 0xca, 0xda, 0xfb, 0xba, 0x71, 0xc9,
	0x8a, 0xed, 0x92, 0x68, 0xc5, 0xcd, 0xd3, 0x58, 0x71, 0xf3, 0x89, 0xad, 0xb8, 0x79, 0xa4, 0x15,
	0xdf, 0x81, 0xa9, 0xf5, 0x28, 0xe1, 0x5c, 0x70, 0x45, 0xd7, 0xa0, 0x74, 0xd7, 0x4f, 0x83, 0x74,
	0x20, 0x53, 0x04, 0x87, 0xea, 0x3e, 0x72, 0x78, 0x37, 0x0a, 0xb7, 0xc5, 0xcb, 0x0c, 0x7f, 0x69,
	0x00, 0xe4, 0xdf, 0x1c, 0x80, 0xe6, 0x97, 0xee, 0x10, 0xbc, 0xdf, 0x97, 0x29, 0x62, 0x66, 0x15,
	0x45, 0x52, 0x52, 0x0c, 0x71, 0x5b, 0x98, 0xb0, 0xb9, 0xd8, 0x8c, 0x53, 0x3d, 0x8a, 0x7c, 0x68,
	0xf8, 0x78, 0x96, 0x2e, 0x86, 0x07, 0x2b, 0x5d, 0x39, 0xa3, 0xd8, 0x24, 0xf7, 0x61, 0xba, 0xf9,
	0xbe, 0x1f, 0xa4, 0x5c, 0x3d, 0x28, 0xc4, 0x93, 0xa4, 0xda, 0xb5, 0xd1, 0x5c, 0xcc, 0x32, 0x98,
	0xdf, 0x77, 0x86, 0x66, 0x1c, 0xb3, 0x8f, 0x9f, 0x62, 0xc6, 0x91, 0x62, 0x83, 0xd9, 0x5a, 0x3c,
	0xc8, 0xa1, 0x47, 0xaa, 0x1d, 0x19, 0xdb, 0x28, 0x0a, 0xee, 0x86, 0xd2, 0x65, 0x45, 0x87, 0xbc,
	0x0b, 0xb3, 0xcd, 0x86, 0x1f, 0x6e, 0xb2, 0xde, 0x99, 0xb1, 0x19, 0x8c, 0x4c, 0x79, 0x36, 0x7c,
	0x52, 0x96, 0x0c, 0x7a, 0xa9, 0xe2, 0x53, 0xf4, 0xc8, 0x1a, 0x54, 0x9a, 0x8d, 0x28, 0xdc, 0x0a,
	0xe2, 0xdd, 0xb3, 0xa0, 0x9c, 0x59, 0xd3, 0x3d, 0x43, 0xaa, 0x5f, 0x81, 0x99, 0x26, 0x8d, 0x1e,
	0x46, 0xe9, 0xdd, 0x68, 0x3b, 0x08, 0x8f, 0x0b, 0x33, 0x6f, 0x0d, 0x63, 0x1f, 0xef, 0x04, 0xbc,
	0x28, 0x94, 0xb1, 0x8a, 0x42, 0x29, 0x78, 0x62, 0x06, 0xb4, 0x03, 0xad, 0x93, 0xa7, 0x2d, 0x3f,
	0xcd, 0x01, 0x2c, 0x07, 0x5b, 0x5b, 0xc1, 0xe6, 0xa0, 0x97, 0xee, 0x49, 0x0e, 0x2d, 0x88, 0xe1,
	0xf2, 0x0e, 0xc3, 0xd4, 0xfc, 0xa4, 0x5c, 0x0a, 0xec, 0x27, 0xe0, 0xb2, 0xa3, 0x0f, 0x4b, 0x87,
	0x86, 0x66, 0x87, 0x0b, 0x28, 0xf7, 0xe5, 0x16, 0x99, 0xa7, 0xd8, 0xd4, 0x57, 0x46, 0xb2, 0xe6,
	0xca, 0x08, 0xc2, 0xda, 0xc1, 0x47, 0x3a, 0x42, 0x60, 0x1b, 0x4f, 0x6f, 0xb3, 0x94, 0xf5, 0xa3,
	0x38, 0x35, 0xd5, 0xc2, 0x31, 0x3b, 0xb1, 0x88, 0x6e, 0xea, 0x93, 0x04, 0xd5, 0x7d, 0x4b, 0x88,
	0xd9, 0x43, 0xe6, 0x93, 0x1b, 0xa1, 0xd4, 0x38, 0x77, 0x7e, 0xc8, 0xb9, 0x31, 0xd1, 0xf7, 0x1f,
	0xf6, 0xd8, 0x6a, 0x57, 0x7c, 0xac, 0xa2, 0xaa, 0x4b, 0x3a, 0x30, 0xdd, 0xf2, 0x77, 0x19, 0xcf,
	0xc8, 0x96, 0xa3, 0xef, 0x84, 0xc7, 0x58, 0x70, 0x56, 0x95, 0x39, 0xd4, 0x74, 0xd9, 0xa1, 0xe9,
	0x50, 0x54, 0xed, 0x4d, 0x25, 0x03, 0x6c, 0x92, 0xbf, 0x72, 0x60, 0xb6, 0x25, 0x64, 0xa0, 0xc3,
	0xc5, 0x24, 0x61, 0x4f, 0xb6, 0x23, 0xbd, 0xfe, 0x9a, 0xff, 0xa1, 0xa9, 0xc4, 0x53, 0xd5, 0x45,
	0x01, 0x2c, 0x0d, 0x7a, 0x3d, 0x96, 0x2a, 0x01, 0x88, 0x1e, 0x5a, 0x9e, 0xa0, 0x81, 0xcf, 0x2d,
	0x93, 0x73, 0x03, 0x21, 0x3b, 0x30, 0x65, 0x13, 0x79, 0xd6, 0x14, 0xe6, 0x35, 0x85, 0x64, 0x6d,
	0x44, 0x1c, 0x49, 0xdf, 0x7b, 0x13, 0xf2, 0xb8, 0x83, 0xa9, 0x42, 0xe6, 0xf8, 0x92, 0x83, 0x3d,
	0x4e, 0x0c, 0x21, 0xd7, 0xa1, 0xd4, 0x42, 0x05, 0xae, 0x84, 0xdd, 0x93, 0x04, 0x1f, 0xd2, 0x84,
	0x99, 0xd6, 0xe9, 0x15, 0x7e, 0x58, 0xad, 0xff, 0xeb, 0xc0, 0x0c, 0xce, 0xd3, 0x66, 0x69, 0xda,
	0x63, 0xbb, 0x2c, 0x34, 0x67, 0x0a, 0xc7, 0x3a, 0x53, 0xe8, 0x1d, 0x24, 0x63, 0xed, 0x20, 0x98,
	0x30, 0xbe, 0x17, 0xf4, 0xd5, 0xb7, 0x3f, 0x19, 0x20, 0x6c, 0x90, 0xf7, 0x0a, 0x9c, 0x6f, 0xec,
	0xf8, 0xbd, 0x1e, 0x0b, 0xb7, 0x99, 0xc6, 0x13, 0xcb, 0x1f, 0x7e, 0x81, 0xd2, 0x6e, 0x0c, 0x62,
	0xf3, 0x41, 0x9d, 0xaa, 0xae, 0xad, 0x87, 0xc2, 0xb0, 0xa5, 0x28, 0xb6, 0x8b, 0xc3, 0x6e, 0xa8,
	0xb5, 0x5e, 0x1a, 0xd6, 0x3a, 0xf9, 0x26, 0xcc, 0x3c, 0xe8, 0x77, 0xfd, 0x94, 0xbd, 0xc3, 0xf6,
	0x78, 0x05, 0x03, 0x85, 0xf2, 0x0e, 0xdb, 0x13, 0x95, 0x53, 0x8a, 0xcd, 0xe1, 0x4a, 0x47, 0x59,
	0x55, 0x3a, 0x3e, 0x76, 0x60, 0x76, 0xfd, 0x18, 0x0f, 0x38, 0x6d, 0x24, 0x1d, 0x6b, 0x5f, 0xbc,
	0x1a, 0xc0, 0x33, 0x15, 0xe1, 0x00, 0xa2, 0x43, 0xfe, 0xc6, 0x81, 0xa9, 0xf5, 0x49, 0x06, 0x7e,
	0x76, 0x04, 0xa8, 0xdc, 0x30, 0x7f, 0x44, 0x6e, 0x58, 0xb0, 0x72, 0xc3, 0xaa, 0xb8, 0x88, 0xb6,
	0xda, 0xfd, 0x50, 0x95, 0x40, 0x64, 0x17, 0x5d, 0x64, 0x7d, 0x9c, 0x8b, 0x38, 0x93, 0x5d, 0x64,
	0xfd, 0x68, 0x17, 0x59, 0x3f, 0x8d, 0x8b, 0xfc, 0xab, 0x03, 0xb3, 0xcd, 0xa7, 0xd4, 0x97, 0x1d,
	0xd0, 0xe5, 0x1e, 0xaf, 0x03, 0xba, 0x15, 0x3d, 0xa5, 0xe8, 0x54, 0xf4, 0x54, 0x35, 0x8e, 0xbc,
	0x55, 0x29, 0xd2, 0xfa, 0x2c, 0x58, 0xfa, 0x44, 0x0f, 0xa2, 0x7e, 0x1a, 0x44, 0x8d, 0x1d, 0x3f,
	0xdc, 0x16, 0x46, 0x5c, 0xa2, 0x36, 0x88, 0xfc, 0xcc, 0x81, 0xa9, 0xe6, 0xd3, 0x68, 0x7c, 0x24,
	0xc8, 0x5b, 0x64, 0x8e, 0xd7, 0xbd, 0xa5, 0xd3, 0xfc, 0x90, 0x4e, 0x91, 0x60, 0x11, 0x8a, 0x45,
	0x35, 0x40, 0x30, 0x63, 0x83, 0x0c, 0x86, 0x08, 0x18, 0x45, 0x1b, 0x43, 0x24, 0x9e, 0x6b, 0x23,
	0x7a, 0x39, 0x85, 0x5d, 0x34, 0x8f, 0xb0, 0x8b, 0x77, 0xe1, 0x7c, 0xd3, 0x84, 0xaf, 0x7b, 0x51,
	0x1a, 0x6c, 0xb2, 0x13, 0x25, 0x70, 0x43, 0x92, 0xc9, 0x5a, 0x92, 0x11, 0xe9, 0xba, 0x90, 0xaa,
	0x48, 0xdc, 0x8e, 0x93, 0xba, 0x55, 0x73, 0xcc, 0xa9, 0x32, 0x97, 0xf9, 0xfe, 0x6c, 0xbc, 0xc7,
	0x12, 0xb6, 0x36, 0x0b, 0x51, 0x8e, 0xc9, 0xdb, 0xe5, 0x98, 0xa3, 0xbe, 0x27, 0xfc, 0xc8, 0x81,
	0x52, 0xf3, 0x14, 0xf6, 0x3f, 0x9e, 0x3d, 0xef, 0x5d, 0x70, 0x6d, 0xe6, 0xac, 0xfa, 0xdf, 0xb5,
	0xb1, 0x82, 0xb7, 0x07, 0xd0, 0x43, 0xc3, 0xc9, 0x6f, 0x82, 0x2b, 0x92, 0x38, 0xe4, 0xb4, 0xbd,
	0x17, 0x9e, 0x34, 0x43, 0xb2, 0x1d, 0x6a, 0x52, 0x7e, 0xbe, 0x34, 0x3a, 0xff, 0xf1, 0x69, 0xe2,
	0xe8, 0xc9, 0x96, 0xfc, 0xa5, 0x03, 0xb9, 0xc6, 0x8e, 0x9f, 0x7a, 0x04, 0xa6, 0xda, 0x6c, 0x13,
	0xb7, 0x9c, 0xf7, 0xf9, 0x85, 0x2c, 0x11, 0xfa, 0x87, 0x60, 0x68, 0xc6, 0xcd, 0xa0, 0x97, 0xb2,
	0x58, 0xa0, 0x88, 0x79, 0x6c, 0x10, 0xe6, 0x28, 0xa8, 0x8e, 0xd5, 0x65, 0x49, 0xac, 0xec, 0xe1,
	0xc8, 0x46, 0x14, 0xa6, 0x2c, 0x4c, 0xad, 0x33, 0xb3, 0x0d, 0x42, 0xc2, 0x97, 0x59, 0xcf, 0xdf,
	0x4b, 0xd8, 0xa6, 0xf4, 0x2f, 0xdd, 0x27, 0x9f, 0x39, 0x50, 0x59, 0x7c, 0xb8, 0xc7, 0xe7, 0x92,
	0x75, 0x80, 0xb1, 0x5f, 0xe0, 0x6b, 0x23, 0x37, 0x60, 0x6c, 0x01, 0x5c, 0x54, 0xf5, 0x7e, 0x41,
	0x9c, 0xe8, 0x4c, 0x3a, 0x35, 0xf2, 0xf2, 0x91, 0x0c, 0xf6, 0xfc, 0x03, 0xf9, 0x3f, 0x3a, 0x98,
	0x6c, 0xa1, 0x3d, 0x36, 0x83, 0x64, 0xc7, 0xfb, 0x3a, 0x64, 0x02, 0xf5, 0x95, 0xe3, 0x85, 0x83,
	0xfd, 0x7a, 0x26, 0xe8, 0xfe, 0xdf, 0x7e, 0xfd, 0xc2, 0x63, 0xbf, 0x17, 0xe0, 0x76, 0xfa, 0x26,
	0x89, 0xd9, 0x07, 0x83, 0x20, 0x66, 0x5d, 0x42, 0x33, 0x41, 0xd7, 0xfb, 0x65, 0xc8, 0x86, 0xf2,
	0x1a, 0x5a, 0x7e, 0x69, 0xee, 0x60, 0xbf, 0x8e, 0xdd, 0x71, 0x03, 0xf0, 0x9d, 0xd7, 0x82, 0xca,
	0xa6, 0xdf, 0x4f, 0x07, 0x31, 0xeb, 0xe0, 0x48, 0xf1, 0x39, 0xe3, 0x6b, 0x07, 0xfb, 0x75, 0x1b,
	0x3c, 0x6e, 0x06, 0x90, 0x38, 0xf7, 0x06, 0xbb, 0x64, 0x01, 0x5c, 0x41, 0xf7, 0x86, 0x9f, 0x3c,
	0x6a, 0x31, 0x7e, 0x00, 0xb9, 0x04, 0x85, 0x07, 0x89, 0x65, 0x29, 0xb2, 0x47, 0x7e, 0x92, 0x1d,
	0x45, 0x3e, 0xab, 0x4f, 0x33, 0xdf, 0x82, 0x62, 0xea, 0x27, 0x8f, 0x3a, 0x81, 0xfa, 0x32, 0x43,
	0x10, 0x4d, 0x82, 0xc6, 0xb1, 0x51, 0xc0, 0xf7, 0xab, 0x5d, 0xef, 0x36, 0x14, 0x62, 0x4e, 0x95,
	0xfc, 0x5c, 0xf3, 0xe2, 0xc1, 0x7e, 0x5d, 0x42, 0xc6, 0x0e, 0x15, 0xaf, 0xbd, 0x37, 0x20, 0xbf,
	0xd9, 0x8b, 0x36, 0xd5, 0x9d, 0xc4, 0xab, 0x07, 0xfb, 0x75, 0x01, 0x18, 0x37, 0x50, 0xbc, 0xf5,
	0x9a, 0x50, 0xe1, 0xc4, 0x25, 0xf6, 0x9d, 0xe2, 0x6b, 0x07, 0xfb, 0x75, 0x40, 0xc9, 0x08, 0x3b,
	0x19, 0x2b, 0xfd, 0x54, 0xa3, 0x78, 0x8f, 0xa0, 0x22, 0x28, 0xe9, 0x6c, 0x05, 0xc9, 0x4e, 0xb5,
	0x38, 0xb9, 0x18, 0x66, 0x0c, 0x4c, 0xa8, 0xda, 0x1a, 0x3a, 0x76, 0xb1, 0x58, 0x8f, 0x21, 0xff,
	0x90, 0x85, 0x0b, 0x46, 0x7d, 0x22, 0xb1, 0x43, 0x75, 0xdf, 0x1e, 0x56, 0xb7, 0x90, 0x9f, 0x80,
	0x8c, 0x95, 0x9f, 0x78, 0x6d, 0xeb, 0x2d, 0xf3, 0x14, 0x7a, 0xcb, 0x3e, 0xb1, 0xde, 0x72, 0x4f,
	0xa5, 0xb7, 0xfc, 0x19, 0xe9, 0xad, 0xf0, 0x4c, 0xf5, 0xf6, 0x3d, 0x07, 0xce, 0x8f, 0x1c, 0xa8,
	0xdf, 0xbb, 0xe9, 0xbd, 0x09, 0xc5, 0x41, 0xc2, 0xe2, 0x4e, 0x70, 0x1a, 0xb5, 0x0d, 0x84, 0xda,
	0x6e, 0x43, 0x21, 0xb1, 0x2f, 0x39, 0xbc, 0x68, 0x2e, 0x39, 0x8c, 0x1d, 0x2a, 0x06, 0x90, 0x77,
	0x01, 0xe4, 0xaf, 0x4a, 0xd8, 0x19, 0x39, 0xff, 0xc2, 0x27, 0x45, 0x98, 0xe2, 0x97, 0xe9, 0xd6,
	0x92, 0x6d, 0x3e, 0x6e, 0x16, 0x2a, 0x8b, 0x6b, 0x8d, 0xce, 0x6a, 0xf8, 0xd8, 0xef, 0xad, 0x76,
	0xdd, 0x73, 0xde, 0x73, 0x70, 0x1e, 0x01, 0x8d, 0x8e, 0x75, 0x25, 0xca, 0x75, 0x0c, 0xd8, 0xba,
	0x31, 0xe4, 0x66, 0xbc, 0x0b, 0x30, 0x2b, 0xc0, 0xba, 0x90, 0xed, 0x66, 0x3d, 0x0f, 0x66, 0x04,
	0x50, 0x7d, 0xc3, 0x76, 0x73, 0xde, 0x45, 0x70, 0x2d, 0x44, 0x1e, 0xf4, 0xdd, 0xbc, 0xc1, 0x54,
	0x1f, 0xee, 0xdc, 0x82, 0xc1, 0x34, 0xdf, 0x63, 0xdc, 0x39, 0xef, 0x3c, 0x4c, 0x4b, 0xa8, 0xa8,
	0xbc, 0xba, 0x75, 0x83, 0x68, 0x4a, 0xde, 0xee, 0x4d, 0x0b, 0xaa, 0xcb, 0x9a, 0xee, 0x2d, 0xef,
	0x12, 0x78, 0x12, 0x6a, 0x95, 0x01, 0xdd, 0xd7, 0xcc, 0xb4, 0xb2, 0xa0, 0xeb, 0xbe, 0x6e, 0x68,
	0x52, 0x75, 0x37, 0xf7, 0x0d, 0xc3, 0xbd, 0x55, 0xf6, 0x72, 0xbf, 0xe1, 0x5d, 0x86, 0xe7, 0x6c,
	0xb0, 0xae, 0x65, 0xb9, 0xdf, 0x1c, 0x1d, 0xc1, 0x4b, 0x48, 0xee, 0x6d, 0xef, 0x79, 0xb8, 0x20,
	0x45, 0x63, 0x5f, 0x58, 0x76, 0x9b, 0x86, 0x10, 0x79, 0xa7, 0xd3, 0x6d, 0x19, 0xd9, 0xea, 0x5f,
	0x27, 0xb8, 0x77, 0xcc, 0xbc, 0xd6, 0x55, 0x74, 0x77, 0xd5, 0x70, 0x6d, 0xee, 0x16, 0xb9, 0x6f,
	0x5b, 0xc8, 0xe6, 0x0e, 0x9e, 0xfb, 0x8e, 0x35, 0xb1, 0x56, 0xd0, 0x5d, 0x6b, 0x06, 0xfd, 0x0b,
	0x15, 0x77, 0x4d, 0xd1, 0xdb, 0xee, 0x0c, 0x9d, 0xe9, 0x5d, 0x4c, 0xe2, 0xe4, 0x8b, 0x75, 0xdb,
	0x5d, 0xdc, 0x4f, 0x1c, 0xef, 0x79, 0x21, 0x6a, 0xfd, 0x46, 0x48, 0xe4, 0x53, 0xc7, 0xbb, 0x20,
	0x04, 0xdb, 0xee, 0xa8, 0xd3, 0x92, 0xfb, 0xbb, 0x8e, 0x99, 0xa7, 0x39, 0x34, 0xcf, 0xe7, 0xd6,
	0x3c, 0x76, 0x6e, 0xed, 0xfe, 0x89, 0xe3, 0x5d, 0x12, 0x5c, 0xb5, 0x3b, 0x56, 0x76, 0xed, 0xfe,
	0xc0, 0x9a, 0x5f, 0x65, 0xa3, 0xee, 0x0f, 0xf5, 0xfc, 0x4a, 0x0f, 0x32, 0x4b, 0x73, 0xff, 0xd4,
	0x5a, 0xb9, 0x35, 0xb4, 0xf2, 0x8f, 0xac, 0x95, 0xed, 0x82, 0x88, 0xfb, 0x67, 0xd6, 0x0a, 0xaa,
	0x24, 0xe2, 0xfe, 0xb9, 0xe3, 0xd5, 0x84, 0x11, 0x48, 0xa0, 0x45, 0xd2, 0x5f, 0x38, 0xde, 0x45,
	0x21, 0xe9, 0x76, 0xa7, 0xf5, 0x8e, 0x2f, 0x4e, 0xf5, 0xee, 0x8f, 0x9d, 0x85, 0x7f, 0xca, 0xc1,
	0x79, 0xe5, 0x84, 0x2b, 0x71, 0x1c, 0xc5, 0xdc, 0x13, 0x5d, 0x98, 0x5a, 0x5c, 0x5b, 0xb1, 0x5d,
	0x91, 0xfb, 0xe6, 0x4a, 0xa3, 0xd3, 0x1e, 0x6c, 0xb2, 0x04, 0x9d, 0x70, 0x06, 0x80, 0x03, 0xd6,
	0xfd, 0xd8, 0xdf, 0x75, 0x33, 0x42, 0x3b, 0xd8, 0xe7, 0xc9, 0xd5, 0xbd, 0x28, 0x5d, 0xf9, 0x50,
	0x78, 0x20, 0x37, 0x4c, 0xfb, 0x05, 0x92, 0x16, 0x84, 0xdb, 0x6e, 0xce, 0xab, 0xc1, 0x25, 0xfe,
	0xea, 0x41, 0x98, 0xb0, 0x38, 0xf0, 0x7b, 0xc1, 0x47, 0xac, 0xe9, 0x07, 0x3d, 0xd6, 0x75, 0xf3,
	0xfa, 0xdd, 0x32, 0x1b, 0x7d, 0x57, 0xd0, 0x6b, 0x35, 0x63, 0x96, 0xec, 0x60, 0xe8, 0xe3, 0x77,
	0x70, 0xdc, 0xa2, 0x30, 0x1c, 0xa4, 0x72, 0x2f, 0x49, 0xd9, 0x2e, 0xe7, 0xc7, 0x2d, 0x69, 0x6e,
	0xda, 0x1f, 0xf4, 0x1a, 0x51, 0x18, 0xba, 0x65, 0x4d, 0x3c, 0x3f, 0x1c, 0xb9, 0x20, 0x2c, 0x7e,
	0xa5, 0xd1, 0x79, 0x2f, 0xe8, 0xdf, 0x65, 0x8f, 0x59, 0xcf, 0xad, 0x68, 0x14, 0x31, 0xf5, 0x94,
	0xee, 0xf3, 0x98, 0xe3, 0x4e, 0xeb, 0x21, 0xea, 0xd3, 0x9e, 0x3b, 0x23, 0x1c, 0x7b, 0x45, 0x46,
	0x2b, 0x2d, 0x81, 0x59, 0x61, 0xfa, 0x16, 0xfc, 0x7e, 0x9f, 0x85, 0xae, 0xab, 0xc1, 0xc2, 0xc9,
	0x24, 0x73, 0xe7, 0x47, 0xc0, 0x52, 0xde, 0x9e, 0x66, 0xe2, 0x5e, 0x24, 0xbc, 0xe4, 0x82, 0x70,
	0x9d, 0x95, 0x46, 0xa7, 0x11, 0xf5, 0x7a, 0x22, 0x2b, 0x77, 0x2f, 0x6a, 0x09, 0x70, 0x24, 0x39,
	0xf8, 0x39, 0x8d, 0x7a, 0x2f, 0x4a, 0x31, 0x12, 0xa1, 0xf4, 0x2f, 0x69, 0x0e, 0xee, 0x45, 0x29,
	0x3f, 0xf4, 0xb8, 0xcf, 0xeb, 0xb5, 0x79, 0x9f, 0xdf, 0x19, 0x61, 0x5d, 0xb7, 0xaa, 0x27, 0xe5,
	0x97, 0x9a, 0x24, 0xa1, 0x97, 0x17, 0x5e, 0x01, 0x10, 0x34, 0x36, 0xf0, 0x94, 0x3e, 0x03, 0xd0,
	0xe6, 0xe6, 0xc1, 0x97, 0x3c, 0x27, 0xfb, 0x94, 0x6d, 0xa1, 0x8e, 0x5c, 0x67, 0xe1, 0x15, 0xf9,
	0xc5, 0x91, 0xdb, 0x17, 0x0a, 0xd3, 0x46, 0x46, 0xeb, 0xda, 0xec, 0x68, 0x91, 0x39, 0x0b, 0xeb,
	0xd6, 0x87, 0x4e, 0x9e, 0xc6, 0x97, 0x21, 0x7f, 0x2f, 0xea, 0x7c, 0xf4, 0xaa, 0x40, 0x6e, 0x6c,
	0xfc, 0xda, 0xfa, 0x8a, 0x54, 0x8d, 0x83, 0x51, 0x52, 0x00, 0xb4, 0xfa, 0x32, 0x06, 0x49, 0xe8,
	0x2b, 0xbb, 0xf0, 0xb7, 0xce, 0xd0, 0x9d, 0x7b, 0xaf, 0x04, 0x39, 0x9c, 0xd0, 0x3d, 0x87, 0xdc,
	0xad, 0xb5, 0x37, 0x16, 0x37, 0x1e, 0xb4, 0x91, 0x02, 0xce, 0xb5, 0xd8, 0x64, 0x6c, 0xa8, 0x08,
	0x84, 0x19, 0x1b, 0x19, 0x4f, 0x2b, 0x41, 0x38, 0x60, 0x6e, 0x16, 0x35, 0xaf, 0xa0, 0x8b, 0xbd,
	0xdd, 0x28, 0x49, 0xef, 0x3f, 0x66, 0xb1, 0x9b, 0xb3, 0x27, 0x41, 0xb9, 0x0b, 0xcd, 0xe5, 0x91,
	0x38, 0x05, 0x46, 0xc7, 0x2d, 0xa0, 0x7e, 0xac, 0xc5, 0xd0, 0xa4, 0xdc, 0xe2, 0xc2, 0x9b, 0xf2,
	0x36, 0x94, 0xbe, 0x84, 0x23, 0x65, 0x70, 0xd3, 0x3d, 0xe7, 0x4d, 0x41, 0x69, 0xf1, 0xc1, 0x46,
	0x07, 0x5f, 0xb9, 0x0e, 0xb7, 0x8d, 0x07, 0x1b, 0x1d, 0x5e, 0x2e, 0xd9, 0x08, 0xfa, 0x6e, 0x66,
	0x61, 0xd1, 0xba, 0xd3, 0xa2, 0xc6, 0xdd, 0x12, 0x5a, 0x59, 0xdc, 0xe8, 0x34, 0x06, 0x71, 0x8c,
	0x51, 0xc1, 0xf1, 0xa6, 0xa1, 0xbc, 0xb8, 0xd1, 0x59, 0x62, 0x5b, 0x51, 0xcc, 0xdc, 0x8c, 0x07,
	0x50, 0x58, 0xdc, 0xe8, 0x2c, 0xfb, 0x7b, 0x6e, 0x76, 0xe1, 0x1b, 0x50, 0x42, 0xbb, 0xb6, 0x57,
	0x7e, 0x4d, 0x48, 0x7f, 0x43, 0x08, 0x56, 0x0a, 0x4a, 0x03, 0x04, 0x77, 0x99, 0x85, 0x36, 0xb8,
	0x66, 0xbf, 0x93, 0xd2, 0x9e, 0x85, 0xca, 0xfb, 0x6b, 0x86, 0x39, 0x4e, 0x08, 0x02, 0x10, 0x2f,
	0xdc, 0x16, 0xb3, 0x60, 0x5f, 0x6d, 0x73, 0x19, 0xa4, 0x0c, 0x01, 0x62, 0x95, 0xec, 0xc2, 0x2d,
	0x00, 0x1e, 0xd2, 0xc4, 0x74, 0x92, 0x9e, 0xd7, 0x85, 0x24, 0x5a, 0x28, 0xc6, 0x94, 0x4b, 0x42,
	0xf4, 0xee, 0x32, 0xff, 0x31, 0x73, 0x33, 0x0b, 0xaf, 0x40, 0xe5, 0x8e, 0xdf, 0xeb, 0x59, 0xf9,
	0xc5, 0x1d, 0x95, 0x5f, 0x04, 0x5d, 0x31, 0x16, 0x01, 0x8d, 0x3b, 0x7e, 0xea, 0x3a, 0x37, 0x7f,
	0x32, 0x0d, 0x95, 0x45, 0x93, 0xc9, 0x79, 0x9f, 0x3a, 0x50, 0x89, 0x42, 0xbd, 0x9f, 0x7b, 0xf3,
	0x63, 0x6b, 0xd5, 0x23, 0xbf, 0x17, 0xaa, 0x9d, 0x10, 0x33, 0xe9, 0x93, 0xab, 0x9f, 0xfc, 0xfc,
	0xbf, 0xff, 0x30, 0x53, 0x23, 0xd5, 0x1b, 0xd6, 0x88, 0x1b, 0xf6, 0xaa, 0x1f, 0x40, 0x29, 0x0a,
	0x85, 0xf9, 0x79, 0xe3, 0xaf, 0xd1, 0xea, 0x4f, 0xd9, 0xb5, 0x63, 0x71, 0x92, 0x3e, 0x79, 0x81,
	0xaf, 0xfa, 0x3c, 0x79, 0x6e, 0x64, 0x55, 0xb9, 0xcc, 0x1e, 0x40, 0x14, 0xea, 0xeb, 0x4b, 0x2f,
	0x4d, 0xfc, 0xb9, 0x9d, 0xbc, 0x09, 0x50, 0x3b, 0x01, 0x56, 0xd2, 0x27, 0x75, 0xbe, 0xf0, 0x65,
	0xf2, 0xfc, 0xc8, 0xc2, 0x7a, 0xb1, 0x4f, 0x1d, 0x98, 0x96, 0xdc, 0x4b, 0x55, 0x7f, 0x6d, 0xe2,
	0x5d, 0x75, 0x9d, 0x19, 0xd7, 0x4e, 0x84, 0x97, 0xf4, 0x09, 0xe1, 0x24, 0x5c, 0x21, 0xb5, 0xa3,
	0x24, 0x2e, 0xd7, 0xfc, 0xd8, 0x81, 0xa9, 0x28, 0xb4, 0x7e, 0xd8, 0x37, 0x76, 0xf2, 0xe1, 0xdf,
	0x17, 0xd6, 0x4e, 0x84, 0x97, 0xf4, 0xc9, 0x8b, 0x9c, 0x88, 0xaf, 0x90, 0xcb, 0x23, 0x44, 0x58,
	0x4b, 0x7e, 0x17, 0x8d, 0xcf, 0x5c, 0xc9, 0xb8, 0x36, 0xf9, 0x06, 0xb5, 0x52, 0xc3, 0x49, 0xd0,
	0x26, 0x98, 0x9d, 0x59, 0xef, 0xb7, 0x51, 0x02, 0x26, 0x3f, 0x1e, 0xbf, 0xfe, 0xd0, 0x65, 0xcf,
	0xda, 0x49, 0xd0, 0x26, 0xf0, 0x6f, 0x2d, 0x98, 0x40, 0x51, 0xf6, 0x27, 0x58, 0xa0, 0x75, 0xb9,
	0xb6, 0x76, 0x02, 0xac, 0xa4, 0x4f, 0xae, 0xf0, 0x95, 0x2f, 0x91, 0x8b, 0x47, 0xad, 0xec, 0x7d,
	0xe6, 0xc0, 0x6c, 0x14, 0xb6, 0x58, 0x6a, 0x72, 0xd4, 0x09, 0xba, 0x1f, 0xfa, 0xf5, 0x4e, 0xed,
	0x44, 0x78, 0x49, 0x9f, 0xbc, 0xc4, 0x29, 0x98, 0x23, 0x57, 0x46, 0x28, 0x18, 0x5e, 0xf5, 0x53,
	0x07, 0x66, 0x38, 0x4c, 0x67, 0xc0, 0x13, 0x4c, 0xc0, 0xfe, 0xa9, 0x78, 0xed, 0x24, 0x68, 0x49,
	0x9f, 0x7c, 0x95, 0x93, 0xf1, 0x02, 0xf9, 0xca, 0x61, 0x32, 0xcc, 0x92, 0x9f, 0x71, 0x77, 0x6c,
	0xb1, 0x14, 0x7b, 0xbc, 0xc2, 0x35, 0x3f, 0xf9, 0xb0, 0x6b, 0xaa, 0x49, 0xb5, 0x13, 0x62, 0x4e,
	0x70, 0x49, 0x7b, 0xdd, 0xef, 0x39, 0xe0, 0x46, 0xa1, 0x28, 0x5e, 0x68, 0xe0, 0xcb, 0xc7, 0x2f,
	0xa1, 0xcb, 0x1d, 0xe3, 0x03, 0xa3, 0x39, 0xd7, 0x92, 0x6b, 0x9c, 0x92, 0x3a, 0x79, 0x61, 0x84,
	0x92, 0x91, 0x75, 0xff, 0xc0, 0x81, 0xe7, 0x70, 0xc4, 0xd0, 0xd9, 0x7c, 0xc0, 0x92, 0xd4, 0xfb,
	0xa5, 0xf1, 0x14, 0x8d, 0x1c, 0xe4, 0x4f, 0x44, 0xcf, 0x02, 0xa7, 0xe7, 0x25, 0x42, 0x46, 0xe3,
	0xe5, 0xe1, 0xa5, 0x97, 0x2e, 0xff, 0xf4, 0x17, 0x73, 0xe7, 0x7e, 0xfa, 0xc5, 0x9c, 0xf3, 0xb3,
	0x2f, 0xe6, 0x9c, 0xff, 0xfc, 0x62, 0xce, 0xf9, 0xc1, 0x7f, 0xcd, 0x9d, 0xfb, 0xf5, 0xac, 0xdf,
	0x0f, 0x1e, 0x16, 0xf8, 0x7f, 0x87, 0xb8, 0xf5, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x91, 0xb6,
	0xbc, 0xa4, 0x8f, 0x42, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ArenaServerClient is the client API for ArenaServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ArenaServerClient interface {
	OnMatchList(ctx context.Context, in *GMatchDetailsReq, opts ...grpc.CallOption) (*GMatchDetailsRsp, error)
	OnSignUp(ctx context.Context, in *GSignUpReq, opts ...grpc.CallOption) (*GSignUpRsp, error)
	OnRankList(ctx context.Context, in *GRankListReq, opts ...grpc.CallOption) (*GRankListRsp, error)
	OnMatchStatus(ctx context.Context, in *MatchStatusReq, opts ...grpc.CallOption) (*MatchStatusRsp, error)
	OnWeekRecord(ctx context.Context, in *GWeekRecordReq, opts ...grpc.CallOption) (*GWeekRecordRsp, error)
	OnAwardList(ctx context.Context, in *GAwardListReq, opts ...grpc.CallOption) (*GAwardListRsp, error)
	OnAwardCount(ctx context.Context, in *AwardCountReq, opts ...grpc.CallOption) (*AwardCountRsp, error)
	OnAward(ctx context.Context, in *GGetAwardReq, opts ...grpc.CallOption) (*GGetAwardRsp, error)
	OnGetFamousList(ctx context.Context, in *GFamousListReq, opts ...grpc.CallOption) (*GFamousListRsp, error)
	OnGetDailyTask(ctx context.Context, in *GDailyTaskReq, opts ...grpc.CallOption) (*GDailyTaskRsp, error)
	OnGetTaskFish(ctx context.Context, in *RewardTaskGetReq, opts ...grpc.CallOption) (*RewardTaskGetRsp, error)
	OnUpdateTaskFish(ctx context.Context, in *RewardTaskUpdateReq, opts ...grpc.CallOption) (*CommonResp, error)
	OnReportStatusRequest(ctx context.Context, in *ReportStatusReqV2, opts ...grpc.CallOption) (*CommonResp, error)
}

type arenaServerClient struct {
	cc *grpc.ClientConn
}

func NewArenaServerClient(cc *grpc.ClientConn) ArenaServerClient {
	return &arenaServerClient{cc}
}

func (c *arenaServerClient) OnMatchList(ctx context.Context, in *GMatchDetailsReq, opts ...grpc.CallOption) (*GMatchDetailsRsp, error) {
	out := new(GMatchDetailsRsp)
	err := c.cc.Invoke(ctx, "/arenaServer.service.v1.ArenaServer/onMatchList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnSignUp(ctx context.Context, in *GSignUpReq, opts ...grpc.CallOption) (*GSignUpRsp, error) {
	out := new(GSignUpRsp)
	err := c.cc.Invoke(ctx, "/arenaServer.service.v1.ArenaServer/onSignUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnRankList(ctx context.Context, in *GRankListReq, opts ...grpc.CallOption) (*GRankListRsp, error) {
	out := new(GRankListRsp)
	err := c.cc.Invoke(ctx, "/arenaServer.service.v1.ArenaServer/onRankList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnMatchStatus(ctx context.Context, in *MatchStatusReq, opts ...grpc.CallOption) (*MatchStatusRsp, error) {
	out := new(MatchStatusRsp)
	err := c.cc.Invoke(ctx, "/arenaServer.service.v1.ArenaServer/onMatchStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnWeekRecord(ctx context.Context, in *GWeekRecordReq, opts ...grpc.CallOption) (*GWeekRecordRsp, error) {
	out := new(GWeekRecordRsp)
	err := c.cc.Invoke(ctx, "/arenaServer.service.v1.ArenaServer/onWeekRecord", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnAwardList(ctx context.Context, in *GAwardListReq, opts ...grpc.CallOption) (*GAwardListRsp, error) {
	out := new(GAwardListRsp)
	err := c.cc.Invoke(ctx, "/arenaServer.service.v1.ArenaServer/onAwardList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnAwardCount(ctx context.Context, in *AwardCountReq, opts ...grpc.CallOption) (*AwardCountRsp, error) {
	out := new(AwardCountRsp)
	err := c.cc.Invoke(ctx, "/arenaServer.service.v1.ArenaServer/onAwardCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnAward(ctx context.Context, in *GGetAwardReq, opts ...grpc.CallOption) (*GGetAwardRsp, error) {
	out := new(GGetAwardRsp)
	err := c.cc.Invoke(ctx, "/arenaServer.service.v1.ArenaServer/onAward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnGetFamousList(ctx context.Context, in *GFamousListReq, opts ...grpc.CallOption) (*GFamousListRsp, error) {
	out := new(GFamousListRsp)
	err := c.cc.Invoke(ctx, "/arenaServer.service.v1.ArenaServer/onGetFamousList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnGetDailyTask(ctx context.Context, in *GDailyTaskReq, opts ...grpc.CallOption) (*GDailyTaskRsp, error) {
	out := new(GDailyTaskRsp)
	err := c.cc.Invoke(ctx, "/arenaServer.service.v1.ArenaServer/onGetDailyTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnGetTaskFish(ctx context.Context, in *RewardTaskGetReq, opts ...grpc.CallOption) (*RewardTaskGetRsp, error) {
	out := new(RewardTaskGetRsp)
	err := c.cc.Invoke(ctx, "/arenaServer.service.v1.ArenaServer/onGetTaskFish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnUpdateTaskFish(ctx context.Context, in *RewardTaskUpdateReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/arenaServer.service.v1.ArenaServer/onUpdateTaskFish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arenaServerClient) OnReportStatusRequest(ctx context.Context, in *ReportStatusReqV2, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/arenaServer.service.v1.ArenaServer/onReportStatusRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArenaServerServer is the server API for ArenaServer service.
type ArenaServerServer interface {
	OnMatchList(context.Context, *GMatchDetailsReq) (*GMatchDetailsRsp, error)
	OnSignUp(context.Context, *GSignUpReq) (*GSignUpRsp, error)
	OnRankList(context.Context, *GRankListReq) (*GRankListRsp, error)
	OnMatchStatus(context.Context, *MatchStatusReq) (*MatchStatusRsp, error)
	OnWeekRecord(context.Context, *GWeekRecordReq) (*GWeekRecordRsp, error)
	OnAwardList(context.Context, *GAwardListReq) (*GAwardListRsp, error)
	OnAwardCount(context.Context, *AwardCountReq) (*AwardCountRsp, error)
	OnAward(context.Context, *GGetAwardReq) (*GGetAwardRsp, error)
	OnGetFamousList(context.Context, *GFamousListReq) (*GFamousListRsp, error)
	OnGetDailyTask(context.Context, *GDailyTaskReq) (*GDailyTaskRsp, error)
	OnGetTaskFish(context.Context, *RewardTaskGetReq) (*RewardTaskGetRsp, error)
	OnUpdateTaskFish(context.Context, *RewardTaskUpdateReq) (*CommonResp, error)
	OnReportStatusRequest(context.Context, *ReportStatusReqV2) (*CommonResp, error)
}

func RegisterArenaServerServer(s *grpc.Server, srv ArenaServerServer) {
	s.RegisterService(&_ArenaServer_serviceDesc, srv)
}

func _ArenaServer_OnMatchList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GMatchDetailsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnMatchList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arenaServer.service.v1.ArenaServer/OnMatchList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnMatchList(ctx, req.(*GMatchDetailsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnSignUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GSignUpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnSignUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arenaServer.service.v1.ArenaServer/OnSignUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnSignUp(ctx, req.(*GSignUpReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnRankList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GRankListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnRankList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arenaServer.service.v1.ArenaServer/OnRankList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnRankList(ctx, req.(*GRankListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnMatchStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnMatchStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arenaServer.service.v1.ArenaServer/OnMatchStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnMatchStatus(ctx, req.(*MatchStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnWeekRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GWeekRecordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnWeekRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arenaServer.service.v1.ArenaServer/OnWeekRecord",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnWeekRecord(ctx, req.(*GWeekRecordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnAwardList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GAwardListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnAwardList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arenaServer.service.v1.ArenaServer/OnAwardList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnAwardList(ctx, req.(*GAwardListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnAwardCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AwardCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnAwardCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arenaServer.service.v1.ArenaServer/OnAwardCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnAwardCount(ctx, req.(*AwardCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnAward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GGetAwardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnAward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arenaServer.service.v1.ArenaServer/OnAward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnAward(ctx, req.(*GGetAwardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnGetFamousList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GFamousListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnGetFamousList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arenaServer.service.v1.ArenaServer/OnGetFamousList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnGetFamousList(ctx, req.(*GFamousListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnGetDailyTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GDailyTaskReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnGetDailyTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arenaServer.service.v1.ArenaServer/OnGetDailyTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnGetDailyTask(ctx, req.(*GDailyTaskReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnGetTaskFish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RewardTaskGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnGetTaskFish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arenaServer.service.v1.ArenaServer/OnGetTaskFish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnGetTaskFish(ctx, req.(*RewardTaskGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnUpdateTaskFish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RewardTaskUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnUpdateTaskFish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arenaServer.service.v1.ArenaServer/OnUpdateTaskFish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnUpdateTaskFish(ctx, req.(*RewardTaskUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArenaServer_OnReportStatusRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportStatusReqV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArenaServerServer).OnReportStatusRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arenaServer.service.v1.ArenaServer/OnReportStatusRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArenaServerServer).OnReportStatusRequest(ctx, req.(*ReportStatusReqV2))
	}
	return interceptor(ctx, in, info, handler)
}

var _ArenaServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arenaServer.service.v1.ArenaServer",
	HandlerType: (*ArenaServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "onMatchList",
			Handler:    _ArenaServer_OnMatchList_Handler,
		},
		{
			MethodName: "onSignUp",
			Handler:    _ArenaServer_OnSignUp_Handler,
		},
		{
			MethodName: "onRankList",
			Handler:    _ArenaServer_OnRankList_Handler,
		},
		{
			MethodName: "onMatchStatus",
			Handler:    _ArenaServer_OnMatchStatus_Handler,
		},
		{
			MethodName: "onWeekRecord",
			Handler:    _ArenaServer_OnWeekRecord_Handler,
		},
		{
			MethodName: "onAwardList",
			Handler:    _ArenaServer_OnAwardList_Handler,
		},
		{
			MethodName: "onAwardCount",
			Handler:    _ArenaServer_OnAwardCount_Handler,
		},
		{
			MethodName: "onAward",
			Handler:    _ArenaServer_OnAward_Handler,
		},
		{
			MethodName: "onGetFamousList",
			Handler:    _ArenaServer_OnGetFamousList_Handler,
		},
		{
			MethodName: "onGetDailyTask",
			Handler:    _ArenaServer_OnGetDailyTask_Handler,
		},
		{
			MethodName: "onGetTaskFish",
			Handler:    _ArenaServer_OnGetTaskFish_Handler,
		},
		{
			MethodName: "onUpdateTaskFish",
			Handler:    _ArenaServer_OnUpdateTaskFish_Handler,
		},
		{
			MethodName: "onReportStatusRequest",
			Handler:    _ArenaServer_OnReportStatusRequest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *HttpCommonRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpCommonRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.En != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.En))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GAward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GAward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GRank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GRank) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rank != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Mark != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mark))
	}
	if m.RankStart != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RankStart))
	}
	if m.RankEnd != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RankEnd))
	}
	if len(m.NickName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.NickName)))
		i += copy(dAtA[i:], m.NickName)
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if m.Awards != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Awards.Size()))
		n1, err := m.Awards.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GDailyTaskReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GDailyTaskReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MatchId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GDailyTaskRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GDailyTaskRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.TargetScore != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TargetScore))
	}
	if m.AwardType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AwardType))
	}
	if m.AwardNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AwardNum))
	}
	if m.FinishStatus != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FinishStatus))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GRankListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GRankListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MatchId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GRankListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GRankListRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.SelfRank != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SelfRank))
	}
	if len(m.FristDay) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.FristDay)))
		i += copy(dAtA[i:], m.FristDay)
	}
	if len(m.LastDay) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.LastDay)))
		i += copy(dAtA[i:], m.LastDay)
	}
	if len(m.CurDay) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CurDay)))
		i += copy(dAtA[i:], m.CurDay)
	}
	if len(m.Ranklist) > 0 {
		for _, msg := range m.Ranklist {
			dAtA[i] = 0x42
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GWeekRecordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GWeekRecordReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MatchId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WeekRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeekRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WeekOne != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.WeekOne))
	}
	if m.Mark != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mark))
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GWeekRecordRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GWeekRecordRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.WeekOne != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.WeekOne))
	}
	if m.WeekRank != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.WeekRank))
	}
	if m.WeekMark != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.WeekMark))
	}
	if len(m.WeekRecords) > 0 {
		for _, msg := range m.WeekRecords {
			dAtA[i] = 0x32
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GConditions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GConditions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GMatchDetailsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GMatchDetailsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GMatchDetailsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GMatchDetailsRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.MatchId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
	}
	if len(m.StartTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.StartTime)))
		i += copy(dAtA[i:], m.StartTime)
	}
	if len(m.EndTime) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndTime)))
		i += copy(dAtA[i:], m.EndTime)
	}
	if m.WeekMark != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.WeekMark))
	}
	if m.DayMark != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DayMark))
	}
	if m.Rank != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
	}
	if m.TotalRank != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TotalRank))
	}
	if len(m.Condition) > 0 {
		for _, msg := range m.Condition {
			dAtA[i] = 0x52
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Cost != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Cost.Size()))
		n2, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Additional != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Additional))
	}
	if m.MatchStatus != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MatchStatus))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GSignUpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GSignUpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MatchId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GSignUpRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GSignUpRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.MatchId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
	}
	if len(m.GameUrl) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.GameUrl)))
		i += copy(dAtA[i:], m.GameUrl)
	}
	if len(m.ArenaUrl) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ArenaUrl)))
		i += copy(dAtA[i:], m.ArenaUrl)
	}
	if m.Status != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GFamousListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GFamousListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MatchId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Famous) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Famous) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Date) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Date)))
		i += copy(dAtA[i:], m.Date)
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Mark != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mark))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GFamousListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GFamousListRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.FamousList) > 0 {
		for _, msg := range m.FamousList {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MatchStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchStatusReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MatchTips) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchTips) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GameType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GameType))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if len(m.TypeTips) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeTips)))
		i += copy(dAtA[i:], m.TypeTips)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MatchStatusRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchStatusRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Tips) > 0 {
		for _, msg := range m.Tips {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShareStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShareStatusReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.Status {
		dAtA[i] = 0x20
		i++
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShareStatusRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShareStatusRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.Core != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Core))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AwardListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GAwardListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GAwardListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GAwardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GAwardInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.TypeTips) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeTips)))
		i += copy(dAtA[i:], m.TypeTips)
	}
	if len(m.Awards) > 0 {
		for _, msg := range m.Awards {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Date) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Date)))
		i += copy(dAtA[i:], m.Date)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GAwardListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GAwardListRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.AwardList) > 0 {
		for _, msg := range m.AwardList {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GGetAwardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GGetAwardReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if len(m.Ids) > 0 {
		for _, s := range m.Ids {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AwardRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ids) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ids)))
		i += copy(dAtA[i:], m.Ids)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GGetAwardRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GGetAwardRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if len(m.AwardRsps) > 0 {
		for _, msg := range m.AwardRsps {
			dAtA[i] = 0x22
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AwardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if len(m.TypeTips) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeTips)))
		i += copy(dAtA[i:], m.TypeTips)
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.MoneyId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MoneyId))
	}
	if m.Money != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Money))
	}
	if len(m.Date) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Date)))
		i += copy(dAtA[i:], m.Date)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AwardListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardListRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AwardList) > 0 {
		for _, msg := range m.AwardList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAwardData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAwardData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if len(m.Date) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Date)))
		i += copy(dAtA[i:], m.Date)
	}
	if m.MoneyId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MoneyId))
	}
	if m.Money != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Money))
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAwardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAwardReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if len(m.AwardList) > 0 {
		for _, msg := range m.AwardList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAwardRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAwardRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if len(m.AwardList) > 0 {
		for _, msg := range m.AwardList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Code != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AwardCountReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardCountReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AwardCountRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardCountRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Count != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RankListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Areantype != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Areantype))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RankListInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankListInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartRank != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StartRank))
	}
	if m.EndRank != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.EndRank))
	}
	if m.UserType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.UserType))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if m.Mark != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mark))
	}
	if m.AwardId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AwardId))
	}
	if m.Award != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Award))
	}
	if m.Multiple != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Multiple))
	}
	if m.Stars {
		dAtA[i] = 0x50
		i++
		if m.Stars {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RankListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankListRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if len(m.TypeTip) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeTip)))
		i += copy(dAtA[i:], m.TypeTip)
	}
	if m.Areantype != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Areantype))
	}
	if len(m.RankList) > 0 {
		for _, msg := range m.RankList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Rank != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
	}
	if m.TotalRank != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TotalRank))
	}
	if m.Mark != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mark))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PMatchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PMatchInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if len(m.TypeTips) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeTips)))
		i += copy(dAtA[i:], m.TypeTips)
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.JoinTimes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.JoinTimes))
	}
	if m.TotalTimes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TotalTimes))
	}
	if m.TimeStatus != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TimeStatus))
	}
	if m.Hour != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Hour))
	}
	if m.Minute != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Minute))
	}
	if m.Status != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
	}
	if len(m.ConditionList) > 0 {
		for _, msg := range m.ConditionList {
			dAtA[i] = 0x52
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Rank != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
	}
	if m.TotalRank != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TotalRank))
	}
	if m.Award != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Award))
	}
	if m.Multiple != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Multiple))
	}
	if m.AwardCount != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AwardCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PMatchListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PMatchListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PMatchListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PMatchListRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MatchList) > 0 {
		for _, msg := range m.MatchList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PSignUpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PSignUpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Head) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Head)))
		i += copy(dAtA[i:], m.Head)
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PSignUpRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PSignUpRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Money != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Money))
	}
	if m.Core != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Core))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FMatchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FMatchInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if len(m.TypeTips) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeTips)))
		i += copy(dAtA[i:], m.TypeTips)
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if len(m.OpenTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.OpenTime)))
		i += copy(dAtA[i:], m.OpenTime)
	}
	if m.PlayerTimes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerTimes))
	}
	if m.JoinTimes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.JoinTimes))
	}
	if m.TotalTimes != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TotalTimes))
	}
	if m.MatchTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MatchTime))
	}
	if len(m.ConditionList) > 0 {
		for _, msg := range m.ConditionList {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AwardList) > 0 {
		dAtA4 := make([]byte, len(m.AwardList)*10)
		var j3 int
		for _, num1 := range m.AwardList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.Status != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FMatchListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FMatchListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FMatchListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FMatchListRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MatchList) > 0 {
		for _, msg := range m.MatchList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PositionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Latitude != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i += 8
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FSignUpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSignUpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Head) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Head)))
		i += copy(dAtA[i:], m.Head)
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if m.Position != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Position.Size()))
		n5, err := m.Position.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FSignUpRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSignUpRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Money != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Money))
	}
	if m.Core != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Core))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FWaitMatchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FWaitMatchReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FWaitMatchRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FWaitMatchRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
	}
	if m.Join != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Join))
	}
	if m.Total != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FCancelMatchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FCancelMatchReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FCancelMatchRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FCancelMatchRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Result != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FConfirmReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FConfirmReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FConfirmRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FConfirmRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Result != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FRobotLoginReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FRobotLoginReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FRobotLoginRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FRobotLoginRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Core != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Core))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FRobotJoinMatchRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FRobotJoinMatchRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.Difficulty != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Difficulty))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FRobotHeartReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FRobotHeartReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FRobotHeartRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FRobotHeartRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Core != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Core))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Ops != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ops))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Size_))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReportStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportStatusReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ServerId))
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TableId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GameCountDown) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameCountDown) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TableId))
	}
	if m.Sce != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Sce))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GReportMatchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GReportMatchReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.MaxMark != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MaxMark))
	}
	if m.Bullet != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Bullet))
	}
	if m.ReportType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ReportType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GReportMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GReportMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.MaxMark != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MaxMark))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GReportMatchRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GReportMatchRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, msg := range m.Infos {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GGameEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GGameEnd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GGameCountDown) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GGameCountDown) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.Sce != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Sce))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GameSettlement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameSettlement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rank != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
	}
	if m.Total != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
	}
	if m.VipAddition != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VipAddition))
	}
	if m.ChallengeAddition != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ChallengeAddition))
	}
	if m.CurMark != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CurMark))
	}
	if m.MaxMark != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MaxMark))
	}
	if m.Type != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateKeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateKeyValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PReportMatchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PReportMatchReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.MaxMark != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MaxMark))
	}
	if m.Score != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PReportMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PReportMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.MaxMark != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MaxMark))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Head) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Head)))
		i += copy(dAtA[i:], m.Head)
	}
	if m.RankIdx != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RankIdx))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PReportMatchRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PReportMatchRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, msg := range m.Infos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PGameEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PGameEnd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FReportMatchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FReportMatchReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ServerId))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TableId))
	}
	if m.Mark != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mark))
	}
	if m.Score != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
	}
	if m.RatioChange {
		dAtA[i] = 0x38
		i++
		if m.RatioChange {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FReportMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FReportMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TableId))
	}
	if m.MaxMark != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MaxMark))
	}
	if m.RankIdx != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RankIdx))
	}
	if m.BulletCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BulletCount))
	}
	if m.BulletTotal != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BulletTotal))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FReportMatchRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FReportMatchRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, msg := range m.Infos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FSettlementNotice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSettlementNotice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if len(m.TableId) > 0 {
		dAtA7 := make([]byte, len(m.TableId)*10)
		var j6 int
		for _, num1 := range m.TableId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FPlayerResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FPlayerResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Rank != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Mark != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mark))
	}
	if m.Award != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Award))
	}
	if len(m.Date) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Date)))
		i += copy(dAtA[i:], m.Date)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FGameEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FGameEnd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if len(m.TableId) > 0 {
		dAtA9 := make([]byte, len(m.TableId)*10)
		var j8 int
		for _, num1 := range m.TableId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if len(m.PlayerResultList) > 0 {
		for _, msg := range m.PlayerResultList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FRobotNameSynReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FRobotNameSynReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ServerId))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FRobotNameSynRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FRobotNameSynRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Chat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SectionWords) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.SectionWords)))
		i += copy(dAtA[i:], m.SectionWords)
	}
	if len(m.FilterWords) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.FilterWords)))
		i += copy(dAtA[i:], m.FilterWords)
	}
	if m.GameID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
	}
	if m.ContentType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ContentType))
	}
	if m.Delaysec != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Delaysec))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AbyGameInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AbyGameInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GameType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GameType))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
	}
	if m.Count != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Count))
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
	}
	if len(m.Tips) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tips)))
		i += copy(dAtA[i:], m.Tips)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RewardFish) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardFish) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
	}
	if m.CaptureNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CaptureNum))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RewardTaskGetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardTaskGetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RewardTaskGetRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardTaskGetRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.TaskId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TaskId))
	}
	if m.Reward != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Reward))
	}
	if m.Clock != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Clock))
	}
	if m.TaskStatus != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TaskStatus))
	}
	if len(m.RewardFish) > 0 {
		for _, msg := range m.RewardFish {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RewardTaskUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardTaskUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
	}
	if m.TaskId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TaskId))
	}
	if m.Reward != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Reward))
	}
	if m.Clock != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Clock))
	}
	if m.TaskStatus != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TaskStatus))
	}
	if len(m.RewardFish) > 0 {
		for _, msg := range m.RewardFish {
			dAtA[i] = 0x32
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReportStatusReqV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportStatusReqV2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommonResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HttpCommonRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.En != 0 {
		n += 1 + sovApi(uint64(m.En))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GAward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GRank) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Mark != 0 {
		n += 1 + sovApi(uint64(m.Mark))
	}
	if m.RankStart != 0 {
		n += 1 + sovApi(uint64(m.RankStart))
	}
	if m.RankEnd != 0 {
		n += 1 + sovApi(uint64(m.RankEnd))
	}
	l = len(m.NickName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Awards != nil {
		l = m.Awards.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GDailyTaskReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GDailyTaskRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TargetScore != 0 {
		n += 1 + sovApi(uint64(m.TargetScore))
	}
	if m.AwardType != 0 {
		n += 1 + sovApi(uint64(m.AwardType))
	}
	if m.AwardNum != 0 {
		n += 1 + sovApi(uint64(m.AwardNum))
	}
	if m.FinishStatus != 0 {
		n += 1 + sovApi(uint64(m.FinishStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GRankListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GRankListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.SelfRank != 0 {
		n += 1 + sovApi(uint64(m.SelfRank))
	}
	l = len(m.FristDay)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.LastDay)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.CurDay)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Ranklist) > 0 {
		for _, e := range m.Ranklist {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GWeekRecordReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WeekRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WeekOne != 0 {
		n += 1 + sovApi(uint64(m.WeekOne))
	}
	if m.Mark != 0 {
		n += 1 + sovApi(uint64(m.Mark))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GWeekRecordRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.WeekOne != 0 {
		n += 1 + sovApi(uint64(m.WeekOne))
	}
	if m.WeekRank != 0 {
		n += 1 + sovApi(uint64(m.WeekRank))
	}
	if m.WeekMark != 0 {
		n += 1 + sovApi(uint64(m.WeekMark))
	}
	if len(m.WeekRecords) > 0 {
		for _, e := range m.WeekRecords {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GConditions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GMatchDetailsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GMatchDetailsRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.WeekMark != 0 {
		n += 1 + sovApi(uint64(m.WeekMark))
	}
	if m.DayMark != 0 {
		n += 1 + sovApi(uint64(m.DayMark))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.TotalRank != 0 {
		n += 1 + sovApi(uint64(m.TotalRank))
	}
	if len(m.Condition) > 0 {
		for _, e := range m.Condition {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Additional != 0 {
		n += 1 + sovApi(uint64(m.Additional))
	}
	if m.MatchStatus != 0 {
		n += 1 + sovApi(uint64(m.MatchStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GSignUpReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GSignUpRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	l = len(m.GameUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ArenaUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GFamousListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Famous) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mark != 0 {
		n += 1 + sovApi(uint64(m.Mark))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GFamousListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.FamousList) > 0 {
		for _, e := range m.FamousList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchStatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchTips) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameType != 0 {
		n += 1 + sovApi(uint64(m.GameType))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.TypeTips)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchStatusRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Tips) > 0 {
		for _, e := range m.Tips {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShareStatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Status {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShareStatusRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Core != 0 {
		n += 1 + sovApi(uint64(m.Core))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GAwardListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GAwardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.TypeTips)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Awards) > 0 {
		for _, e := range m.Awards {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GAwardListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.AwardList) > 0 {
		for _, e := range m.AwardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GGetAwardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if len(m.Ids) > 0 {
		for _, s := range m.Ids {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ids)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GGetAwardRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if len(m.AwardRsps) > 0 {
		for _, e := range m.AwardRsps {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.TypeTips)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.MoneyId != 0 {
		n += 1 + sovApi(uint64(m.MoneyId))
	}
	if m.Money != 0 {
		n += 1 + sovApi(uint64(m.Money))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AwardList) > 0 {
		for _, e := range m.AwardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAwardData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MoneyId != 0 {
		n += 1 + sovApi(uint64(m.MoneyId))
	}
	if m.Money != 0 {
		n += 1 + sovApi(uint64(m.Money))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAwardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if len(m.AwardList) > 0 {
		for _, e := range m.AwardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAwardRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if len(m.AwardList) > 0 {
		for _, e := range m.AwardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardCountReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardCountRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Count != 0 {
		n += 1 + sovApi(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Value != 0 {
		n += 1 + sovApi(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Areantype != 0 {
		n += 1 + sovApi(uint64(m.Areantype))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankListInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartRank != 0 {
		n += 1 + sovApi(uint64(m.StartRank))
	}
	if m.EndRank != 0 {
		n += 1 + sovApi(uint64(m.EndRank))
	}
	if m.UserType != 0 {
		n += 1 + sovApi(uint64(m.UserType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mark != 0 {
		n += 1 + sovApi(uint64(m.Mark))
	}
	if m.AwardId != 0 {
		n += 1 + sovApi(uint64(m.AwardId))
	}
	if m.Award != 0 {
		n += 1 + sovApi(uint64(m.Award))
	}
	if m.Multiple != 0 {
		n += 1 + sovApi(uint64(m.Multiple))
	}
	if m.Stars {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.TypeTip)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Areantype != 0 {
		n += 1 + sovApi(uint64(m.Areantype))
	}
	if len(m.RankList) > 0 {
		for _, e := range m.RankList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.TotalRank != 0 {
		n += 1 + sovApi(uint64(m.TotalRank))
	}
	if m.Mark != 0 {
		n += 1 + sovApi(uint64(m.Mark))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PMatchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.TypeTips)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.JoinTimes != 0 {
		n += 1 + sovApi(uint64(m.JoinTimes))
	}
	if m.TotalTimes != 0 {
		n += 1 + sovApi(uint64(m.TotalTimes))
	}
	if m.TimeStatus != 0 {
		n += 1 + sovApi(uint64(m.TimeStatus))
	}
	if m.Hour != 0 {
		n += 1 + sovApi(uint64(m.Hour))
	}
	if m.Minute != 0 {
		n += 1 + sovApi(uint64(m.Minute))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if len(m.ConditionList) > 0 {
		for _, e := range m.ConditionList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.TotalRank != 0 {
		n += 1 + sovApi(uint64(m.TotalRank))
	}
	if m.Award != 0 {
		n += 1 + sovApi(uint64(m.Award))
	}
	if m.Multiple != 0 {
		n += 1 + sovApi(uint64(m.Multiple))
	}
	if m.AwardCount != 0 {
		n += 1 + sovApi(uint64(m.AwardCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PMatchListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PMatchListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MatchList) > 0 {
		for _, e := range m.MatchList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PSignUpReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PSignUpRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Money != 0 {
		n += 1 + sovApi(uint64(m.Money))
	}
	if m.Core != 0 {
		n += 1 + sovApi(uint64(m.Core))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FMatchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.TypeTips)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.OpenTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PlayerTimes != 0 {
		n += 1 + sovApi(uint64(m.PlayerTimes))
	}
	if m.JoinTimes != 0 {
		n += 1 + sovApi(uint64(m.JoinTimes))
	}
	if m.TotalTimes != 0 {
		n += 1 + sovApi(uint64(m.TotalTimes))
	}
	if m.MatchTime != 0 {
		n += 1 + sovApi(uint64(m.MatchTime))
	}
	if len(m.ConditionList) > 0 {
		for _, e := range m.ConditionList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.AwardList) > 0 {
		l = 0
		for _, e := range m.AwardList {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FMatchListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FMatchListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MatchList) > 0 {
		for _, e := range m.MatchList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PositionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Latitude != 0 {
		n += 9
	}
	if m.Longitude != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FSignUpReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FSignUpRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Money != 0 {
		n += 1 + sovApi(uint64(m.Money))
	}
	if m.Core != 0 {
		n += 1 + sovApi(uint64(m.Core))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FWaitMatchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FWaitMatchRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.Join != 0 {
		n += 1 + sovApi(uint64(m.Join))
	}
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FCancelMatchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FCancelMatchRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Result != 0 {
		n += 1 + sovApi(uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FConfirmReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FConfirmRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Result != 0 {
		n += 1 + sovApi(uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FRobotLoginReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FRobotLoginRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Core != 0 {
		n += 1 + sovApi(uint64(m.Core))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FRobotJoinMatchRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Difficulty != 0 {
		n += 1 + sovApi(uint64(m.Difficulty))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FRobotHeartReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FRobotHeartRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Core != 0 {
		n += 1 + sovApi(uint64(m.Core))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Ops != 0 {
		n += 1 + sovApi(uint64(m.Ops))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovApi(uint64(m.Size_))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportStatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.ServerId != 0 {
		n += 1 + sovApi(uint64(m.ServerId))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.TableId != 0 {
		n += 1 + sovApi(uint64(m.TableId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameCountDown) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.TableId != 0 {
		n += 1 + sovApi(uint64(m.TableId))
	}
	if m.Sce != 0 {
		n += 1 + sovApi(uint64(m.Sce))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GReportMatchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.MaxMark != 0 {
		n += 1 + sovApi(uint64(m.MaxMark))
	}
	if m.Bullet != 0 {
		n += 1 + sovApi(uint64(m.Bullet))
	}
	if m.ReportType != 0 {
		n += 1 + sovApi(uint64(m.ReportType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GReportMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.MaxMark != 0 {
		n += 1 + sovApi(uint64(m.MaxMark))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GReportMatchRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GGameEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GGameCountDown) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Sce != 0 {
		n += 1 + sovApi(uint64(m.Sce))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameSettlement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if m.VipAddition != 0 {
		n += 1 + sovApi(uint64(m.VipAddition))
	}
	if m.ChallengeAddition != 0 {
		n += 1 + sovApi(uint64(m.ChallengeAddition))
	}
	if m.CurMark != 0 {
		n += 1 + sovApi(uint64(m.CurMark))
	}
	if m.MaxMark != 0 {
		n += 1 + sovApi(uint64(m.MaxMark))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateKeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PReportMatchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.MaxMark != 0 {
		n += 1 + sovApi(uint64(m.MaxMark))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PReportMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.MaxMark != 0 {
		n += 1 + sovApi(uint64(m.MaxMark))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.RankIdx != 0 {
		n += 1 + sovApi(uint64(m.RankIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PReportMatchRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PGameEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FReportMatchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.ServerId != 0 {
		n += 1 + sovApi(uint64(m.ServerId))
	}
	if m.TableId != 0 {
		n += 1 + sovApi(uint64(m.TableId))
	}
	if m.Mark != 0 {
		n += 1 + sovApi(uint64(m.Mark))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.RatioChange {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FReportMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.TableId != 0 {
		n += 1 + sovApi(uint64(m.TableId))
	}
	if m.MaxMark != 0 {
		n += 1 + sovApi(uint64(m.MaxMark))
	}
	if m.RankIdx != 0 {
		n += 1 + sovApi(uint64(m.RankIdx))
	}
	if m.BulletCount != 0 {
		n += 1 + sovApi(uint64(m.BulletCount))
	}
	if m.BulletTotal != 0 {
		n += 1 + sovApi(uint64(m.BulletTotal))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FReportMatchRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FSettlementNotice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if len(m.TableId) > 0 {
		l = 0
		for _, e := range m.TableId {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FPlayerResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mark != 0 {
		n += 1 + sovApi(uint64(m.Mark))
	}
	if m.Award != 0 {
		n += 1 + sovApi(uint64(m.Award))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FGameEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if len(m.TableId) > 0 {
		l = 0
		for _, e := range m.TableId {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.PlayerResultList) > 0 {
		for _, e := range m.PlayerResultList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FRobotNameSynReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.ServerId != 0 {
		n += 1 + sovApi(uint64(m.ServerId))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FRobotNameSynRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Chat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SectionWords)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.FilterWords)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.ContentType != 0 {
		n += 1 + sovApi(uint64(m.ContentType))
	}
	if m.Delaysec != 0 {
		n += 1 + sovApi(uint64(m.Delaysec))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AbyGameInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameType != 0 {
		n += 1 + sovApi(uint64(m.GameType))
	}
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.Count != 0 {
		n += 1 + sovApi(uint64(m.Count))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	l = len(m.Tips)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardFish) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.CaptureNum != 0 {
		n += 1 + sovApi(uint64(m.CaptureNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardTaskGetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardTaskGetRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TaskId != 0 {
		n += 1 + sovApi(uint64(m.TaskId))
	}
	if m.Reward != 0 {
		n += 1 + sovApi(uint64(m.Reward))
	}
	if m.Clock != 0 {
		n += 1 + sovApi(uint64(m.Clock))
	}
	if m.TaskStatus != 0 {
		n += 1 + sovApi(uint64(m.TaskStatus))
	}
	if len(m.RewardFish) > 0 {
		for _, e := range m.RewardFish {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardTaskUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.TaskId != 0 {
		n += 1 + sovApi(uint64(m.TaskId))
	}
	if m.Reward != 0 {
		n += 1 + sovApi(uint64(m.Reward))
	}
	if m.Clock != 0 {
		n += 1 + sovApi(uint64(m.Clock))
	}
	if m.TaskStatus != 0 {
		n += 1 + sovApi(uint64(m.TaskStatus))
	}
	if len(m.RewardFish) > 0 {
		for _, e := range m.RewardFish {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportStatusReqV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HttpCommonRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpCommonRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpCommonRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field En", wireType)
			}
			m.En = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.En |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GAward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GAward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GAward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GRank) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GRank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GRank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			m.Mark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mark |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankStart", wireType)
			}
			m.RankStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankStart |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankEnd", wireType)
			}
			m.RankEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankEnd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Awards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Awards == nil {
				m.Awards = &GAward{}
			}
			if err := m.Awards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GDailyTaskReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GDailyTaskReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GDailyTaskReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GDailyTaskRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GDailyTaskRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GDailyTaskRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetScore", wireType)
			}
			m.TargetScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetScore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardType", wireType)
			}
			m.AwardType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AwardType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardNum", wireType)
			}
			m.AwardNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AwardNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishStatus", wireType)
			}
			m.FinishStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinishStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GRankListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GRankListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GRankListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GRankListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GRankListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GRankListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfRank", wireType)
			}
			m.SelfRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FristDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FristDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranklist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranklist = append(m.Ranklist, &GRank{})
			if err := m.Ranklist[len(m.Ranklist)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GWeekRecordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GWeekRecordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GWeekRecordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeekRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeekRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeekRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekOne", wireType)
			}
			m.WeekOne = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeekOne |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			m.Mark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mark |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GWeekRecordRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GWeekRecordRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GWeekRecordRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekOne", wireType)
			}
			m.WeekOne = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeekOne |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekRank", wireType)
			}
			m.WeekRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeekRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekMark", wireType)
			}
			m.WeekMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeekMark |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekRecords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WeekRecords = append(m.WeekRecords, &WeekRecord{})
			if err := m.WeekRecords[len(m.WeekRecords)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GConditions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GConditions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GConditions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GMatchDetailsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GMatchDetailsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GMatchDetailsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GMatchDetailsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GMatchDetailsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GMatchDetailsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekMark", wireType)
			}
			m.WeekMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeekMark |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayMark", wireType)
			}
			m.DayMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DayMark |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRank", wireType)
			}
			m.TotalRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Condition = append(m.Condition, &GConditions{})
			if err := m.Condition[len(m.Condition)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &GConditions{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Additional", wireType)
			}
			m.Additional = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Additional |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchStatus", wireType)
			}
			m.MatchStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GSignUpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GSignUpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GSignUpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GSignUpRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GSignUpRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GSignUpRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArenaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GFamousListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GFamousListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GFamousListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Famous) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Famous: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Famous: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			m.Mark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mark |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GFamousListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GFamousListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GFamousListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamousList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FamousList = append(m.FamousList, &Famous{})
			if err := m.FamousList[len(m.FamousList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchTips) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchTips: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchTips: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameType", wireType)
			}
			m.GameType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeTips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeTips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchStatusRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchStatusRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchStatusRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tips = append(m.Tips, &MatchTips{})
			if err := m.Tips[len(m.Tips)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShareStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShareStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShareStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShareStatusRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShareStatusRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShareStatusRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			m.Core = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Core |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GAwardListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GAwardListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GAwardListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GAwardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GAwardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GAwardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeTips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeTips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Awards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Awards = append(m.Awards, &GAward{})
			if err := m.Awards[len(m.Awards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GAwardListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GAwardListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GAwardListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwardList = append(m.AwardList, &GAwardInfo{})
			if err := m.AwardList[len(m.AwardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GGetAwardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GGetAwardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GGetAwardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GGetAwardRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GGetAwardRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GGetAwardRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardRsps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwardRsps = append(m.AwardRsps, &AwardRsp{})
			if err := m.AwardRsps[len(m.AwardRsps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeTips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeTips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoneyId", wireType)
			}
			m.MoneyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoneyId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwardList = append(m.AwardList, &AwardInfo{})
			if err := m.AwardList[len(m.AwardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAwardData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAwardData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAwardData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoneyId", wireType)
			}
			m.MoneyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoneyId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAwardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAwardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAwardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwardList = append(m.AwardList, &GetAwardData{})
			if err := m.AwardList[len(m.AwardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAwardRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAwardRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAwardRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwardList = append(m.AwardList, &GetAwardData{})
			if err := m.AwardList[len(m.AwardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardCountReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardCountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardCountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardCountRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardCountRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardCountRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Areantype", wireType)
			}
			m.Areantype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Areantype |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankListInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankListInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankListInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartRank", wireType)
			}
			m.StartRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndRank", wireType)
			}
			m.EndRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserType", wireType)
			}
			m.UserType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			m.Mark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardId", wireType)
			}
			m.AwardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AwardId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Award", wireType)
			}
			m.Award = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Award |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiple", wireType)
			}
			m.Multiple = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Multiple |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stars", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stars = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeTip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeTip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Areantype", wireType)
			}
			m.Areantype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Areantype |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankList = append(m.RankList, &RankListInfo{})
			if err := m.RankList[len(m.RankList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRank", wireType)
			}
			m.TotalRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			m.Mark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PMatchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PMatchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PMatchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeTips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeTips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinTimes", wireType)
			}
			m.JoinTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTimes", wireType)
			}
			m.TotalTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStatus", wireType)
			}
			m.TimeStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hour", wireType)
			}
			m.Hour = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hour |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minute", wireType)
			}
			m.Minute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minute |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionList = append(m.ConditionList, &Condition{})
			if err := m.ConditionList[len(m.ConditionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRank", wireType)
			}
			m.TotalRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Award", wireType)
			}
			m.Award = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Award |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiple", wireType)
			}
			m.Multiple = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Multiple |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardCount", wireType)
			}
			m.AwardCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AwardCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PMatchListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PMatchListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PMatchListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PMatchListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PMatchListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PMatchListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchList = append(m.MatchList, &PMatchInfo{})
			if err := m.MatchList[len(m.MatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PSignUpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PSignUpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PSignUpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PSignUpRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PSignUpRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PSignUpRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			m.Core = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Core |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FMatchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FMatchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FMatchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeTips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeTips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerTimes", wireType)
			}
			m.PlayerTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinTimes", wireType)
			}
			m.JoinTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTimes", wireType)
			}
			m.TotalTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchTime", wireType)
			}
			m.MatchTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionList = append(m.ConditionList, &Condition{})
			if err := m.ConditionList[len(m.ConditionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AwardList = append(m.AwardList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AwardList) == 0 {
					m.AwardList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AwardList = append(m.AwardList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardList", wireType)
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FMatchListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FMatchListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FMatchListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FMatchListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FMatchListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FMatchListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchList = append(m.MatchList, &FMatchInfo{})
			if err := m.MatchList[len(m.MatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSignUpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSignUpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSignUpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &PositionInfo{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSignUpRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSignUpRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSignUpRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			m.Core = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Core |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FWaitMatchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FWaitMatchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FWaitMatchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FWaitMatchRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FWaitMatchRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FWaitMatchRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			m.Join = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Join |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FCancelMatchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FCancelMatchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FCancelMatchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FCancelMatchRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FCancelMatchRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FCancelMatchRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FConfirmReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FConfirmReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FConfirmReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FConfirmRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FConfirmRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FConfirmRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FRobotLoginReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FRobotLoginReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FRobotLoginReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FRobotLoginRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FRobotLoginRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FRobotLoginRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			m.Core = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Core |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FRobotJoinMatchRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FRobotJoinMatchRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FRobotJoinMatchRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Difficulty", wireType)
			}
			m.Difficulty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Difficulty |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FRobotHeartReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FRobotHeartReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FRobotHeartReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FRobotHeartRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FRobotHeartRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FRobotHeartRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			m.Core = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Core |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			m.Ops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ops |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameCountDown) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameCountDown: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameCountDown: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sce", wireType)
			}
			m.Sce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sce |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GReportMatchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GReportMatchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GReportMatchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMark", wireType)
			}
			m.MaxMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMark |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bullet", wireType)
			}
			m.Bullet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bullet |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportType", wireType)
			}
			m.ReportType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GReportMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GReportMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GReportMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMark", wireType)
			}
			m.MaxMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GReportMatchRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GReportMatchRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GReportMatchRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &GReportMatch{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GGameEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GGameEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GGameEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GGameCountDown) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GGameCountDown: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GGameCountDown: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sce", wireType)
			}
			m.Sce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sce |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameSettlement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameSettlement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameSettlement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipAddition", wireType)
			}
			m.VipAddition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipAddition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeAddition", wireType)
			}
			m.ChallengeAddition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeAddition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurMark", wireType)
			}
			m.CurMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurMark |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMark", wireType)
			}
			m.MaxMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMark |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateKeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateKeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateKeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PReportMatchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PReportMatchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PReportMatchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMark", wireType)
			}
			m.MaxMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PReportMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PReportMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PReportMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMark", wireType)
			}
			m.MaxMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankIdx", wireType)
			}
			m.RankIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PReportMatchRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PReportMatchRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PReportMatchRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &PReportMatch{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PGameEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PGameEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PGameEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FReportMatchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FReportMatchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FReportMatchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			m.Mark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatioChange", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RatioChange = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FReportMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FReportMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FReportMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMark", wireType)
			}
			m.MaxMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankIdx", wireType)
			}
			m.RankIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulletCount", wireType)
			}
			m.BulletCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BulletCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulletTotal", wireType)
			}
			m.BulletTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BulletTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FReportMatchRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FReportMatchRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FReportMatchRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &FReportMatch{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSettlementNotice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSettlementNotice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSettlementNotice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TableId = append(m.TableId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TableId) == 0 {
					m.TableId = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TableId = append(m.TableId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FPlayerResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FPlayerResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FPlayerResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			m.Mark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Award", wireType)
			}
			m.Award = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Award |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FGameEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FGameEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FGameEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TableId = append(m.TableId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TableId) == 0 {
					m.TableId = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TableId = append(m.TableId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerResultList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerResultList = append(m.PlayerResultList, &FPlayerResult{})
			if err := m.PlayerResultList[len(m.PlayerResultList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FRobotNameSynReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FRobotNameSynReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FRobotNameSynReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FRobotNameSynRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FRobotNameSynRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FRobotNameSynRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionWords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SectionWords = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterWords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilterWords = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			m.ContentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delaysec", wireType)
			}
			m.Delaysec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delaysec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AbyGameInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AbyGameInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AbyGameInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameType", wireType)
			}
			m.GameType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardFish) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardFish: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardFish: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptureNum", wireType)
			}
			m.CaptureNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptureNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardTaskGetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardTaskGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardTaskGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardTaskGetRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardTaskGetRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardTaskGetRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			m.Reward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reward |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			m.Clock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Clock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskStatus", wireType)
			}
			m.TaskStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardFish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardFish = append(m.RewardFish, &RewardFish{})
			if err := m.RewardFish[len(m.RewardFish)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardTaskUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardTaskUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardTaskUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			m.Reward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reward |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			m.Clock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Clock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskStatus", wireType)
			}
			m.TaskStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardFish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardFish = append(m.RewardFish, &RewardFish{})
			if err := m.RewardFish[len(m.RewardFish)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportStatusReqV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportStatusReqV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportStatusReqV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthApi
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)
