// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

// package 命名使用 {appid}.{version} 的方式, version 形如 v1, v2 ..

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type MatchDetailReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	Vip                  int32    `protobuf:"varint,3,opt,name=Vip,proto3" json:"Vip" form:"Vip"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchDetailReq) Reset()         { *m = MatchDetailReq{} }
func (m *MatchDetailReq) String() string { return proto.CompactTextString(m) }
func (*MatchDetailReq) ProtoMessage()    {}
func (*MatchDetailReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *MatchDetailReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchDetailReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchDetailReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchDetailReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchDetailReq.Merge(m, src)
}
func (m *MatchDetailReq) XXX_Size() int {
	return m.Size()
}
func (m *MatchDetailReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchDetailReq.DiscardUnknown(m)
}

var xxx_messageInfo_MatchDetailReq proto.InternalMessageInfo

type MatchDetailRsp struct {
	Code                 int32          `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string         `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	MatchList            []*MatchDetail `protobuf:"bytes,3,rep,name=MatchList,proto3" json:"MatchList"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *MatchDetailRsp) Reset()         { *m = MatchDetailRsp{} }
func (m *MatchDetailRsp) String() string { return proto.CompactTextString(m) }
func (*MatchDetailRsp) ProtoMessage()    {}
func (*MatchDetailRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *MatchDetailRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchDetailRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchDetailRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchDetailRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchDetailRsp.Merge(m, src)
}
func (m *MatchDetailRsp) XXX_Size() int {
	return m.Size()
}
func (m *MatchDetailRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchDetailRsp.DiscardUnknown(m)
}

var xxx_messageInfo_MatchDetailRsp proto.InternalMessageInfo

type MatchDetail struct {
	Name                 string            `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	ID                   int32             `protobuf:"varint,2,opt,name=ID,proto3" json:"ID,omitempty"`
	ArenaID              int32             `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID,omitempty"`
	ArenaTimeID          int32             `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID,omitempty"`
	LimitTimes           int32             `protobuf:"varint,5,opt,name=LimitTimes,proto3" json:"LimitTimes,omitempty"`
	Order                int32             `protobuf:"varint,6,opt,name=Order,proto3" json:"Order,omitempty"`
	EnterDeadline        string            `protobuf:"bytes,7,opt,name=EnterDeadline,proto3" json:"EnterDeadline,omitempty"`
	BeginType            *BeginDetail      `protobuf:"bytes,8,opt,name=BeginType,proto3" json:"BeginType,omitempty"`
	EndType              *EndDetail        `protobuf:"bytes,9,opt,name=EndType,proto3" json:"EndType,omitempty"`
	MatchDate            *DateDetail       `protobuf:"bytes,10,opt,name=MatchDate,proto3" json:"MatchDate,omitempty"`
	SignConditon         []*ThingsDetail   `protobuf:"bytes,11,rep,name=SignConditon,proto3" json:"SignConditon,omitempty"`
	SignPay              *PayDetail        `protobuf:"bytes,12,opt,name=SignPay,proto3" json:"SignPay,omitempty"`
	MatchStatus          int32             `protobuf:"varint,13,opt,name=MatchStatus,proto3" json:"MatchStatus,omitempty"`
	DatePropert          string            `protobuf:"bytes,14,opt,name=DatePropert,proto3" json:"DatePropert,omitempty"`
	NextVipRate          int32             `protobuf:"varint,15,opt,name=NextVipRate,proto3" json:"NextVipRate,omitempty"`
	NextTimesRate        int32             `protobuf:"varint,16,opt,name=NextTimesRate,proto3" json:"NextTimesRate,omitempty"`
	WeekRankRewardTime   *RewardTimeDetail `protobuf:"bytes,17,opt,name=WeekRankRewardTime,proto3" json:"WeekRankRewardTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MatchDetail) Reset()         { *m = MatchDetail{} }
func (m *MatchDetail) String() string { return proto.CompactTextString(m) }
func (*MatchDetail) ProtoMessage()    {}
func (*MatchDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *MatchDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchDetail.Merge(m, src)
}
func (m *MatchDetail) XXX_Size() int {
	return m.Size()
}
func (m *MatchDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchDetail.DiscardUnknown(m)
}

var xxx_messageInfo_MatchDetail proto.InternalMessageInfo

type RewardTimeDetail struct {
	RewardDay            int32    `protobuf:"varint,1,opt,name=RewardDay,proto3" json:"RewardDay,omitempty"`
	RewardTime           string   `protobuf:"bytes,2,opt,name=RewardTime,proto3" json:"RewardTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RewardTimeDetail) Reset()         { *m = RewardTimeDetail{} }
func (m *RewardTimeDetail) String() string { return proto.CompactTextString(m) }
func (*RewardTimeDetail) ProtoMessage()    {}
func (*RewardTimeDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *RewardTimeDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardTimeDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardTimeDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardTimeDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardTimeDetail.Merge(m, src)
}
func (m *RewardTimeDetail) XXX_Size() int {
	return m.Size()
}
func (m *RewardTimeDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardTimeDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RewardTimeDetail proto.InternalMessageInfo

type BeginDetail struct {
	BeginType            string   `protobuf:"bytes,1,opt,name=BeginType,proto3" json:"BeginType,omitempty"`
	FullNums             int32    `protobuf:"varint,2,opt,name=FullNums,proto3" json:"FullNums,omitempty"`
	StartTime            string   `protobuf:"bytes,3,opt,name=StartTime,proto3" json:"StartTime,omitempty"`
	CycleRate            int32    `protobuf:"varint,4,opt,name=CycleRate,proto3" json:"CycleRate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BeginDetail) Reset()         { *m = BeginDetail{} }
func (m *BeginDetail) String() string { return proto.CompactTextString(m) }
func (*BeginDetail) ProtoMessage()    {}
func (*BeginDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *BeginDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeginDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeginDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeginDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeginDetail.Merge(m, src)
}
func (m *BeginDetail) XXX_Size() int {
	return m.Size()
}
func (m *BeginDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_BeginDetail.DiscardUnknown(m)
}

var xxx_messageInfo_BeginDetail proto.InternalMessageInfo

type EndDetail struct {
	EndType              string   `protobuf:"bytes,1,opt,name=EndType,proto3" json:"EndType,omitempty"`
	EndTime              string   `protobuf:"bytes,2,opt,name=EndTime,proto3" json:"EndTime,omitempty"`
	EndTotal             int32    `protobuf:"varint,3,opt,name=EndTotal,proto3" json:"EndTotal,omitempty"`
	LimitTime            int32    `protobuf:"varint,4,opt,name=LimitTime,proto3" json:"LimitTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EndDetail) Reset()         { *m = EndDetail{} }
func (m *EndDetail) String() string { return proto.CompactTextString(m) }
func (*EndDetail) ProtoMessage()    {}
func (*EndDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *EndDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EndDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EndDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndDetail.Merge(m, src)
}
func (m *EndDetail) XXX_Size() int {
	return m.Size()
}
func (m *EndDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_EndDetail.DiscardUnknown(m)
}

var xxx_messageInfo_EndDetail proto.InternalMessageInfo

type DateDetail struct {
	Week                 []int32  `protobuf:"varint,1,rep,packed,name=Week,proto3" json:"Week,omitempty"`
	Month                []int32  `protobuf:"varint,2,rep,packed,name=Month,proto3" json:"Month,omitempty"`
	Day                  []int32  `protobuf:"varint,3,rep,packed,name=Day,proto3" json:"Day,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DateDetail) Reset()         { *m = DateDetail{} }
func (m *DateDetail) String() string { return proto.CompactTextString(m) }
func (*DateDetail) ProtoMessage()    {}
func (*DateDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *DateDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DateDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DateDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DateDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DateDetail.Merge(m, src)
}
func (m *DateDetail) XXX_Size() int {
	return m.Size()
}
func (m *DateDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_DateDetail.DiscardUnknown(m)
}

var xxx_messageInfo_DateDetail proto.InternalMessageInfo

type PayDetail struct {
	MatchTimes           int32           `protobuf:"varint,1,opt,name=MatchTimes,proto3" json:"MatchTimes,omitempty"`
	Pay                  []*ThingsDetail `protobuf:"bytes,2,rep,name=Pay,proto3" json:"Pay,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PayDetail) Reset()         { *m = PayDetail{} }
func (m *PayDetail) String() string { return proto.CompactTextString(m) }
func (*PayDetail) ProtoMessage()    {}
func (*PayDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *PayDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayDetail.Merge(m, src)
}
func (m *PayDetail) XXX_Size() int {
	return m.Size()
}
func (m *PayDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_PayDetail.DiscardUnknown(m)
}

var xxx_messageInfo_PayDetail proto.InternalMessageInfo

type ThingsDetail struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Num                  int64    `protobuf:"varint,2,opt,name=num,proto3" json:"num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ThingsDetail) Reset()         { *m = ThingsDetail{} }
func (m *ThingsDetail) String() string { return proto.CompactTextString(m) }
func (*ThingsDetail) ProtoMessage()    {}
func (*ThingsDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *ThingsDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThingsDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThingsDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThingsDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThingsDetail.Merge(m, src)
}
func (m *ThingsDetail) XXX_Size() int {
	return m.Size()
}
func (m *ThingsDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_ThingsDetail.DiscardUnknown(m)
}

var xxx_messageInfo_ThingsDetail proto.InternalMessageInfo

type ChessSumReq struct {
	GameID               int32          `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32          `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32          `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	UserList             []*UserDetails `protobuf:"bytes,4,rep,name=UserList,proto3" json:"UserList" form:"UserList" validate:"required"`
	BetAmount            int64          `protobuf:"varint,5,opt,name=BetAmount,proto3" json:"BetAmount" form:"BetAmount" validate:"required"`
	ArenaTimeID          int32          `protobuf:"varint,6,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ChessSumReq) Reset()         { *m = ChessSumReq{} }
func (m *ChessSumReq) String() string { return proto.CompactTextString(m) }
func (*ChessSumReq) ProtoMessage()    {}
func (*ChessSumReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *ChessSumReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChessSumReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChessSumReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChessSumReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChessSumReq.Merge(m, src)
}
func (m *ChessSumReq) XXX_Size() int {
	return m.Size()
}
func (m *ChessSumReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ChessSumReq.DiscardUnknown(m)
}

var xxx_messageInfo_ChessSumReq proto.InternalMessageInfo

type UserDetails struct {
	UserID               int64    `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	Score                int64    `protobuf:"varint,2,opt,name=Score,proto3" json:"Score" form:"Score" validate:"required"`
	Vip                  int32    `protobuf:"varint,3,opt,name=Vip,proto3" json:"Vip" form:"Vip" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserDetails) Reset()         { *m = UserDetails{} }
func (m *UserDetails) String() string { return proto.CompactTextString(m) }
func (*UserDetails) ProtoMessage()    {}
func (*UserDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *UserDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserDetails.Merge(m, src)
}
func (m *UserDetails) XXX_Size() int {
	return m.Size()
}
func (m *UserDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_UserDetails.DiscardUnknown(m)
}

var xxx_messageInfo_UserDetails proto.InternalMessageInfo

type CommonRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonRsp) Reset()         { *m = CommonRsp{} }
func (m *CommonRsp) String() string { return proto.CompactTextString(m) }
func (*CommonRsp) ProtoMessage()    {}
func (*CommonRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *CommonRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonRsp.Merge(m, src)
}
func (m *CommonRsp) XXX_Size() int {
	return m.Size()
}
func (m *CommonRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CommonRsp proto.InternalMessageInfo

type DayRankReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	BeforeDay            int32    `protobuf:"varint,4,opt,name=BeforeDay,proto3" json:"BeforeDay" form:"BeforeDay"`
	EndRankPoint         int64    `protobuf:"varint,5,opt,name=EndRankPoint,proto3" json:"EndRankPoint" form:"EndRankPoint"`
	UserID               int64    `protobuf:"varint,6,opt,name=UserID,proto3" json:"UserID" form:"UserID" `
	ArenaTimeID          int32    `protobuf:"varint,7,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DayRankReq) Reset()         { *m = DayRankReq{} }
func (m *DayRankReq) String() string { return proto.CompactTextString(m) }
func (*DayRankReq) ProtoMessage()    {}
func (*DayRankReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *DayRankReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DayRankReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DayRankReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DayRankReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DayRankReq.Merge(m, src)
}
func (m *DayRankReq) XXX_Size() int {
	return m.Size()
}
func (m *DayRankReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DayRankReq.DiscardUnknown(m)
}

var xxx_messageInfo_DayRankReq proto.InternalMessageInfo

type DayRankRsp struct {
	Code                 int32         `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string        `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	SelfRank             int64         `protobuf:"varint,3,opt,name=SelfRank,proto3" json:"SelfRank,omitempty"`
	SelfRankScore        int64         `protobuf:"varint,4,opt,name=SelfRankScore,proto3" json:"SelfRankScore,omitempty"`
	DayRankList          []*RankDetail `protobuf:"bytes,5,rep,name=DayRankList,proto3" json:"DayRankList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DayRankRsp) Reset()         { *m = DayRankRsp{} }
func (m *DayRankRsp) String() string { return proto.CompactTextString(m) }
func (*DayRankRsp) ProtoMessage()    {}
func (*DayRankRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *DayRankRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DayRankRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DayRankRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DayRankRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DayRankRsp.Merge(m, src)
}
func (m *DayRankRsp) XXX_Size() int {
	return m.Size()
}
func (m *DayRankRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_DayRankRsp.DiscardUnknown(m)
}

var xxx_messageInfo_DayRankRsp proto.InternalMessageInfo

type CatchDayRankReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	UserID               int64    `protobuf:"varint,5,opt,name=UserID,proto3" json:"UserID" form:"UserID" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatchDayRankReq) Reset()         { *m = CatchDayRankReq{} }
func (m *CatchDayRankReq) String() string { return proto.CompactTextString(m) }
func (*CatchDayRankReq) ProtoMessage()    {}
func (*CatchDayRankReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *CatchDayRankReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatchDayRankReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CatchDayRankReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CatchDayRankReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatchDayRankReq.Merge(m, src)
}
func (m *CatchDayRankReq) XXX_Size() int {
	return m.Size()
}
func (m *CatchDayRankReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CatchDayRankReq.DiscardUnknown(m)
}

var xxx_messageInfo_CatchDayRankReq proto.InternalMessageInfo

type CatchDayRankRsp struct {
	Code                 int32              `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string             `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	SelfRank             int64              `protobuf:"varint,3,opt,name=SelfRank,proto3" json:"SelfRank,omitempty"`
	SelfRankScore        int64              `protobuf:"varint,4,opt,name=SelfRankScore,proto3" json:"SelfRankScore,omitempty"`
	DayRankList          []*CatchRankDetail `protobuf:"bytes,5,rep,name=DayRankList,proto3" json:"DayRankList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *CatchDayRankRsp) Reset()         { *m = CatchDayRankRsp{} }
func (m *CatchDayRankRsp) String() string { return proto.CompactTextString(m) }
func (*CatchDayRankRsp) ProtoMessage()    {}
func (*CatchDayRankRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *CatchDayRankRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatchDayRankRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CatchDayRankRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CatchDayRankRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatchDayRankRsp.Merge(m, src)
}
func (m *CatchDayRankRsp) XXX_Size() int {
	return m.Size()
}
func (m *CatchDayRankRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CatchDayRankRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CatchDayRankRsp proto.InternalMessageInfo

type WeekRankReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	WeekBefore           int32    `protobuf:"varint,3,opt,name=WeekBefore,proto3" json:"WeekBefore" form:"WeekBefore" `
	ArenaID              int32    `protobuf:"varint,4,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	EndRankPoint         int64    `protobuf:"varint,5,opt,name=EndRankPoint,proto3" json:"EndRankPoint" form:"EndRankPoint"`
	UserID               int64    `protobuf:"varint,6,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	ArenaTimeID          int32    `protobuf:"varint,7,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WeekRankReq) Reset()         { *m = WeekRankReq{} }
func (m *WeekRankReq) String() string { return proto.CompactTextString(m) }
func (*WeekRankReq) ProtoMessage()    {}
func (*WeekRankReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *WeekRankReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeekRankReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeekRankReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeekRankReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeekRankReq.Merge(m, src)
}
func (m *WeekRankReq) XXX_Size() int {
	return m.Size()
}
func (m *WeekRankReq) XXX_DiscardUnknown() {
	xxx_messageInfo_WeekRankReq.DiscardUnknown(m)
}

var xxx_messageInfo_WeekRankReq proto.InternalMessageInfo

type WeekRankRsp struct {
	Code                 int32         `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string        `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	SelfRank             int64         `protobuf:"varint,3,opt,name=SelfRank,proto3" json:"SelfRank,omitempty"`
	SelfRankScore        int64         `protobuf:"varint,4,opt,name=SelfRankScore,proto3" json:"SelfRankScore,omitempty"`
	WeekRankList         []*RankDetail `protobuf:"bytes,5,rep,name=WeekRankList,proto3" json:"WeekRankList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *WeekRankRsp) Reset()         { *m = WeekRankRsp{} }
func (m *WeekRankRsp) String() string { return proto.CompactTextString(m) }
func (*WeekRankRsp) ProtoMessage()    {}
func (*WeekRankRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *WeekRankRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeekRankRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeekRankRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeekRankRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeekRankRsp.Merge(m, src)
}
func (m *WeekRankRsp) XXX_Size() int {
	return m.Size()
}
func (m *WeekRankRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_WeekRankRsp.DiscardUnknown(m)
}

var xxx_messageInfo_WeekRankRsp proto.InternalMessageInfo

type RankDetail struct {
	UserID               int64           `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	RankScore            int64           `protobuf:"varint,2,opt,name=RankScore,proto3" json:"RankScore,omitempty"`
	Rank                 int32           `protobuf:"varint,3,opt,name=Rank,proto3" json:"Rank,omitempty"`
	RankRewardList       []*ThingsDetail `protobuf:"bytes,4,rep,name=RankRewardList,proto3" json:"RankRewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RankDetail) Reset()         { *m = RankDetail{} }
func (m *RankDetail) String() string { return proto.CompactTextString(m) }
func (*RankDetail) ProtoMessage()    {}
func (*RankDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{18}
}
func (m *RankDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankDetail.Merge(m, src)
}
func (m *RankDetail) XXX_Size() int {
	return m.Size()
}
func (m *RankDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RankDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RankDetail proto.InternalMessageInfo

type CatchRankDetail struct {
	Rank                 []int32         `protobuf:"varint,1,rep,packed,name=Rank,proto3" json:"Rank,omitempty"`
	FinalUserID          int64           `protobuf:"varint,2,opt,name=FinalUserID,proto3" json:"FinalUserID,omitempty"`
	FinalScore           int64           `protobuf:"varint,3,opt,name=FinalScore,proto3" json:"FinalScore,omitempty"`
	RankRewardList       []*ThingsDetail `protobuf:"bytes,4,rep,name=RankRewardList,proto3" json:"RankRewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CatchRankDetail) Reset()         { *m = CatchRankDetail{} }
func (m *CatchRankDetail) String() string { return proto.CompactTextString(m) }
func (*CatchRankDetail) ProtoMessage()    {}
func (*CatchRankDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{19}
}
func (m *CatchRankDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatchRankDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CatchRankDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CatchRankDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatchRankDetail.Merge(m, src)
}
func (m *CatchRankDetail) XXX_Size() int {
	return m.Size()
}
func (m *CatchRankDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_CatchRankDetail.DiscardUnknown(m)
}

var xxx_messageInfo_CatchRankDetail proto.InternalMessageInfo

type CommonReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	UserID               int64    `protobuf:"varint,4,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	ArenaTimeID          int32    `protobuf:"varint,5,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonReq) Reset()         { *m = CommonReq{} }
func (m *CommonReq) String() string { return proto.CompactTextString(m) }
func (*CommonReq) ProtoMessage()    {}
func (*CommonReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{20}
}
func (m *CommonReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonReq.Merge(m, src)
}
func (m *CommonReq) XXX_Size() int {
	return m.Size()
}
func (m *CommonReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonReq.DiscardUnknown(m)
}

var xxx_messageInfo_CommonReq proto.InternalMessageInfo

type RankRewardReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	RewardID             string   `protobuf:"bytes,3,opt,name=RewardID,proto3" json:"RewardID" form:"RewardID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RankRewardReq) Reset()         { *m = RankRewardReq{} }
func (m *RankRewardReq) String() string { return proto.CompactTextString(m) }
func (*RankRewardReq) ProtoMessage()    {}
func (*RankRewardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{21}
}
func (m *RankRewardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankRewardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankRewardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankRewardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankRewardReq.Merge(m, src)
}
func (m *RankRewardReq) XXX_Size() int {
	return m.Size()
}
func (m *RankRewardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RankRewardReq.DiscardUnknown(m)
}

var xxx_messageInfo_RankRewardReq proto.InternalMessageInfo

type RankRewardRsp struct {
	Code                 int32           `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string          `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	RewardList           []*ThingsDetail `protobuf:"bytes,3,rep,name=RewardList,proto3" json:"RewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RankRewardRsp) Reset()         { *m = RankRewardRsp{} }
func (m *RankRewardRsp) String() string { return proto.CompactTextString(m) }
func (*RankRewardRsp) ProtoMessage()    {}
func (*RankRewardRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{22}
}
func (m *RankRewardRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankRewardRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankRewardRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankRewardRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankRewardRsp.Merge(m, src)
}
func (m *RankRewardRsp) XXX_Size() int {
	return m.Size()
}
func (m *RankRewardRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RankRewardRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RankRewardRsp proto.InternalMessageInfo

type MatchSignReq struct {
	GameID               int32           `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32           `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32           `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32           `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	UserID               int64           `protobuf:"varint,5,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	SignThinsList        []*ThingsDetail `protobuf:"bytes,6,rep,name=SignThinsList,proto3" json:"SignThinsList" form:"SignThinsList" `
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MatchSignReq) Reset()         { *m = MatchSignReq{} }
func (m *MatchSignReq) String() string { return proto.CompactTextString(m) }
func (*MatchSignReq) ProtoMessage()    {}
func (*MatchSignReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{23}
}
func (m *MatchSignReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchSignReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchSignReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchSignReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchSignReq.Merge(m, src)
}
func (m *MatchSignReq) XXX_Size() int {
	return m.Size()
}
func (m *MatchSignReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchSignReq.DiscardUnknown(m)
}

var xxx_messageInfo_MatchSignReq proto.InternalMessageInfo

type MatchSignRsp struct {
	Code                 int32           `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string          `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	CostList             []*ThingsDetail `protobuf:"bytes,3,rep,name=CostList,proto3" json:"CostList,omitempty"`
	Join                 bool            `protobuf:"varint,4,opt,name=Join,proto3" json:"Join,omitempty"`
	MatchSignCount       int32           `protobuf:"varint,5,opt,name=MatchSignCount,proto3" json:"MatchSignCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MatchSignRsp) Reset()         { *m = MatchSignRsp{} }
func (m *MatchSignRsp) String() string { return proto.CompactTextString(m) }
func (*MatchSignRsp) ProtoMessage()    {}
func (*MatchSignRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{24}
}
func (m *MatchSignRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchSignRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchSignRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchSignRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchSignRsp.Merge(m, src)
}
func (m *MatchSignRsp) XXX_Size() int {
	return m.Size()
}
func (m *MatchSignRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchSignRsp.DiscardUnknown(m)
}

var xxx_messageInfo_MatchSignRsp proto.InternalMessageInfo

type CatchSumReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	UserID               int64    `protobuf:"varint,3,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	Score                int64    `protobuf:"varint,4,opt,name=Score,proto3" json:"Score" form:"Score" validate:"required"`
	Vip                  int32    `protobuf:"varint,5,opt,name=Vip,proto3" json:"Vip" form:"Vip"`
	ArenaID              int32    `protobuf:"varint,6,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,7,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatchSumReq) Reset()         { *m = CatchSumReq{} }
func (m *CatchSumReq) String() string { return proto.CompactTextString(m) }
func (*CatchSumReq) ProtoMessage()    {}
func (*CatchSumReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{25}
}
func (m *CatchSumReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatchSumReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CatchSumReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CatchSumReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatchSumReq.Merge(m, src)
}
func (m *CatchSumReq) XXX_Size() int {
	return m.Size()
}
func (m *CatchSumReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CatchSumReq.DiscardUnknown(m)
}

var xxx_messageInfo_CatchSumReq proto.InternalMessageInfo

type CatchSumRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	CurScore             int64    `protobuf:"varint,3,opt,name=CurScore,proto3" json:"CurScore,omitempty"`
	MaxScore             int64    `protobuf:"varint,4,opt,name=MaxScore,proto3" json:"MaxScore,omitempty"`
	Rank                 int64    `protobuf:"varint,5,opt,name=Rank,proto3" json:"Rank,omitempty"`
	RankTotal            int64    `protobuf:"varint,6,opt,name=RankTotal,proto3" json:"RankTotal,omitempty"`
	VipAddRate           int32    `protobuf:"varint,7,opt,name=VipAddRate,proto3" json:"VipAddRate,omitempty"`
	TimesAddRate         int32    `protobuf:"varint,8,opt,name=TimesAddRate,proto3" json:"TimesAddRate,omitempty"`
	NextTimesAddRate     int32    `protobuf:"varint,9,opt,name=NextTimesAddRate,proto3" json:"NextTimesAddRate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatchSumRsp) Reset()         { *m = CatchSumRsp{} }
func (m *CatchSumRsp) String() string { return proto.CompactTextString(m) }
func (*CatchSumRsp) ProtoMessage()    {}
func (*CatchSumRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{26}
}
func (m *CatchSumRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatchSumRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CatchSumRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CatchSumRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatchSumRsp.Merge(m, src)
}
func (m *CatchSumRsp) XXX_Size() int {
	return m.Size()
}
func (m *CatchSumRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CatchSumRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CatchSumRsp proto.InternalMessageInfo

type WeekResultReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	UserID               int64    `protobuf:"varint,4,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	ArenaTimeID          int32    `protobuf:"varint,5,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WeekResultReq) Reset()         { *m = WeekResultReq{} }
func (m *WeekResultReq) String() string { return proto.CompactTextString(m) }
func (*WeekResultReq) ProtoMessage()    {}
func (*WeekResultReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{27}
}
func (m *WeekResultReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeekResultReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeekResultReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeekResultReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeekResultReq.Merge(m, src)
}
func (m *WeekResultReq) XXX_Size() int {
	return m.Size()
}
func (m *WeekResultReq) XXX_DiscardUnknown() {
	xxx_messageInfo_WeekResultReq.DiscardUnknown(m)
}

var xxx_messageInfo_WeekResultReq proto.InternalMessageInfo

type WeekResultRsp struct {
	Code                 int32             `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string            `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	WeekScore            int64             `protobuf:"varint,3,opt,name=WeekScore,proto3" json:"WeekScore,omitempty"`
	WeekRank             int64             `protobuf:"varint,4,opt,name=WeekRank,proto3" json:"WeekRank,omitempty"`
	UserRankList         []*UserRankDetail `protobuf:"bytes,5,rep,name=UserRankList,proto3" json:"UserRankList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *WeekResultRsp) Reset()         { *m = WeekResultRsp{} }
func (m *WeekResultRsp) String() string { return proto.CompactTextString(m) }
func (*WeekResultRsp) ProtoMessage()    {}
func (*WeekResultRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{28}
}
func (m *WeekResultRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeekResultRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeekResultRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeekResultRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeekResultRsp.Merge(m, src)
}
func (m *WeekResultRsp) XXX_Size() int {
	return m.Size()
}
func (m *WeekResultRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_WeekResultRsp.DiscardUnknown(m)
}

var xxx_messageInfo_WeekResultRsp proto.InternalMessageInfo

type UserRankDetail struct {
	RankDay              int32    `protobuf:"varint,1,opt,name=RankDay,proto3" json:"RankDay,omitempty"`
	RankScore            int64    `protobuf:"varint,2,opt,name=RankScore,proto3" json:"RankScore,omitempty"`
	RankRanking          int64    `protobuf:"varint,3,opt,name=RankRanking,proto3" json:"RankRanking,omitempty"`
	RankStatus           int32    `protobuf:"varint,4,opt,name=RankStatus,proto3" json:"RankStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserRankDetail) Reset()         { *m = UserRankDetail{} }
func (m *UserRankDetail) String() string { return proto.CompactTextString(m) }
func (*UserRankDetail) ProtoMessage()    {}
func (*UserRankDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{29}
}
func (m *UserRankDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRankDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRankDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRankDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRankDetail.Merge(m, src)
}
func (m *UserRankDetail) XXX_Size() int {
	return m.Size()
}
func (m *UserRankDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRankDetail.DiscardUnknown(m)
}

var xxx_messageInfo_UserRankDetail proto.InternalMessageInfo

type UserRankRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Rank                 int64    `protobuf:"varint,3,opt,name=Rank,proto3" json:"Rank,omitempty"`
	RankScore            int64    `protobuf:"varint,4,opt,name=RankScore,proto3" json:"RankScore,omitempty"`
	RankTotal            int64    `protobuf:"varint,5,opt,name=RankTotal,proto3" json:"RankTotal,omitempty"`
	DifScore             int64    `protobuf:"varint,6,opt,name=DifScore,proto3" json:"DifScore,omitempty"`
	WeekSumScore         int64    `protobuf:"varint,7,opt,name=WeekSumScore,proto3" json:"WeekSumScore,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserRankRsp) Reset()         { *m = UserRankRsp{} }
func (m *UserRankRsp) String() string { return proto.CompactTextString(m) }
func (*UserRankRsp) ProtoMessage()    {}
func (*UserRankRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{30}
}
func (m *UserRankRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRankRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRankRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRankRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRankRsp.Merge(m, src)
}
func (m *UserRankRsp) XXX_Size() int {
	return m.Size()
}
func (m *UserRankRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRankRsp.DiscardUnknown(m)
}

var xxx_messageInfo_UserRankRsp proto.InternalMessageInfo

type MatchEndReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchEndReq) Reset()         { *m = MatchEndReq{} }
func (m *MatchEndReq) String() string { return proto.CompactTextString(m) }
func (*MatchEndReq) ProtoMessage()    {}
func (*MatchEndReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{31}
}
func (m *MatchEndReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchEndReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchEndReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchEndReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchEndReq.Merge(m, src)
}
func (m *MatchEndReq) XXX_Size() int {
	return m.Size()
}
func (m *MatchEndReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchEndReq.DiscardUnknown(m)
}

var xxx_messageInfo_MatchEndReq proto.InternalMessageInfo

type WeekRewardReportReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WeekRewardReportReq) Reset()         { *m = WeekRewardReportReq{} }
func (m *WeekRewardReportReq) String() string { return proto.CompactTextString(m) }
func (*WeekRewardReportReq) ProtoMessage()    {}
func (*WeekRewardReportReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{32}
}
func (m *WeekRewardReportReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeekRewardReportReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeekRewardReportReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeekRewardReportReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeekRewardReportReq.Merge(m, src)
}
func (m *WeekRewardReportReq) XXX_Size() int {
	return m.Size()
}
func (m *WeekRewardReportReq) XXX_DiscardUnknown() {
	xxx_messageInfo_WeekRewardReportReq.DiscardUnknown(m)
}

var xxx_messageInfo_WeekRewardReportReq proto.InternalMessageInfo

type UserRewardReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserRewardReq) Reset()         { *m = UserRewardReq{} }
func (m *UserRewardReq) String() string { return proto.CompactTextString(m) }
func (*UserRewardReq) ProtoMessage()    {}
func (*UserRewardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{33}
}
func (m *UserRewardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRewardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRewardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRewardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRewardReq.Merge(m, src)
}
func (m *UserRewardReq) XXX_Size() int {
	return m.Size()
}
func (m *UserRewardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRewardReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserRewardReq proto.InternalMessageInfo

type UserRewardRsp struct {
	Code                 int32           `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string          `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	RewardList           []*RewardDetail `protobuf:"bytes,3,rep,name=RewardList,proto3" json:"RewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UserRewardRsp) Reset()         { *m = UserRewardRsp{} }
func (m *UserRewardRsp) String() string { return proto.CompactTextString(m) }
func (*UserRewardRsp) ProtoMessage()    {}
func (*UserRewardRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{34}
}
func (m *UserRewardRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRewardRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRewardRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRewardRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRewardRsp.Merge(m, src)
}
func (m *UserRewardRsp) XXX_Size() int {
	return m.Size()
}
func (m *UserRewardRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRewardRsp.DiscardUnknown(m)
}

var xxx_messageInfo_UserRewardRsp proto.InternalMessageInfo

type RewardDetail struct {
	MatchID              int32           `protobuf:"varint,1,opt,name=MatchID,proto3" json:"MatchID,omitempty"`
	RewardID             string          `protobuf:"bytes,2,opt,name=RewardID,proto3" json:"RewardID,omitempty"`
	Rank                 int64           `protobuf:"varint,3,opt,name=Rank,proto3" json:"Rank,omitempty"`
	RankScore            int64           `protobuf:"varint,4,opt,name=RankScore,proto3" json:"RankScore,omitempty"`
	RewardTime           string          `protobuf:"bytes,5,opt,name=RewardTime,proto3" json:"RewardTime,omitempty"`
	ThingsList           []*ThingsDetail `protobuf:"bytes,6,rep,name=ThingsList,proto3" json:"ThingsList,omitempty"`
	ArenaID              int32           `protobuf:"varint,7,opt,name=ArenaID,proto3" json:"ArenaID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RewardDetail) Reset()         { *m = RewardDetail{} }
func (m *RewardDetail) String() string { return proto.CompactTextString(m) }
func (*RewardDetail) ProtoMessage()    {}
func (*RewardDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{35}
}
func (m *RewardDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardDetail.Merge(m, src)
}
func (m *RewardDetail) XXX_Size() int {
	return m.Size()
}
func (m *RewardDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RewardDetail proto.InternalMessageInfo

type FloatBonusPoolReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FloatBonusPoolReq) Reset()         { *m = FloatBonusPoolReq{} }
func (m *FloatBonusPoolReq) String() string { return proto.CompactTextString(m) }
func (*FloatBonusPoolReq) ProtoMessage()    {}
func (*FloatBonusPoolReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{36}
}
func (m *FloatBonusPoolReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FloatBonusPoolReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FloatBonusPoolReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FloatBonusPoolReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatBonusPoolReq.Merge(m, src)
}
func (m *FloatBonusPoolReq) XXX_Size() int {
	return m.Size()
}
func (m *FloatBonusPoolReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatBonusPoolReq.DiscardUnknown(m)
}

var xxx_messageInfo_FloatBonusPoolReq proto.InternalMessageInfo

type FloatBonusPoolRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	BonusPoolNum         int64    `protobuf:"varint,3,opt,name=BonusPoolNum,proto3" json:"BonusPoolNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FloatBonusPoolRsp) Reset()         { *m = FloatBonusPoolRsp{} }
func (m *FloatBonusPoolRsp) String() string { return proto.CompactTextString(m) }
func (*FloatBonusPoolRsp) ProtoMessage()    {}
func (*FloatBonusPoolRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{37}
}
func (m *FloatBonusPoolRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FloatBonusPoolRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FloatBonusPoolRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FloatBonusPoolRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatBonusPoolRsp.Merge(m, src)
}
func (m *FloatBonusPoolRsp) XXX_Size() int {
	return m.Size()
}
func (m *FloatBonusPoolRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatBonusPoolRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FloatBonusPoolRsp proto.InternalMessageInfo

type FamousHallReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FamousHallReq) Reset()         { *m = FamousHallReq{} }
func (m *FamousHallReq) String() string { return proto.CompactTextString(m) }
func (*FamousHallReq) ProtoMessage()    {}
func (*FamousHallReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{38}
}
func (m *FamousHallReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FamousHallReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FamousHallReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FamousHallReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FamousHallReq.Merge(m, src)
}
func (m *FamousHallReq) XXX_Size() int {
	return m.Size()
}
func (m *FamousHallReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FamousHallReq.DiscardUnknown(m)
}

var xxx_messageInfo_FamousHallReq proto.InternalMessageInfo

type FamousHallRsp struct {
	Code                 int32             `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string            `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	ChampionList         []*ChampionDetail `protobuf:"bytes,3,rep,name=ChampionList,proto3" json:"ChampionList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FamousHallRsp) Reset()         { *m = FamousHallRsp{} }
func (m *FamousHallRsp) String() string { return proto.CompactTextString(m) }
func (*FamousHallRsp) ProtoMessage()    {}
func (*FamousHallRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{39}
}
func (m *FamousHallRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FamousHallRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FamousHallRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FamousHallRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FamousHallRsp.Merge(m, src)
}
func (m *FamousHallRsp) XXX_Size() int {
	return m.Size()
}
func (m *FamousHallRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FamousHallRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FamousHallRsp proto.InternalMessageInfo

type ChampionDetail struct {
	UserID               int64    `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	BeginDate            string   `protobuf:"bytes,2,opt,name=BeginDate,proto3" json:"BeginDate,omitempty"`
	EndDate              string   `protobuf:"bytes,3,opt,name=EndDate,proto3" json:"EndDate,omitempty"`
	RankScore            int64    `protobuf:"varint,4,opt,name=RankScore,proto3" json:"RankScore,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChampionDetail) Reset()         { *m = ChampionDetail{} }
func (m *ChampionDetail) String() string { return proto.CompactTextString(m) }
func (*ChampionDetail) ProtoMessage()    {}
func (*ChampionDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{40}
}
func (m *ChampionDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChampionDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChampionDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChampionDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChampionDetail.Merge(m, src)
}
func (m *ChampionDetail) XXX_Size() int {
	return m.Size()
}
func (m *ChampionDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_ChampionDetail.DiscardUnknown(m)
}

var xxx_messageInfo_ChampionDetail proto.InternalMessageInfo

type RewardListReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	RewardType           string   `protobuf:"bytes,2,opt,name=RewardType,proto3" json:"RewardType" form:"RewardType" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RewardListReq) Reset()         { *m = RewardListReq{} }
func (m *RewardListReq) String() string { return proto.CompactTextString(m) }
func (*RewardListReq) ProtoMessage()    {}
func (*RewardListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{41}
}
func (m *RewardListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardListReq.Merge(m, src)
}
func (m *RewardListReq) XXX_Size() int {
	return m.Size()
}
func (m *RewardListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardListReq.DiscardUnknown(m)
}

var xxx_messageInfo_RewardListReq proto.InternalMessageInfo

type RewardListRsp struct {
	Code                 int32                `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string               `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	MatchRewardList      []*MatchRewardDetail `protobuf:"bytes,3,rep,name=MatchRewardList,proto3" json:"MatchRewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *RewardListRsp) Reset()         { *m = RewardListRsp{} }
func (m *RewardListRsp) String() string { return proto.CompactTextString(m) }
func (*RewardListRsp) ProtoMessage()    {}
func (*RewardListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{42}
}
func (m *RewardListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardListRsp.Merge(m, src)
}
func (m *RewardListRsp) XXX_Size() int {
	return m.Size()
}
func (m *RewardListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RewardListRsp proto.InternalMessageInfo

type MatchRewardDetail struct {
	MatchID              int32               `protobuf:"varint,1,opt,name=MatchID,proto3" json:"MatchID,omitempty"`
	ArenaID              int32               `protobuf:"varint,2,opt,name=ArenaID,proto3" json:"ArenaID,omitempty"`
	ArenaTimeID          int32               `protobuf:"varint,3,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID,omitempty"`
	RewardList           []*RankRewardDetail `protobuf:"bytes,4,rep,name=RewardList,proto3" json:"RewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *MatchRewardDetail) Reset()         { *m = MatchRewardDetail{} }
func (m *MatchRewardDetail) String() string { return proto.CompactTextString(m) }
func (*MatchRewardDetail) ProtoMessage()    {}
func (*MatchRewardDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{43}
}
func (m *MatchRewardDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchRewardDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchRewardDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchRewardDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchRewardDetail.Merge(m, src)
}
func (m *MatchRewardDetail) XXX_Size() int {
	return m.Size()
}
func (m *MatchRewardDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchRewardDetail.DiscardUnknown(m)
}

var xxx_messageInfo_MatchRewardDetail proto.InternalMessageInfo

type RankRewardDetail struct {
	Rank                 []int32         `protobuf:"varint,1,rep,packed,name=Rank,proto3" json:"Rank,omitempty"`
	ThingsList           []*ThingsDetail `protobuf:"bytes,2,rep,name=ThingsList,proto3" json:"ThingsList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RankRewardDetail) Reset()         { *m = RankRewardDetail{} }
func (m *RankRewardDetail) String() string { return proto.CompactTextString(m) }
func (*RankRewardDetail) ProtoMessage()    {}
func (*RankRewardDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{44}
}
func (m *RankRewardDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankRewardDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankRewardDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankRewardDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankRewardDetail.Merge(m, src)
}
func (m *RankRewardDetail) XXX_Size() int {
	return m.Size()
}
func (m *RankRewardDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RankRewardDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RankRewardDetail proto.InternalMessageInfo

type MatchStatusReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchStatusReq) Reset()         { *m = MatchStatusReq{} }
func (m *MatchStatusReq) String() string { return proto.CompactTextString(m) }
func (*MatchStatusReq) ProtoMessage()    {}
func (*MatchStatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{45}
}
func (m *MatchStatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchStatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchStatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchStatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchStatusReq.Merge(m, src)
}
func (m *MatchStatusReq) XXX_Size() int {
	return m.Size()
}
func (m *MatchStatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchStatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_MatchStatusReq proto.InternalMessageInfo

type MatchStatusRsp struct {
	Code                 int32                `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string               `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	MatchStatusList      []*MatchStatusDetail `protobuf:"bytes,3,rep,name=MatchStatusList,proto3" json:"MatchStatusList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *MatchStatusRsp) Reset()         { *m = MatchStatusRsp{} }
func (m *MatchStatusRsp) String() string { return proto.CompactTextString(m) }
func (*MatchStatusRsp) ProtoMessage()    {}
func (*MatchStatusRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{46}
}
func (m *MatchStatusRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchStatusRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchStatusRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchStatusRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchStatusRsp.Merge(m, src)
}
func (m *MatchStatusRsp) XXX_Size() int {
	return m.Size()
}
func (m *MatchStatusRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchStatusRsp.DiscardUnknown(m)
}

var xxx_messageInfo_MatchStatusRsp proto.InternalMessageInfo

type MatchStatusDetail struct {
	MatchID              int32             `protobuf:"varint,1,opt,name=MatchID,proto3" json:"MatchID,omitempty"`
	ArenaID              int32             `protobuf:"varint,2,opt,name=ArenaID,proto3" json:"ArenaID,omitempty"`
	ArenaTimeID          int32             `protobuf:"varint,3,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID,omitempty"`
	Name                 string            `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	EnterDeadline        string            `protobuf:"bytes,5,opt,name=EnterDeadline,proto3" json:"EnterDeadline,omitempty"`
	BeginType            *BeginDetail      `protobuf:"bytes,6,opt,name=BeginType,proto3" json:"BeginType,omitempty"`
	EndType              *EndDetail        `protobuf:"bytes,7,opt,name=EndType,proto3" json:"EndType,omitempty"`
	DatePropert          string            `protobuf:"bytes,8,opt,name=DatePropert,proto3" json:"DatePropert,omitempty"`
	MatchDate            *DateDetail       `protobuf:"bytes,9,opt,name=MatchDate,proto3" json:"MatchDate,omitempty"`
	MatchStatus          int32             `protobuf:"varint,10,opt,name=MatchStatus,proto3" json:"MatchStatus,omitempty"`
	WeekRankRewardTime   *RewardTimeDetail `protobuf:"bytes,11,opt,name=WeekRankRewardTime,proto3" json:"WeekRankRewardTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MatchStatusDetail) Reset()         { *m = MatchStatusDetail{} }
func (m *MatchStatusDetail) String() string { return proto.CompactTextString(m) }
func (*MatchStatusDetail) ProtoMessage()    {}
func (*MatchStatusDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{47}
}
func (m *MatchStatusDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchStatusDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchStatusDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchStatusDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchStatusDetail.Merge(m, src)
}
func (m *MatchStatusDetail) XXX_Size() int {
	return m.Size()
}
func (m *MatchStatusDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchStatusDetail.DiscardUnknown(m)
}

var xxx_messageInfo_MatchStatusDetail proto.InternalMessageInfo

type FullMatchSignReq struct {
	GameID               int32           `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32           `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32           `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32           `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	RoundID              int64           `protobuf:"varint,5,opt,name=RoundID,proto3" json:"RoundID" form:"RoundID"`
	PersonList           []*PersonDetail `protobuf:"bytes,6,rep,name=PersonList,proto3" json:"PersonList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *FullMatchSignReq) Reset()         { *m = FullMatchSignReq{} }
func (m *FullMatchSignReq) String() string { return proto.CompactTextString(m) }
func (*FullMatchSignReq) ProtoMessage()    {}
func (*FullMatchSignReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{48}
}
func (m *FullMatchSignReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FullMatchSignReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FullMatchSignReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FullMatchSignReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FullMatchSignReq.Merge(m, src)
}
func (m *FullMatchSignReq) XXX_Size() int {
	return m.Size()
}
func (m *FullMatchSignReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FullMatchSignReq.DiscardUnknown(m)
}

var xxx_messageInfo_FullMatchSignReq proto.InternalMessageInfo

type PersonDetail struct {
	UserID               int64           `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	SignThinsList        []*ThingsDetail `protobuf:"bytes,6,rep,name=SignThinsList,proto3" json:"SignThinsList" form:"SignThinsList" `
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PersonDetail) Reset()         { *m = PersonDetail{} }
func (m *PersonDetail) String() string { return proto.CompactTextString(m) }
func (*PersonDetail) ProtoMessage()    {}
func (*PersonDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{49}
}
func (m *PersonDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PersonDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PersonDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PersonDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PersonDetail.Merge(m, src)
}
func (m *PersonDetail) XXX_Size() int {
	return m.Size()
}
func (m *PersonDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_PersonDetail.DiscardUnknown(m)
}

var xxx_messageInfo_PersonDetail proto.InternalMessageInfo

type FullMatchSignRsp struct {
	Code                 int32               `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string              `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	SignStatusList       []*SignStatusDetail `protobuf:"bytes,3,rep,name=SignStatusList,proto3" json:"SignStatusList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *FullMatchSignRsp) Reset()         { *m = FullMatchSignRsp{} }
func (m *FullMatchSignRsp) String() string { return proto.CompactTextString(m) }
func (*FullMatchSignRsp) ProtoMessage()    {}
func (*FullMatchSignRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{50}
}
func (m *FullMatchSignRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FullMatchSignRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FullMatchSignRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FullMatchSignRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FullMatchSignRsp.Merge(m, src)
}
func (m *FullMatchSignRsp) XXX_Size() int {
	return m.Size()
}
func (m *FullMatchSignRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FullMatchSignRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FullMatchSignRsp proto.InternalMessageInfo

type CancelMatchSignReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	RoundID              int64    `protobuf:"varint,5,opt,name=RoundID,proto3" json:"RoundID" form:"RoundID"`
	UserList             []int64  `protobuf:"varint,6,rep,packed,name=UserList,proto3" json:"UserList" form:"UserList" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelMatchSignReq) Reset()         { *m = CancelMatchSignReq{} }
func (m *CancelMatchSignReq) String() string { return proto.CompactTextString(m) }
func (*CancelMatchSignReq) ProtoMessage()    {}
func (*CancelMatchSignReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{51}
}
func (m *CancelMatchSignReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelMatchSignReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelMatchSignReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelMatchSignReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelMatchSignReq.Merge(m, src)
}
func (m *CancelMatchSignReq) XXX_Size() int {
	return m.Size()
}
func (m *CancelMatchSignReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelMatchSignReq.DiscardUnknown(m)
}

var xxx_messageInfo_CancelMatchSignReq proto.InternalMessageInfo

type CancelMatchSignRsp struct {
	Code                 int32               `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string              `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	UserList             []*CancelSignDetail `protobuf:"bytes,3,rep,name=UserList,proto3" json:"UserList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CancelMatchSignRsp) Reset()         { *m = CancelMatchSignRsp{} }
func (m *CancelMatchSignRsp) String() string { return proto.CompactTextString(m) }
func (*CancelMatchSignRsp) ProtoMessage()    {}
func (*CancelMatchSignRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{52}
}
func (m *CancelMatchSignRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelMatchSignRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelMatchSignRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelMatchSignRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelMatchSignRsp.Merge(m, src)
}
func (m *CancelMatchSignRsp) XXX_Size() int {
	return m.Size()
}
func (m *CancelMatchSignRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelMatchSignRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CancelMatchSignRsp proto.InternalMessageInfo

type CancelSignDetail struct {
	UserID               int64           `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	IsCancel             bool            `protobuf:"varint,2,opt,name=IsCancel,proto3" json:"IsCancel,omitempty"`
	CostList             []*ThingsDetail `protobuf:"bytes,3,rep,name=CostList,proto3" json:"CostList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CancelSignDetail) Reset()         { *m = CancelSignDetail{} }
func (m *CancelSignDetail) String() string { return proto.CompactTextString(m) }
func (*CancelSignDetail) ProtoMessage()    {}
func (*CancelSignDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{53}
}
func (m *CancelSignDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelSignDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelSignDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelSignDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelSignDetail.Merge(m, src)
}
func (m *CancelSignDetail) XXX_Size() int {
	return m.Size()
}
func (m *CancelSignDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelSignDetail.DiscardUnknown(m)
}

var xxx_messageInfo_CancelSignDetail proto.InternalMessageInfo

type SignStatusDetail struct {
	UserID               int64           `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Join                 bool            `protobuf:"varint,2,opt,name=Join,proto3" json:"Join,omitempty"`
	MatchSignCount       int32           `protobuf:"varint,3,opt,name=MatchSignCount,proto3" json:"MatchSignCount,omitempty"`
	CostList             []*ThingsDetail `protobuf:"bytes,4,rep,name=CostList,proto3" json:"CostList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SignStatusDetail) Reset()         { *m = SignStatusDetail{} }
func (m *SignStatusDetail) String() string { return proto.CompactTextString(m) }
func (*SignStatusDetail) ProtoMessage()    {}
func (*SignStatusDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{54}
}
func (m *SignStatusDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignStatusDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignStatusDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignStatusDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignStatusDetail.Merge(m, src)
}
func (m *SignStatusDetail) XXX_Size() int {
	return m.Size()
}
func (m *SignStatusDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_SignStatusDetail.DiscardUnknown(m)
}

var xxx_messageInfo_SignStatusDetail proto.InternalMessageInfo

type CatchRoundSumReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	UserID               int64    `protobuf:"varint,3,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	Score                int64    `protobuf:"varint,4,opt,name=Score,proto3" json:"Score" form:"Score" `
	Vip                  int32    `protobuf:"varint,5,opt,name=Vip,proto3" json:"Vip" form:"Vip"`
	ArenaID              int32    `protobuf:"varint,6,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,7,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	RoundID              int64    `protobuf:"varint,8,opt,name=RoundID,proto3" json:"RoundID" form:"RoundID"  validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatchRoundSumReq) Reset()         { *m = CatchRoundSumReq{} }
func (m *CatchRoundSumReq) String() string { return proto.CompactTextString(m) }
func (*CatchRoundSumReq) ProtoMessage()    {}
func (*CatchRoundSumReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{55}
}
func (m *CatchRoundSumReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatchRoundSumReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CatchRoundSumReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CatchRoundSumReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatchRoundSumReq.Merge(m, src)
}
func (m *CatchRoundSumReq) XXX_Size() int {
	return m.Size()
}
func (m *CatchRoundSumReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CatchRoundSumReq.DiscardUnknown(m)
}

var xxx_messageInfo_CatchRoundSumReq proto.InternalMessageInfo

type RoundReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	RoundID              int64    `protobuf:"varint,5,opt,name=RoundID,proto3" json:"RoundID" form:"RoundID"  validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoundReq) Reset()         { *m = RoundReq{} }
func (m *RoundReq) String() string { return proto.CompactTextString(m) }
func (*RoundReq) ProtoMessage()    {}
func (*RoundReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{56}
}
func (m *RoundReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoundReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoundReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoundReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundReq.Merge(m, src)
}
func (m *RoundReq) XXX_Size() int {
	return m.Size()
}
func (m *RoundReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoundReq proto.InternalMessageInfo

type RoundRankRsp struct {
	Code                 int32         `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string        `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	RoundStatus          int32         `protobuf:"varint,3,opt,name=RoundStatus,proto3" json:"RoundStatus,omitempty"`
	RoundFinalTime       int64         `protobuf:"varint,4,opt,name=RoundFinalTime,proto3" json:"RoundFinalTime,omitempty"`
	DayRankList          []*RankDetail `protobuf:"bytes,5,rep,name=DayRankList,proto3" json:"DayRankList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RoundRankRsp) Reset()         { *m = RoundRankRsp{} }
func (m *RoundRankRsp) String() string { return proto.CompactTextString(m) }
func (*RoundRankRsp) ProtoMessage()    {}
func (*RoundRankRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{57}
}
func (m *RoundRankRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoundRankRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoundRankRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoundRankRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundRankRsp.Merge(m, src)
}
func (m *RoundRankRsp) XXX_Size() int {
	return m.Size()
}
func (m *RoundRankRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundRankRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RoundRankRsp proto.InternalMessageInfo

type RoundEndRsp struct {
	Code                 int32              `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string             `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	RoundRankList        []*RoundRankDetail `protobuf:"bytes,3,rep,name=RoundRankList,proto3" json:"RoundRankList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *RoundEndRsp) Reset()         { *m = RoundEndRsp{} }
func (m *RoundEndRsp) String() string { return proto.CompactTextString(m) }
func (*RoundEndRsp) ProtoMessage()    {}
func (*RoundEndRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{58}
}
func (m *RoundEndRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoundEndRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoundEndRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoundEndRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundEndRsp.Merge(m, src)
}
func (m *RoundEndRsp) XXX_Size() int {
	return m.Size()
}
func (m *RoundEndRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundEndRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RoundEndRsp proto.InternalMessageInfo

type RoundRankDetail struct {
	UserID               int64           `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	RankScore            int64           `protobuf:"varint,2,opt,name=RankScore,proto3" json:"RankScore,omitempty"`
	Rank                 int32           `protobuf:"varint,3,opt,name=Rank,proto3" json:"Rank,omitempty"`
	RankRewardList       []*RewardDetail `protobuf:"bytes,4,rep,name=RankRewardList,proto3" json:"RankRewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RoundRankDetail) Reset()         { *m = RoundRankDetail{} }
func (m *RoundRankDetail) String() string { return proto.CompactTextString(m) }
func (*RoundRankDetail) ProtoMessage()    {}
func (*RoundRankDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{59}
}
func (m *RoundRankDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoundRankDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoundRankDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoundRankDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundRankDetail.Merge(m, src)
}
func (m *RoundRankDetail) XXX_Size() int {
	return m.Size()
}
func (m *RoundRankDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundRankDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RoundRankDetail proto.InternalMessageInfo

type GetOnlineRoundRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	RoundID              []int64  `protobuf:"varint,3,rep,packed,name=RoundID,proto3" json:"RoundID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetOnlineRoundRsp) Reset()         { *m = GetOnlineRoundRsp{} }
func (m *GetOnlineRoundRsp) String() string { return proto.CompactTextString(m) }
func (*GetOnlineRoundRsp) ProtoMessage()    {}
func (*GetOnlineRoundRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{60}
}
func (m *GetOnlineRoundRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOnlineRoundRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOnlineRoundRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOnlineRoundRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOnlineRoundRsp.Merge(m, src)
}
func (m *GetOnlineRoundRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetOnlineRoundRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOnlineRoundRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetOnlineRoundRsp proto.InternalMessageInfo

type GetOnlineRoundReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetOnlineRoundReq) Reset()         { *m = GetOnlineRoundReq{} }
func (m *GetOnlineRoundReq) String() string { return proto.CompactTextString(m) }
func (*GetOnlineRoundReq) ProtoMessage()    {}
func (*GetOnlineRoundReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{61}
}
func (m *GetOnlineRoundReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOnlineRoundReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOnlineRoundReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOnlineRoundReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOnlineRoundReq.Merge(m, src)
}
func (m *GetOnlineRoundReq) XXX_Size() int {
	return m.Size()
}
func (m *GetOnlineRoundReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOnlineRoundReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetOnlineRoundReq proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MatchDetailReq)(nil), "match.service.v1.MatchDetailReq")
	proto.RegisterType((*MatchDetailRsp)(nil), "match.service.v1.MatchDetailRsp")
	proto.RegisterType((*MatchDetail)(nil), "match.service.v1.MatchDetail")
	proto.RegisterType((*RewardTimeDetail)(nil), "match.service.v1.RewardTimeDetail")
	proto.RegisterType((*BeginDetail)(nil), "match.service.v1.BeginDetail")
	proto.RegisterType((*EndDetail)(nil), "match.service.v1.EndDetail")
	proto.RegisterType((*DateDetail)(nil), "match.service.v1.DateDetail")
	proto.RegisterType((*PayDetail)(nil), "match.service.v1.PayDetail")
	proto.RegisterType((*ThingsDetail)(nil), "match.service.v1.ThingsDetail")
	proto.RegisterType((*ChessSumReq)(nil), "match.service.v1.ChessSumReq")
	proto.RegisterType((*UserDetails)(nil), "match.service.v1.UserDetails")
	proto.RegisterType((*CommonRsp)(nil), "match.service.v1.CommonRsp")
	proto.RegisterType((*DayRankReq)(nil), "match.service.v1.DayRankReq")
	proto.RegisterType((*DayRankRsp)(nil), "match.service.v1.DayRankRsp")
	proto.RegisterType((*CatchDayRankReq)(nil), "match.service.v1.CatchDayRankReq")
	proto.RegisterType((*CatchDayRankRsp)(nil), "match.service.v1.CatchDayRankRsp")
	proto.RegisterType((*WeekRankReq)(nil), "match.service.v1.WeekRankReq")
	proto.RegisterType((*WeekRankRsp)(nil), "match.service.v1.WeekRankRsp")
	proto.RegisterType((*RankDetail)(nil), "match.service.v1.RankDetail")
	proto.RegisterType((*CatchRankDetail)(nil), "match.service.v1.CatchRankDetail")
	proto.RegisterType((*CommonReq)(nil), "match.service.v1.CommonReq")
	proto.RegisterType((*RankRewardReq)(nil), "match.service.v1.RankRewardReq")
	proto.RegisterType((*RankRewardRsp)(nil), "match.service.v1.RankRewardRsp")
	proto.RegisterType((*MatchSignReq)(nil), "match.service.v1.MatchSignReq")
	proto.RegisterType((*MatchSignRsp)(nil), "match.service.v1.MatchSignRsp")
	proto.RegisterType((*CatchSumReq)(nil), "match.service.v1.CatchSumReq")
	proto.RegisterType((*CatchSumRsp)(nil), "match.service.v1.CatchSumRsp")
	proto.RegisterType((*WeekResultReq)(nil), "match.service.v1.WeekResultReq")
	proto.RegisterType((*WeekResultRsp)(nil), "match.service.v1.WeekResultRsp")
	proto.RegisterType((*UserRankDetail)(nil), "match.service.v1.UserRankDetail")
	proto.RegisterType((*UserRankRsp)(nil), "match.service.v1.UserRankRsp")
	proto.RegisterType((*MatchEndReq)(nil), "match.service.v1.MatchEndReq")
	proto.RegisterType((*WeekRewardReportReq)(nil), "match.service.v1.WeekRewardReportReq")
	proto.RegisterType((*UserRewardReq)(nil), "match.service.v1.UserRewardReq")
	proto.RegisterType((*UserRewardRsp)(nil), "match.service.v1.UserRewardRsp")
	proto.RegisterType((*RewardDetail)(nil), "match.service.v1.RewardDetail")
	proto.RegisterType((*FloatBonusPoolReq)(nil), "match.service.v1.FloatBonusPoolReq")
	proto.RegisterType((*FloatBonusPoolRsp)(nil), "match.service.v1.FloatBonusPoolRsp")
	proto.RegisterType((*FamousHallReq)(nil), "match.service.v1.FamousHallReq")
	proto.RegisterType((*FamousHallRsp)(nil), "match.service.v1.FamousHallRsp")
	proto.RegisterType((*ChampionDetail)(nil), "match.service.v1.ChampionDetail")
	proto.RegisterType((*RewardListReq)(nil), "match.service.v1.RewardListReq")
	proto.RegisterType((*RewardListRsp)(nil), "match.service.v1.RewardListRsp")
	proto.RegisterType((*MatchRewardDetail)(nil), "match.service.v1.MatchRewardDetail")
	proto.RegisterType((*RankRewardDetail)(nil), "match.service.v1.RankRewardDetail")
	proto.RegisterType((*MatchStatusReq)(nil), "match.service.v1.MatchStatusReq")
	proto.RegisterType((*MatchStatusRsp)(nil), "match.service.v1.MatchStatusRsp")
	proto.RegisterType((*MatchStatusDetail)(nil), "match.service.v1.MatchStatusDetail")
	proto.RegisterType((*FullMatchSignReq)(nil), "match.service.v1.FullMatchSignReq")
	proto.RegisterType((*PersonDetail)(nil), "match.service.v1.PersonDetail")
	proto.RegisterType((*FullMatchSignRsp)(nil), "match.service.v1.FullMatchSignRsp")
	proto.RegisterType((*CancelMatchSignReq)(nil), "match.service.v1.CancelMatchSignReq")
	proto.RegisterType((*CancelMatchSignRsp)(nil), "match.service.v1.CancelMatchSignRsp")
	proto.RegisterType((*CancelSignDetail)(nil), "match.service.v1.CancelSignDetail")
	proto.RegisterType((*SignStatusDetail)(nil), "match.service.v1.SignStatusDetail")
	proto.RegisterType((*CatchRoundSumReq)(nil), "match.service.v1.CatchRoundSumReq")
	proto.RegisterType((*RoundReq)(nil), "match.service.v1.RoundReq")
	proto.RegisterType((*RoundRankRsp)(nil), "match.service.v1.RoundRankRsp")
	proto.RegisterType((*RoundEndRsp)(nil), "match.service.v1.RoundEndRsp")
	proto.RegisterType((*RoundRankDetail)(nil), "match.service.v1.RoundRankDetail")
	proto.RegisterType((*GetOnlineRoundRsp)(nil), "match.service.v1.GetOnlineRoundRsp")
	proto.RegisterType((*GetOnlineRoundReq)(nil), "match.service.v1.GetOnlineRoundReq")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 3240 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5c, 0xdd, 0x8f, 0x23, 0x47,
	0xb5, 0x4f, 0xbb, 0xc7, 0x33, 0xf6, 0xb1, 0x3d, 0xe3, 0xad, 0xfd, 0x88, 0xe3, 0xcc, 0x8e, 0x9d,
	0xca, 0xee, 0xcd, 0x2a, 0x52, 0x76, 0xf3, 0x71, 0xa3, 0xe8, 0xee, 0x95, 0x72, 0x6f, 0x3c, 0xb3,
	0x3b, 0xd9, 0x24, 0xbb, 0x3b, 0xea, 0x09, 0x1b, 0x01, 0x0a, 0xd0, 0x3b, 0xae, 0xf1, 0xb4, 0xd6,
	0xee, 0xf6, 0xba, 0xdb, 0x49, 0x06, 0x29, 0x48, 0x24, 0x3c, 0x21, 0xde, 0x10, 0x12, 0x48, 0x08,
	0x29, 0x04, 0xc4, 0x43, 0x84, 0x10, 0x12, 0xe2, 0x09, 0x84, 0x84, 0x44, 0x14, 0x94, 0x17, 0x24,
	0x78, 0x44, 0x86, 0x84, 0x3c, 0xa0, 0x81, 0x87, 0x68, 0xfe, 0x02, 0x54, 0xa7, 0xaa, 0xbb, 0xab,
	0xda, 0x6d, 0xcf, 0x78, 0xc6, 0x49, 0x96, 0x65, 0x5e, 0x46, 0x5d, 0xa7, 0x4e, 0xd5, 0xa9, 0x8f,
	0xdf, 0x39, 0x75, 0xea, 0xd4, 0xf1, 0x40, 0xde, 0xee, 0x3a, 0xe7, 0xbb, 0x3d, 0x2f, 0xf0, 0x48,
	0xb9, 0x63, 0x07, 0x1b, 0x5b, 0xe7, 0x7d, 0xd6, 0x7b, 0xc5, 0xd9, 0x60, 0xe7, 0x5f, 0x79, 0xac,
	0xfa, 0x48, 0xcb, 0x09, 0xb6, 0xfa, 0x37, 0xcf, 0x6f, 0x78, 0x9d, 0x0b, 0x2d, 0xaf, 0xe5, 0x5d,
	0x40, 0xc6, 0x9b, 0xfd, 0x4d, 0x2c, 0x61, 0x01, 0xbf, 0x44, 0x07, 0xd5, 0xc5, 0x96, 0xe7, 0xb5,
	0xda, 0xec, 0x82, 0xdd, 0x75, 0x2e, 0xd8, 0xae, 0xeb, 0x05, 0x76, 0xe0, 0x78, 0xae, 0x2f, 0x6a,
	0xe9, 0xfb, 0x06, 0xcc, 0x5f, 0xe5, 0x12, 0x56, 0x58, 0x60, 0x3b, 0x6d, 0x8b, 0xdd, 0x26, 0xab,
	0x30, 0xbb, 0x6a, 0x77, 0xd8, 0x95, 0x95, 0x8a, 0x51, 0x37, 0xce, 0x65, 0x1b, 0x17, 0x76, 0x06,
	0x35, 0x49, 0xd9, 0x1d, 0xd4, 0x1e, 0xd8, 0xf4, 0x7a, 0x9d, 0x8b, 0x54, 0x94, 0x69, 0xfd, 0x15,
	0xbb, 0xed, 0x34, 0xed, 0x80, 0x5d, 0xa4, 0x3d, 0x76, 0xbb, 0xef, 0xf4, 0x58, 0x93, 0x5a, 0x92,
	0x99, 0x77, 0xf4, 0x39, 0x9f, 0xf5, 0xae, 0xac, 0x54, 0x32, 0x75, 0xe3, 0x9c, 0x29, 0x3a, 0x12,
	0x94, 0xb8, 0x23, 0x51, 0x1e, 0xd1, 0x91, 0xa8, 0x24, 0x0f, 0x81, 0x79, 0xc3, 0xe9, 0x56, 0x4c,
	0x1c, 0xce, 0xc9, 0x9d, 0x41, 0x8d, 0x17, 0x77, 0x07, 0x35, 0x10, 0x5d, 0xdc, 0x70, 0xba, 0xd4,
	0xe2, 0x24, 0xfa, 0x56, 0x62, 0x36, 0x7e, 0x97, 0x2c, 0xc2, 0xcc, 0xb2, 0xd7, 0x64, 0x72, 0x2e,
	0xb9, 0x9d, 0x41, 0x0d, 0xcb, 0x16, 0xfe, 0x25, 0x67, 0x61, 0xee, 0x2a, 0xf3, 0x7d, 0xbb, 0xc5,
	0x70, 0x8c, 0xf9, 0x46, 0x61, 0x67, 0x50, 0x0b, 0x49, 0x56, 0xf8, 0x41, 0x9e, 0x83, 0x3c, 0x76,
	0xfb, 0x82, 0xe3, 0x07, 0x15, 0xb3, 0x6e, 0x9e, 0x2b, 0x3c, 0x7e, 0xfa, 0x7c, 0x72, 0x63, 0xce,
	0x2b, 0x92, 0x1b, 0xa5, 0x9d, 0x41, 0x2d, 0x6e, 0x63, 0xc5, 0x9f, 0xf4, 0x4f, 0x59, 0x28, 0x28,
	0x9c, 0x84, 0xc0, 0xcc, 0x35, 0xbb, 0x23, 0x06, 0x98, 0xb7, 0xf0, 0x9b, 0xcc, 0x43, 0x46, 0xae,
	0x5a, 0xd6, 0xca, 0x5c, 0x59, 0x21, 0x15, 0x98, 0x7b, 0xa6, 0xc7, 0x5c, 0xfb, 0xca, 0x8a, 0x58,
	0x04, 0x2b, 0x2c, 0x92, 0x3a, 0x14, 0xf0, 0xf3, 0x45, 0x07, 0x77, 0x6c, 0x06, 0x6b, 0x55, 0x12,
	0x59, 0x02, 0x78, 0xc1, 0xe9, 0x38, 0x01, 0x2f, 0xfa, 0x95, 0x2c, 0x32, 0x28, 0x14, 0x72, 0x02,
	0xb2, 0xd7, 0x7b, 0x4d, 0xd6, 0xab, 0xcc, 0x62, 0x95, 0x28, 0x90, 0x33, 0x50, 0xba, 0xe4, 0x06,
	0xac, 0xb7, 0xc2, 0xec, 0x66, 0xdb, 0x71, 0x59, 0x65, 0x0e, 0x87, 0xa7, 0x13, 0xc9, 0xff, 0x42,
	0xbe, 0xc1, 0x5a, 0x8e, 0xfb, 0xe2, 0x76, 0x97, 0x55, 0x72, 0x75, 0x23, 0x7d, 0x5d, 0x90, 0x45,
	0xee, 0x48, 0xcc, 0x4f, 0x9e, 0x84, 0xb9, 0x4b, 0x6e, 0x13, 0x9b, 0xe6, 0xb1, 0xe9, 0xfd, 0xc3,
	0x4d, 0x2f, 0xb9, 0x4d, 0xd9, 0x30, 0xe4, 0x25, 0x17, 0xe5, 0x5e, 0xac, 0xd8, 0x01, 0xab, 0x00,
	0x36, 0x5c, 0x1c, 0x6e, 0xc8, 0x6b, 0x43, 0x91, 0x11, 0x3b, 0x69, 0x40, 0x71, 0xdd, 0x69, 0xb9,
	0xcb, 0x9e, 0xdb, 0x74, 0x02, 0xcf, 0xad, 0x14, 0x70, 0x2b, 0x97, 0x86, 0x9b, 0xbf, 0xb8, 0xe5,
	0xb8, 0x2d, 0x5f, 0x76, 0xa0, 0xb5, 0xe1, 0xc3, 0xe6, 0xe5, 0x35, 0x7b, 0xbb, 0x52, 0x1c, 0x35,
	0xec, 0x35, 0x7b, 0x3b, 0x1c, 0xb6, 0xe4, 0xe5, 0x1b, 0x85, 0xe3, 0x58, 0x0f, 0xec, 0xa0, 0xef,
	0x57, 0x4a, 0x62, 0xa3, 0x14, 0x12, 0xe7, 0xe0, 0x83, 0x5c, 0xeb, 0x79, 0x5d, 0xd6, 0x0b, 0x2a,
	0xf3, 0xb8, 0xe0, 0x2a, 0x89, 0x73, 0x5c, 0x63, 0xaf, 0x05, 0x37, 0x9c, 0xae, 0xc5, 0x27, 0xbf,
	0x20, 0xfa, 0x50, 0x48, 0x7c, 0xdb, 0x78, 0x11, 0x77, 0x16, 0x79, 0xca, 0xc8, 0xa3, 0x13, 0x89,
	0x05, 0xe4, 0x25, 0xc6, 0x6e, 0x59, 0xb6, 0x7b, 0xcb, 0x62, 0xaf, 0xda, 0xbd, 0x26, 0xaf, 0xaa,
	0x1c, 0xc3, 0xd9, 0xd0, 0xe1, 0xd9, 0xc4, 0x3c, 0x72, 0x52, 0x29, 0xad, 0xe9, 0x1a, 0x94, 0x93,
	0x7c, 0x64, 0x11, 0xf2, 0x82, 0xb6, 0x62, 0x6f, 0x0b, 0x05, 0xb4, 0x62, 0x02, 0x07, 0xa6, 0x22,
	0x1d, 0xd5, 0xcf, 0x52, 0x28, 0xf4, 0x4d, 0x03, 0x0a, 0x0a, 0x74, 0x78, 0x6f, 0x31, 0xd8, 0x84,
	0xb6, 0x28, 0x68, 0xaa, 0x42, 0xee, 0x72, 0xbf, 0xdd, 0xbe, 0xd6, 0xef, 0xf8, 0x52, 0x71, 0xa2,
	0x32, 0x6f, 0xb9, 0x1e, 0xd8, 0x3d, 0x5c, 0x01, 0x54, 0xa0, 0xbc, 0x15, 0x13, 0x78, 0xed, 0xf2,
	0xf6, 0x46, 0x9b, 0xe1, 0x7a, 0x09, 0x05, 0x8a, 0x09, 0x74, 0x1b, 0xf2, 0x11, 0x08, 0xb9, 0x1e,
	0x86, 0x90, 0x15, 0x03, 0x88, 0x50, 0x29, 0x6b, 0xe2, 0x99, 0x84, 0x45, 0x3e, 0x30, 0xfe, 0xe9,
	0x05, 0x76, 0x5b, 0x2a, 0x6f, 0x54, 0xe6, 0xa2, 0x23, 0x4d, 0x0c, 0x45, 0x47, 0x04, 0xfa, 0x2c,
	0x40, 0x0c, 0x63, 0x6e, 0x27, 0xf8, 0xb2, 0x57, 0x8c, 0xba, 0x79, 0x2e, 0x6b, 0xe1, 0x37, 0xd7,
	0xdd, 0xab, 0x9e, 0x1b, 0x6c, 0x55, 0x32, 0x48, 0x14, 0x05, 0x52, 0x06, 0x93, 0x2f, 0xb8, 0x89,
	0x34, 0xfe, 0x49, 0x5f, 0x86, 0x7c, 0x04, 0x49, 0xbe, 0xee, 0x08, 0x3b, 0x61, 0x10, 0xc4, 0xb6,
	0x28, 0x14, 0xf2, 0x28, 0x98, 0x1c, 0xdc, 0x99, 0x7d, 0xe9, 0x06, 0x67, 0xa5, 0x8f, 0x42, 0x51,
	0x25, 0x4a, 0xf3, 0x65, 0x44, 0xe6, 0xab, 0x0c, 0xa6, 0xdb, 0xef, 0x88, 0x53, 0xc0, 0xe2, 0x9f,
	0x74, 0xc7, 0x84, 0xc2, 0xf2, 0x16, 0xf3, 0xfd, 0xf5, 0x7e, 0x67, 0xaa, 0x67, 0xce, 0xf3, 0x30,
	0x87, 0x53, 0x09, 0xcd, 0x67, 0xe3, 0x31, 0x34, 0xe8, 0x82, 0xb4, 0x3b, 0xa8, 0x51, 0xd1, 0x95,
	0x24, 0xa4, 0xf7, 0x15, 0xb2, 0x93, 0xa7, 0x12, 0x66, 0xb7, 0x71, 0x9a, 0x77, 0x26, 0x49, 0xbb,
	0x83, 0xda, 0xbc, 0xe8, 0x4c, 0x12, 0x68, 0x6c, 0x95, 0x5d, 0xc8, 0xf1, 0xa3, 0x0b, 0x8f, 0x8b,
	0x99, 0x51, 0xc7, 0x05, 0xe7, 0x10, 0x0b, 0xe6, 0x37, 0x9e, 0xd8, 0x19, 0xd4, 0xa2, 0x26, 0xbb,
	0x83, 0xda, 0x83, 0xf1, 0xe1, 0x88, 0x87, 0x46, 0xea, 0x38, 0xa3, 0x06, 0x64, 0x9d, 0xab, 0x46,
	0xf0, 0x4c, 0xc7, 0xeb, 0xbb, 0x01, 0x9a, 0x78, 0xb3, 0xf1, 0x24, 0x3f, 0x80, 0x22, 0xe2, 0xee,
	0xa0, 0x76, 0x46, 0x74, 0x19, 0x91, 0xd2, 0xfb, 0x8c, 0x9b, 0x90, 0x55, 0xfd, 0x68, 0xc1, 0xe3,
	0xa1, 0x71, 0x76, 0x67, 0x50, 0x53, 0xc9, 0xbb, 0x83, 0x1a, 0x51, 0x56, 0x41, 0x10, 0xa9, 0x76,
	0x02, 0xd1, 0xdf, 0x19, 0x50, 0x50, 0x26, 0xab, 0xf8, 0x05, 0xc6, 0xe1, 0xfc, 0x82, 0x65, 0xc8,
	0xae, 0x6f, 0x78, 0x3d, 0x26, 0xfd, 0x8b, 0x47, 0x76, 0x06, 0x35, 0x41, 0xd8, 0x1d, 0xd4, 0xea,
	0xa2, 0x1b, 0x2c, 0xa6, 0xf7, 0x22, 0x58, 0xc9, 0x39, 0xd5, 0xb9, 0x38, 0x15, 0x3b, 0x17, 0x85,
	0xd8, 0xb9, 0xa8, 0x0b, 0xef, 0xe2, 0x7f, 0x20, 0xbf, 0xec, 0x75, 0x3a, 0x9e, 0xcb, 0xfd, 0x0a,
	0xa2, 0xfa, 0x15, 0xd2, 0x9b, 0xa8, 0x24, 0xbc, 0x89, 0xc8, 0x81, 0xa0, 0x7f, 0x37, 0xb9, 0x2e,
	0x6f, 0x0b, 0x9b, 0x79, 0xd7, 0xc1, 0xfd, 0xff, 0x38, 0xfc, 0x36, 0xbd, 0x1e, 0xe3, 0x66, 0x07,
	0xcd, 0x58, 0xe3, 0x01, 0x01, 0x3f, 0x49, 0xdc, 0x1d, 0xd4, 0xca, 0x21, 0xfc, 0x24, 0x09, 0xa1,
	0x26, 0xbf, 0xc9, 0xf3, 0x50, 0xbc, 0xe4, 0x36, 0xf9, 0xea, 0xac, 0x79, 0x4e, 0x04, 0xe1, 0x87,
	0x76, 0x06, 0x35, 0x8d, 0xbe, 0x3b, 0xa8, 0x1d, 0x17, 0xdd, 0xa8, 0x54, 0x6a, 0x69, 0x4c, 0xe4,
	0xbf, 0x23, 0x78, 0xcd, 0x62, 0x37, 0x8b, 0x1a, 0xbc, 0xe6, 0x75, 0x78, 0x45, 0x58, 0x4a, 0xa0,
	0x7d, 0xee, 0xc0, 0x68, 0xff, 0x95, 0x11, 0x6f, 0xf5, 0xa4, 0x38, 0xe1, 0x87, 0xc5, 0x3a, 0x6b,
	0x6f, 0xf2, 0xc6, 0xb8, 0x07, 0xa6, 0x15, 0x95, 0xf9, 0xd9, 0x1e, 0x7e, 0x0b, 0xd4, 0xcf, 0x20,
	0x83, 0x4e, 0x24, 0x4f, 0x73, 0x2f, 0x02, 0xa5, 0xa3, 0xf5, 0xc9, 0xa2, 0xf5, 0x49, 0x71, 0x90,
	0x38, 0x87, 0xb4, 0xe1, 0x6a, 0x03, 0xfa, 0x97, 0x0c, 0x2c, 0x2c, 0x0b, 0x87, 0xe9, 0x6e, 0x85,
	0xeb, 0x6a, 0x8a, 0xcf, 0x7c, 0x90, 0xad, 0x56, 0x90, 0x96, 0xdd, 0x3f, 0xd2, 0xe8, 0xbb, 0x46,
	0x62, 0x85, 0x3f, 0x03, 0x94, 0x2c, 0xa7, 0xa1, 0xe4, 0x81, 0x61, 0x94, 0xe0, 0x38, 0x47, 0x41,
	0xe5, 0xeb, 0x33, 0x50, 0x88, 0x3d, 0xc1, 0x3b, 0x15, 0x26, 0x2b, 0x00, 0x7c, 0x90, 0xc2, 0xd8,
	0x48, 0xa4, 0x9c, 0xd9, 0x19, 0xd4, 0x14, 0x6a, 0xbc, 0xd7, 0x31, 0x8d, 0xd6, 0x2d, 0x85, 0x43,
	0x05, 0xdb, 0xcc, 0x44, 0x60, 0x9b, 0xaa, 0x69, 0x5b, 0x4d, 0x98, 0xb6, 0x03, 0x9f, 0x9c, 0x53,
	0xb3, 0x76, 0xbf, 0x31, 0x14, 0x0c, 0x7c, 0x06, 0x40, 0xfe, 0x7f, 0x28, 0x86, 0xe2, 0xf7, 0x6d,
	0xef, 0xb4, 0x16, 0xf4, 0x07, 0x06, 0x40, 0x5c, 0x49, 0x4e, 0xe9, 0xce, 0x49, 0xb4, 0x62, 0xfc,
	0x2e, 0x13, 0x0d, 0x45, 0x78, 0xb2, 0x31, 0x81, 0x4f, 0x3b, 0x9a, 0x44, 0xd6, 0xc2, 0x6f, 0x72,
	0x19, 0xe6, 0xe3, 0x3b, 0x92, 0xe2, 0x0a, 0xee, 0xe5, 0x52, 0x27, 0x5a, 0xd1, 0x9f, 0x85, 0xf6,
	0x42, 0x19, 0x65, 0x28, 0x4f, 0x5e, 0x06, 0x50, 0x5e, 0x1d, 0x0a, 0x97, 0x1d, 0xd7, 0x6e, 0xab,
	0x31, 0x17, 0x4b, 0x25, 0x71, 0xcf, 0x1f, 0x8b, 0x62, 0x12, 0x62, 0xc1, 0x15, 0xca, 0xd4, 0x46,
	0xfc, 0xcf, 0x4c, 0xe4, 0x29, 0xdd, 0x8d, 0xa7, 0x47, 0x08, 0x90, 0x99, 0xa9, 0xea, 0x60, 0xf6,
	0xc0, 0x3a, 0xb8, 0x6b, 0x40, 0x29, 0xde, 0x81, 0x3b, 0x33, 0x84, 0x77, 0x1d, 0x72, 0x62, 0x78,
	0x72, 0xbd, 0xf3, 0xe2, 0xca, 0x13, 0xd2, 0xe2, 0x2b, 0x4f, 0x48, 0x19, 0x71, 0xe5, 0x89, 0xaa,
	0x5f, 0xd7, 0xe6, 0x3c, 0xb1, 0xe5, 0x79, 0x3a, 0x0c, 0x3e, 0x28, 0x21, 0xbd, 0xbd, 0x60, 0xae,
	0xb4, 0xa0, 0x1f, 0x98, 0x50, 0x14, 0xc1, 0x1b, 0xa7, 0xe5, 0x1e, 0xf9, 0x48, 0xa3, 0x7d, 0xa4,
	0xd5, 0x84, 0x8f, 0x74, 0x60, 0x04, 0x75, 0xa1, 0xc4, 0xd7, 0x9a, 0xef, 0x88, 0x8f, 0x9b, 0x36,
	0xbb, 0x9f, 0x4d, 0x6b, 0x3c, 0xbc, 0x33, 0xa8, 0xe9, 0x0d, 0x77, 0x07, 0xb5, 0x93, 0xf2, 0x72,
	0xa8, 0x92, 0x69, 0xdd, 0xd2, 0xf9, 0xe8, 0x2f, 0x0c, 0x75, 0x8f, 0x27, 0x86, 0xd8, 0x45, 0xc8,
	0x2d, 0x7b, 0x7e, 0x30, 0x01, 0xc0, 0x22, 0x7e, 0x2e, 0xe9, 0x39, 0xcf, 0x71, 0x71, 0xdd, 0x73,
	0x16, 0x7e, 0x93, 0xff, 0x92, 0xb1, 0x6d, 0x11, 0x8d, 0x0c, 0x6f, 0xfa, 0x59, 0x2b, 0x41, 0xa5,
	0x7f, 0x36, 0xa1, 0x80, 0xe7, 0xc5, 0x1d, 0x1d, 0x5b, 0x89, 0x71, 0x61, 0x4e, 0x29, 0x08, 0x30,
	0x73, 0x88, 0x20, 0x80, 0x7c, 0x61, 0xc8, 0xee, 0xf5, 0xc2, 0xa0, 0x2a, 0xd4, 0xec, 0x61, 0x14,
	0xea, 0xe0, 0x1e, 0xd7, 0x77, 0x32, 0xca, 0xf6, 0x1e, 0xc4, 0xe3, 0x5a, 0xee, 0xf7, 0x54, 0x07,
	0x20, 0x2a, 0xf3, 0xba, 0xab, 0xf6, 0x6b, 0xaa, 0xb3, 0x15, 0x95, 0x23, 0x87, 0x03, 0x95, 0x58,
	0x3a, 0x1c, 0xd2, 0x25, 0x12, 0xa1, 0xcd, 0xd9, 0xd8, 0x25, 0x12, 0xb1, 0xcd, 0x25, 0x80, 0x1b,
	0x4e, 0xf7, 0x99, 0x66, 0x13, 0xe3, 0xaa, 0x73, 0x22, 0xcc, 0x18, 0x53, 0x08, 0x85, 0x22, 0xc6,
	0x1b, 0x43, 0x8e, 0x1c, 0x72, 0x68, 0x34, 0xf2, 0x30, 0x94, 0xa3, 0xc8, 0x75, 0xc8, 0x97, 0x47,
	0xbe, 0x21, 0x3a, 0xfd, 0x38, 0x03, 0x25, 0x74, 0xec, 0x98, 0xdf, 0x6f, 0x07, 0x47, 0x8e, 0xc7,
	0xa7, 0xe0, 0x78, 0xfc, 0xda, 0xd0, 0x96, 0x7c, 0x62, 0x30, 0x2e, 0x42, 0x9e, 0x37, 0x57, 0xd1,
	0x18, 0x13, 0x38, 0x1c, 0x43, 0x47, 0x3d, 0x84, 0x63, 0x58, 0x26, 0x2b, 0x50, 0xe4, 0x93, 0x49,
	0xb8, 0xfd, 0xf5, 0xf4, 0x20, 0xab, 0xea, 0xfa, 0xab, 0xad, 0xe8, 0x37, 0x0d, 0x98, 0xd7, 0x19,
	0xf8, 0x60, 0xb1, 0x14, 0x3d, 0x58, 0x84, 0xc5, 0x3d, 0x2e, 0x00, 0x75, 0x28, 0xa0, 0x3b, 0x62,
	0xbb, 0xb7, 0x1c, 0xb7, 0x25, 0x27, 0xa3, 0x92, 0xf0, 0xb9, 0x83, 0xb3, 0x8b, 0xf7, 0x1f, 0x11,
	0xec, 0x57, 0x28, 0xf4, 0x7d, 0x19, 0x25, 0x3d, 0xd8, 0x4d, 0x4a, 0xbd, 0x80, 0x24, 0xf4, 0x53,
	0x55, 0x68, 0x65, 0xc4, 0x9a, 0xf6, 0x66, 0x93, 0xda, 0x5b, 0x85, 0xdc, 0x8a, 0xb3, 0x29, 0x9a,
	0x0a, 0xd5, 0x8e, 0xca, 0x5c, 0x73, 0x71, 0x97, 0xfa, 0x1d, 0x51, 0x3f, 0x87, 0xf5, 0x1a, 0x8d,
	0xfe, 0x38, 0x23, 0xdf, 0xbb, 0xf8, 0xfd, 0xf5, 0xc8, 0x3d, 0x1a, 0xa9, 0x42, 0x1f, 0x19, 0x70,
	0x5c, 0xa8, 0x90, 0xf0, 0xdd, 0xbb, 0x5e, 0xef, 0x2e, 0xb4, 0x5d, 0xf4, 0x2d, 0x03, 0x4a, 0x08,
	0xee, 0x3b, 0xf7, 0x8a, 0xc2, 0x6f, 0x14, 0xca, 0x10, 0x3f, 0xa9, 0x1b, 0x85, 0x7c, 0xff, 0x1c,
	0xbe, 0x51, 0x7c, 0x6c, 0x40, 0x51, 0xad, 0x44, 0x51, 0x72, 0xe7, 0xa4, 0x29, 0x0a, 0xb7, 0xa1,
	0xaa, 0x5c, 0xa6, 0xc4, 0x28, 0xa2, 0xf2, 0x01, 0x0c, 0x81, 0xfe, 0x0e, 0x9b, 0x4d, 0xbe, 0xc3,
	0xf2, 0x89, 0x09, 0x2f, 0x75, 0xff, 0x5e, 0xb7, 0xa5, 0xb4, 0x50, 0x93, 0x17, 0xe6, 0xb4, 0xe4,
	0x05, 0xfa, 0x4e, 0x06, 0x8e, 0x5d, 0x6e, 0x7b, 0x76, 0xd0, 0xf0, 0xdc, 0xbe, 0xbf, 0xe6, 0x79,
	0xed, 0x23, 0x53, 0x31, 0xda, 0x54, 0xb0, 0xa1, 0xc5, 0x9a, 0x18, 0xa3, 0x14, 0x8a, 0x51, 0xeb,
	0x6b, 0xfd, 0x8e, 0x04, 0x89, 0x46, 0xa3, 0x3f, 0xc9, 0x40, 0xe9, 0xb2, 0xdd, 0xf1, 0xfa, 0xfe,
	0xb3, 0x76, 0xfb, 0x68, 0x43, 0xc6, 0x6c, 0xc8, 0x9b, 0x86, 0xb6, 0x52, 0x13, 0xef, 0xc6, 0x0a,
	0x14, 0x97, 0xb7, 0xec, 0x4e, 0xd7, 0xf1, 0x5c, 0xc5, 0x66, 0xa4, 0x38, 0x31, 0x21, 0x57, 0xe8,
	0xc4, 0xa8, 0xad, 0xe8, 0xd7, 0x60, 0x5e, 0xaf, 0x1f, 0x17, 0xc2, 0x14, 0xf9, 0x14, 0xdc, 0x8d,
	0xce, 0x28, 0x09, 0x14, 0x98, 0x1b, 0x23, 0x32, 0x18, 0xb0, 0xce, 0x8c, 0x32, 0x18, 0xb0, 0x66,
	0xac, 0xf9, 0xa0, 0x3f, 0x37, 0xa0, 0x14, 0x9b, 0xb1, 0xa9, 0xe2, 0xe5, 0xa5, 0xc8, 0x32, 0x6d,
	0x77, 0xc3, 0x04, 0xad, 0xa7, 0x76, 0x06, 0x35, 0x85, 0xba, 0x3b, 0xa8, 0x9d, 0x55, 0x03, 0x47,
	0x9c, 0x96, 0xde, 0xa9, 0xd2, 0x88, 0x7e, 0x4b, 0x1f, 0xf3, 0xc4, 0x3b, 0x77, 0x15, 0x16, 0x10,
	0x86, 0x43, 0x06, 0xff, 0xc1, 0x11, 0x59, 0x61, 0x9a, 0xd5, 0x4f, 0xb6, 0xa5, 0x3f, 0x35, 0xe0,
	0xd8, 0x10, 0xdb, 0x18, 0xfb, 0xaf, 0x58, 0xd4, 0xcc, 0xd8, 0x74, 0x30, 0x73, 0x38, 0x1d, 0xac,
	0xa1, 0x1d, 0x53, 0x22, 0xbe, 0x4b, 0xd3, 0xc3, 0xe5, 0x23, 0x8f, 0xaa, 0x4d, 0x28, 0x27, 0xeb,
	0x53, 0x23, 0xd2, 0xfa, 0xc9, 0x91, 0x99, 0xf4, 0xe4, 0xa0, 0x9f, 0x0f, 0x23, 0x1e, 0xe8, 0x21,
	0x4f, 0x13, 0x5a, 0xf4, 0x47, 0x86, 0xde, 0xf7, 0xb4, 0x32, 0x05, 0x43, 0x64, 0x88, 0x6e, 0xf7,
	0x81, 0x0c, 0xc1, 0xa8, 0x21, 0x23, 0x6e, 0x4b, 0xff, 0x61, 0x4a, 0x64, 0xa8, 0x6c, 0x9f, 0x10,
	0x32, 0xc2, 0x44, 0xc4, 0x19, 0x25, 0x11, 0x71, 0x28, 0x0d, 0x30, 0xbb, 0x67, 0x1a, 0xe0, 0xec,
	0xc1, 0xd3, 0x00, 0xe7, 0x26, 0x48, 0x03, 0x4c, 0x64, 0xcb, 0xe5, 0x86, 0xb3, 0xe5, 0xb4, 0x44,
	0xc1, 0xfc, 0x64, 0x89, 0x82, 0x89, 0x6c, 0x3d, 0x18, 0xce, 0xd6, 0x4b, 0xcf, 0xa1, 0x2b, 0x1c,
	0x2a, 0x87, 0xee, 0x6d, 0x13, 0xca, 0x97, 0xfb, 0xed, 0xf6, 0x51, 0x60, 0x79, 0x1f, 0x81, 0xe5,
	0xa7, 0x60, 0xce, 0xf2, 0xfa, 0x6e, 0x33, 0x8a, 0x2c, 0xe3, 0x08, 0x24, 0x29, 0x1e, 0x81, 0x24,
	0x50, 0x2b, 0xac, 0xe2, 0x56, 0x69, 0x8d, 0xf5, 0x7c, 0x79, 0xe8, 0x8e, 0xf4, 0x67, 0x05, 0x4f,
	0x68, 0x95, 0xe2, 0x16, 0xf4, 0xf7, 0x06, 0x14, 0xd5, 0xca, 0xe9, 0xe5, 0x33, 0x7d, 0xfa, 0x21,
	0xee, 0xb7, 0x8d, 0x24, 0xe2, 0xa6, 0x97, 0x32, 0x3d, 0xcf, 0xfb, 0x1b, 0xb2, 0x83, 0x29, 0xba,
	0x11, 0xf3, 0x85, 0xef, 0x89, 0x7a, 0x4b, 0xfa, 0x4b, 0x13, 0xc8, 0xb2, 0xed, 0x6e, 0xb0, 0x23,
	0xcd, 0xf8, 0x44, 0x35, 0xe3, 0xba, 0x92, 0xb6, 0xc8, 0xa1, 0x67, 0x1e, 0x32, 0x2f, 0x91, 0x7e,
	0xcf, 0x18, 0xde, 0xb8, 0x69, 0x01, 0xec, 0x69, 0x65, 0xb0, 0x23, 0xa1, 0x25, 0x84, 0x73, 0xb9,
	0xe1, 0x13, 0x4b, 0x34, 0xb6, 0x37, 0x0c, 0x28, 0x27, 0xab, 0x47, 0xba, 0xce, 0x55, 0xc8, 0x5d,
	0xf1, 0x05, 0x37, 0x0e, 0x2a, 0x67, 0x45, 0xe5, 0xc3, 0xbc, 0xf3, 0xd0, 0x1f, 0x1a, 0x50, 0x4e,
	0xc2, 0x7f, 0xe4, 0x20, 0xc2, 0x47, 0xa1, 0xcc, 0xd8, 0x47, 0x21, 0x33, 0xed, 0x51, 0x48, 0x1b,
	0xe4, 0xcc, 0x84, 0x83, 0xfc, 0xfe, 0x0c, 0x5f, 0x29, 0xee, 0x9e, 0x72, 0x9c, 0xfc, 0x67, 0xbc,
	0x2a, 0x3d, 0xaa, 0xbf, 0x2a, 0x55, 0xd5, 0x57, 0xa5, 0x92, 0xf6, 0xaa, 0xf4, 0xef, 0xf7, 0x84,
	0x44, 0x5e, 0x88, 0x0d, 0x44, 0x0e, 0xa7, 0xf7, 0xb8, 0x6e, 0x20, 0x1e, 0xd4, 0x0d, 0x44, 0x3d,
	0x7d, 0xcd, 0xc3, 0xea, 0x8f, 0x33, 0x90, 0xc3, 0xef, 0x23, 0x9b, 0xbc, 0xaf, 0x25, 0xcf, 0x1e,
	0x7e, 0xc9, 0xdf, 0x35, 0xa0, 0x28, 0x96, 0xfc, 0x40, 0x8f, 0x05, 0x75, 0x28, 0x08, 0x55, 0x16,
	0xde, 0xad, 0xbc, 0x0b, 0x28, 0x24, 0x6e, 0x56, 0xb0, 0x88, 0xc9, 0x41, 0xd1, 0xaf, 0x13, 0x4c,
	0x2b, 0x41, 0x3d, 0x74, 0xb6, 0xe9, 0x37, 0x0c, 0x39, 0x94, 0x4b, 0xee, 0x01, 0x42, 0xae, 0xab,
	0x50, 0x8a, 0x56, 0x41, 0x31, 0xbf, 0x29, 0x79, 0x8c, 0x11, 0x9b, 0x1c, 0x84, 0xde, 0x8e, 0xbb,
	0x41, 0x0b, 0x09, 0x96, 0xcf, 0x26, 0x11, 0x4c, 0xbb, 0x72, 0x27, 0xd3, 0xaa, 0xbe, 0x08, 0xc7,
	0x56, 0x59, 0x70, 0xdd, 0xe5, 0x77, 0x2e, 0x31, 0xda, 0x89, 0x57, 0xac, 0x12, 0xc3, 0x90, 0xaf,
	0x95, 0x19, 0x43, 0xea, 0x9d, 0xcc, 0x50, 0xef, 0x47, 0xea, 0x3c, 0x4a, 0x9d, 0x1f, 0xff, 0xed,
	0x09, 0x98, 0xe9, 0xd9, 0x1b, 0x8c, 0x74, 0xf4, 0x1f, 0xf3, 0xd5, 0xc7, 0xfe, 0x2a, 0xd0, 0x62,
	0xb7, 0xab, 0x7b, 0x70, 0xf8, 0x5d, 0x5a, 0x7d, 0xe3, 0x8f, 0x1f, 0x7d, 0x3b, 0x73, 0x82, 0x92,
	0x0b, 0xc8, 0x29, 0xfe, 0x36, 0x45, 0xff, 0x5f, 0x86, 0x5c, 0xf8, 0xb3, 0x19, 0x72, 0x3a, 0x2d,
	0x50, 0x18, 0xfd, 0xa4, 0xa6, 0x9a, 0x72, 0x8d, 0x8e, 0x7e, 0xbd, 0x40, 0xef, 0x45, 0x19, 0xc7,
	0xe8, 0x82, 0x94, 0xb1, 0xc1, 0x1b, 0xfa, 0xfd, 0x0e, 0xb1, 0x21, 0x17, 0x26, 0x17, 0xa4, 0x0a,
	0x88, 0xf3, 0x4a, 0xaa, 0xe3, 0xaa, 0xd3, 0x44, 0xf0, 0xbf, 0x5c, 0x84, 0x0b, 0x25, 0xcd, 0x9b,
	0x20, 0x74, 0x54, 0xde, 0x71, 0xec, 0x6e, 0x8c, 0x9f, 0xcd, 0x22, 0x8a, 0x3a, 0x45, 0x4f, 0xa8,
	0xa2, 0x7a, 0xbc, 0xb5, 0x98, 0x52, 0x3e, 0xd2, 0x6d, 0x52, 0x1d, 0x65, 0x1b, 0xd8, 0xed, 0xea,
	0xd2, 0x18, 0xbb, 0xc1, 0xc5, 0x54, 0x50, 0x0c, 0xa1, 0x65, 0x29, 0x06, 0x25, 0xf4, 0x78, 0xaf,
	0x2f, 0xc3, 0x9c, 0xb4, 0x6a, 0x24, 0x35, 0xc4, 0x10, 0x66, 0xd2, 0x57, 0xc7, 0xd4, 0xfa, 0x5d,
	0x7a, 0x0a, 0x05, 0x94, 0xe9, 0xbc, 0x14, 0xd0, 0xb4, 0xb7, 0xb1, 0xfb, 0xdb, 0x50, 0x54, 0x13,
	0xc6, 0xc9, 0xa8, 0x44, 0x6d, 0x45, 0xd0, 0x5e, 0x2c, 0x7e, 0x97, 0xde, 0x8f, 0xd2, 0x4e, 0xd2,
	0xe3, 0xea, 0xaa, 0x85, 0x22, 0xed, 0xf8, 0xf1, 0x3d, 0x0d, 0x07, 0x4a, 0xda, 0x77, 0x75, 0x5c,
	0x75, 0x0a, 0x0e, 0x5e, 0x65, 0xec, 0x16, 0x8a, 0xf0, 0xa0, 0xb4, 0xca, 0x82, 0xd8, 0xc6, 0x91,
	0xda, 0xb8, 0x30, 0x24, 0x97, 0x34, 0x9e, 0x21, 0x05, 0x08, 0x2d, 0x16, 0x70, 0x51, 0x3d, 0xd1,
	0x3f, 0x93, 0x01, 0x21, 0xee, 0x15, 0x93, 0xa5, 0x51, 0xf1, 0x38, 0x71, 0xb9, 0xac, 0x8e, 0xad,
	0x4f, 0x01, 0x03, 0xfe, 0xf5, 0x79, 0xcf, 0x8e, 0x48, 0x38, 0x17, 0x49, 0x11, 0x69, 0x93, 0xd2,
	0xb2, 0x54, 0xaa, 0xe3, 0x19, 0xfc, 0x2e, 0xbd, 0x0f, 0x25, 0x1d, 0xa7, 0xc7, 0xd4, 0x05, 0x14,
	0x9d, 0x33, 0x28, 0xac, 0xb2, 0x20, 0xcc, 0x1a, 0x20, 0xa3, 0x95, 0x24, 0x7d, 0x9b, 0x94, 0x74,
	0x83, 0x21, 0xab, 0xd3, 0x62, 0x41, 0xdf, 0x67, 0x3d, 0xdc, 0x29, 0x26, 0x7f, 0xbf, 0x25, 0xe1,
	0x37, 0x4d, 0x31, 0x5c, 0x46, 0x88, 0xb9, 0x2f, 0x49, 0x3f, 0xf2, 0x92, 0xdb, 0x1c, 0xab, 0xa7,
	0xa7, 0x47, 0xd4, 0x09, 0x1f, 0x62, 0x08, 0x70, 0xa8, 0xa6, 0xcc, 0x6d, 0x92, 0xaf, 0x40, 0x2e,
	0x4c, 0x49, 0x20, 0xa3, 0x7e, 0xbe, 0x2d, 0xd2, 0x15, 0xc6, 0x9b, 0x9b, 0xe4, 0xd6, 0x33, 0xb7,
	0xd9, 0xc3, 0x87, 0x7b, 0xf2, 0x2a, 0x94, 0x93, 0x8f, 0xf9, 0xe4, 0xec, 0xa8, 0xfd, 0xd5, 0x1e,
	0xfc, 0xc7, 0x4b, 0xac, 0xa1, 0xc4, 0xfb, 0xe8, 0xbd, 0x1a, 0x04, 0x78, 0x07, 0x52, 0xb0, 0x0f,
	0x0b, 0xcb, 0x5b, 0x6c, 0xe3, 0x56, 0xfc, 0x80, 0x9d, 0x06, 0x3c, 0xed, 0x05, 0xbe, 0x3a, 0x9e,
	0xc1, 0xef, 0xd2, 0x25, 0x94, 0x5a, 0xa1, 0xa7, 0xe2, 0x43, 0x62, 0xe3, 0x16, 0x82, 0x42, 0x48,
	0xf8, 0x2a, 0x7a, 0x0c, 0xfa, 0x9b, 0x24, 0x49, 0x89, 0x73, 0x0f, 0x3d, 0xf1, 0x56, 0xf7, 0x66,
	0x4a, 0xb1, 0x4f, 0x2d, 0x16, 0xdc, 0xe4, 0xf5, 0x5d, 0x2e, 0x46, 0x18, 0x8f, 0xf8, 0xf5, 0x2d,
	0x6d, 0xba, 0xda, 0x2b, 0x66, 0x75, 0x3c, 0x43, 0xba, 0xf1, 0xd8, 0x44, 0x86, 0x2d, 0xde, 0xff,
	0x6d, 0x98, 0x5f, 0xeb, 0xf3, 0x9e, 0x42, 0x77, 0x2c, 0xd5, 0x5c, 0xa9, 0xef, 0x60, 0xd5, 0xf1,
	0x0c, 0x7e, 0x97, 0x9e, 0x46, 0x89, 0xf7, 0xd2, 0x93, 0x52, 0x62, 0xb7, 0xdf, 0x6e, 0x8b, 0xb5,
	0x6d, 0x73, 0x01, 0x1d, 0xd0, 0x7f, 0x1f, 0x3e, 0xf6, 0x05, 0x61, 0x9c, 0x6f, 0x11, 0xbd, 0x71,
	0xa4, 0xfb, 0x16, 0xbe, 0xe8, 0xbf, 0x0f, 0x25, 0x2d, 0x14, 0x98, 0x76, 0x2e, 0x27, 0xa3, 0xd3,
	0xd5, 0x3d, 0x79, 0x52, 0x16, 0x76, 0xb3, 0xdf, 0x6e, 0xc7, 0xe6, 0xf2, 0x75, 0x58, 0x48, 0x84,
	0x88, 0xc8, 0x99, 0x51, 0x81, 0x1c, 0x4d, 0xf4, 0x3e, 0xb8, 0xd2, 0x40, 0x8c, 0x2c, 0xb1, 0xf8,
	0x6d, 0x98, 0xd7, 0xdd, 0xde, 0x34, 0x04, 0x0f, 0x39, 0xc6, 0xd5, 0xbd, 0x99, 0x52, 0xf6, 0xb7,
	0xc5, 0x02, 0x0f, 0x39, 0xd0, 0x24, 0x35, 0xee, 0x7b, 0xef, 0x83, 0xa5, 0x7b, 0xde, 0xfb, 0x70,
	0xc9, 0xf8, 0xc3, 0x87, 0x4b, 0xc6, 0x5f, 0x3f, 0x5c, 0x32, 0xbe, 0xfb, 0xb7, 0xa5, 0x7b, 0xbe,
	0x60, 0xda, 0x5d, 0xe7, 0xe6, 0x2c, 0xfe, 0x77, 0x8e, 0x27, 0xfe, 0x15, 0x00, 0x00, 0xff, 0xff,
	0x63, 0xea, 0x6f, 0x11, 0x09, 0x44, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RaceClient is the client API for Race service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaceClient interface {
	//获取比赛详情
	MatchDetail(ctx context.Context, in *MatchDetailReq, opts ...grpc.CallOption) (*MatchDetailRsp, error)
	//棋牌每局结算
	ChessSum(ctx context.Context, in *ChessSumReq, opts ...grpc.CallOption) (*CommonRsp, error)
	//捕鱼每局结算
	CatchSum(ctx context.Context, in *CatchSumReq, opts ...grpc.CallOption) (*CatchSumRsp, error)
	//多人快速赛局内积分上报
	CatchRoundSum(ctx context.Context, in *CatchRoundSumReq, opts ...grpc.CallOption) (*CommonRsp, error)
	//获取比赛局内排行
	RoundRank(ctx context.Context, in *RoundReq, opts ...grpc.CallOption) (*RoundRankRsp, error)
	//获取每日榜单
	DayRank(ctx context.Context, in *DayRankReq, opts ...grpc.CallOption) (*DayRankRsp, error)
	//获取奖励以及对应名但（大师赛独有）
	CatchDayRank(ctx context.Context, in *CatchDayRankReq, opts ...grpc.CallOption) (*CatchDayRankRsp, error)
	//获取每周榜单
	WeekRank(ctx context.Context, in *WeekRankReq, opts ...grpc.CallOption) (*WeekRankRsp, error)
	//获取日榜奖励
	GetRankReward(ctx context.Context, in *RankRewardReq, opts ...grpc.CallOption) (*RankRewardRsp, error)
	//比赛报名
	MatchSign(ctx context.Context, in *MatchSignReq, opts ...grpc.CallOption) (*MatchSignRsp, error)
	//本周战绩
	WeekResult(ctx context.Context, in *WeekResultReq, opts ...grpc.CallOption) (*WeekResultRsp, error)
	//获取玩家排名（按期数）
	GetUserRank(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (*UserRankRsp, error)
	//获取排名（按天数算）
	UserDayRank(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (*UserRankRsp, error)
	//比赛内一局结算发将
	RoundEnd(ctx context.Context, in *RoundReq, opts ...grpc.CallOption) (*RoundEndRsp, error)
	//比赛结束发奖
	MatchEnd(ctx context.Context, in *MatchEndReq, opts ...grpc.CallOption) (*CommonRsp, error)
	//周榜单发奖励
	WeekRewardReport(ctx context.Context, in *WeekRewardReportReq, opts ...grpc.CallOption) (*CommonRsp, error)
	//查询玩家奖励
	CheckUserReward(ctx context.Context, in *UserRewardReq, opts ...grpc.CallOption) (*UserRewardRsp, error)
	//获取浮动奖金池
	GetFloatBonusPool(ctx context.Context, in *FloatBonusPoolReq, opts ...grpc.CallOption) (*FloatBonusPoolRsp, error)
	//获取名人堂
	GetFamousHall(ctx context.Context, in *FamousHallReq, opts ...grpc.CallOption) (*FamousHallRsp, error)
	//拉去奖励的列表
	PullRewardList(ctx context.Context, in *RewardListReq, opts ...grpc.CallOption) (*RewardListRsp, error)
	//获取比赛状态
	MatchStatus(ctx context.Context, in *MatchStatusReq, opts ...grpc.CallOption) (*MatchStatusRsp, error)
	//多人同时报名
	FullMatchSign(ctx context.Context, in *FullMatchSignReq, opts ...grpc.CallOption) (*FullMatchSignRsp, error)
	// 取消报名
	CancelMatchSign(ctx context.Context, in *CancelMatchSignReq, opts ...grpc.CallOption) (*CancelMatchSignRsp, error)
	// 取消报名
	GetOnlineRound(ctx context.Context, in *GetOnlineRoundReq, opts ...grpc.CallOption) (*GetOnlineRoundRsp, error)
}

type raceClient struct {
	cc *grpc.ClientConn
}

func NewRaceClient(cc *grpc.ClientConn) RaceClient {
	return &raceClient{cc}
}

func (c *raceClient) MatchDetail(ctx context.Context, in *MatchDetailReq, opts ...grpc.CallOption) (*MatchDetailRsp, error) {
	out := new(MatchDetailRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/MatchDetail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) ChessSum(ctx context.Context, in *ChessSumReq, opts ...grpc.CallOption) (*CommonRsp, error) {
	out := new(CommonRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/ChessSum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) CatchSum(ctx context.Context, in *CatchSumReq, opts ...grpc.CallOption) (*CatchSumRsp, error) {
	out := new(CatchSumRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/CatchSum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) CatchRoundSum(ctx context.Context, in *CatchRoundSumReq, opts ...grpc.CallOption) (*CommonRsp, error) {
	out := new(CommonRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/CatchRoundSum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) RoundRank(ctx context.Context, in *RoundReq, opts ...grpc.CallOption) (*RoundRankRsp, error) {
	out := new(RoundRankRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/RoundRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) DayRank(ctx context.Context, in *DayRankReq, opts ...grpc.CallOption) (*DayRankRsp, error) {
	out := new(DayRankRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/DayRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) CatchDayRank(ctx context.Context, in *CatchDayRankReq, opts ...grpc.CallOption) (*CatchDayRankRsp, error) {
	out := new(CatchDayRankRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/CatchDayRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) WeekRank(ctx context.Context, in *WeekRankReq, opts ...grpc.CallOption) (*WeekRankRsp, error) {
	out := new(WeekRankRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/WeekRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) GetRankReward(ctx context.Context, in *RankRewardReq, opts ...grpc.CallOption) (*RankRewardRsp, error) {
	out := new(RankRewardRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/GetRankReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) MatchSign(ctx context.Context, in *MatchSignReq, opts ...grpc.CallOption) (*MatchSignRsp, error) {
	out := new(MatchSignRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/MatchSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) WeekResult(ctx context.Context, in *WeekResultReq, opts ...grpc.CallOption) (*WeekResultRsp, error) {
	out := new(WeekResultRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/WeekResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) GetUserRank(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (*UserRankRsp, error) {
	out := new(UserRankRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/GetUserRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) UserDayRank(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (*UserRankRsp, error) {
	out := new(UserRankRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/UserDayRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) RoundEnd(ctx context.Context, in *RoundReq, opts ...grpc.CallOption) (*RoundEndRsp, error) {
	out := new(RoundEndRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/RoundEnd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) MatchEnd(ctx context.Context, in *MatchEndReq, opts ...grpc.CallOption) (*CommonRsp, error) {
	out := new(CommonRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/MatchEnd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) WeekRewardReport(ctx context.Context, in *WeekRewardReportReq, opts ...grpc.CallOption) (*CommonRsp, error) {
	out := new(CommonRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/WeekRewardReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) CheckUserReward(ctx context.Context, in *UserRewardReq, opts ...grpc.CallOption) (*UserRewardRsp, error) {
	out := new(UserRewardRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/CheckUserReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) GetFloatBonusPool(ctx context.Context, in *FloatBonusPoolReq, opts ...grpc.CallOption) (*FloatBonusPoolRsp, error) {
	out := new(FloatBonusPoolRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/GetFloatBonusPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) GetFamousHall(ctx context.Context, in *FamousHallReq, opts ...grpc.CallOption) (*FamousHallRsp, error) {
	out := new(FamousHallRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/GetFamousHall", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) PullRewardList(ctx context.Context, in *RewardListReq, opts ...grpc.CallOption) (*RewardListRsp, error) {
	out := new(RewardListRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/PullRewardList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) MatchStatus(ctx context.Context, in *MatchStatusReq, opts ...grpc.CallOption) (*MatchStatusRsp, error) {
	out := new(MatchStatusRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/MatchStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) FullMatchSign(ctx context.Context, in *FullMatchSignReq, opts ...grpc.CallOption) (*FullMatchSignRsp, error) {
	out := new(FullMatchSignRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/FullMatchSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) CancelMatchSign(ctx context.Context, in *CancelMatchSignReq, opts ...grpc.CallOption) (*CancelMatchSignRsp, error) {
	out := new(CancelMatchSignRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/CancelMatchSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raceClient) GetOnlineRound(ctx context.Context, in *GetOnlineRoundReq, opts ...grpc.CallOption) (*GetOnlineRoundRsp, error) {
	out := new(GetOnlineRoundRsp)
	err := c.cc.Invoke(ctx, "/match.service.v1.race/GetOnlineRound", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaceServer is the server API for Race service.
type RaceServer interface {
	//获取比赛详情
	MatchDetail(context.Context, *MatchDetailReq) (*MatchDetailRsp, error)
	//棋牌每局结算
	ChessSum(context.Context, *ChessSumReq) (*CommonRsp, error)
	//捕鱼每局结算
	CatchSum(context.Context, *CatchSumReq) (*CatchSumRsp, error)
	//多人快速赛局内积分上报
	CatchRoundSum(context.Context, *CatchRoundSumReq) (*CommonRsp, error)
	//获取比赛局内排行
	RoundRank(context.Context, *RoundReq) (*RoundRankRsp, error)
	//获取每日榜单
	DayRank(context.Context, *DayRankReq) (*DayRankRsp, error)
	//获取奖励以及对应名但（大师赛独有）
	CatchDayRank(context.Context, *CatchDayRankReq) (*CatchDayRankRsp, error)
	//获取每周榜单
	WeekRank(context.Context, *WeekRankReq) (*WeekRankRsp, error)
	//获取日榜奖励
	GetRankReward(context.Context, *RankRewardReq) (*RankRewardRsp, error)
	//比赛报名
	MatchSign(context.Context, *MatchSignReq) (*MatchSignRsp, error)
	//本周战绩
	WeekResult(context.Context, *WeekResultReq) (*WeekResultRsp, error)
	//获取玩家排名（按期数）
	GetUserRank(context.Context, *CommonReq) (*UserRankRsp, error)
	//获取排名（按天数算）
	UserDayRank(context.Context, *CommonReq) (*UserRankRsp, error)
	//比赛内一局结算发将
	RoundEnd(context.Context, *RoundReq) (*RoundEndRsp, error)
	//比赛结束发奖
	MatchEnd(context.Context, *MatchEndReq) (*CommonRsp, error)
	//周榜单发奖励
	WeekRewardReport(context.Context, *WeekRewardReportReq) (*CommonRsp, error)
	//查询玩家奖励
	CheckUserReward(context.Context, *UserRewardReq) (*UserRewardRsp, error)
	//获取浮动奖金池
	GetFloatBonusPool(context.Context, *FloatBonusPoolReq) (*FloatBonusPoolRsp, error)
	//获取名人堂
	GetFamousHall(context.Context, *FamousHallReq) (*FamousHallRsp, error)
	//拉去奖励的列表
	PullRewardList(context.Context, *RewardListReq) (*RewardListRsp, error)
	//获取比赛状态
	MatchStatus(context.Context, *MatchStatusReq) (*MatchStatusRsp, error)
	//多人同时报名
	FullMatchSign(context.Context, *FullMatchSignReq) (*FullMatchSignRsp, error)
	// 取消报名
	CancelMatchSign(context.Context, *CancelMatchSignReq) (*CancelMatchSignRsp, error)
	// 取消报名
	GetOnlineRound(context.Context, *GetOnlineRoundReq) (*GetOnlineRoundRsp, error)
}

// UnimplementedRaceServer can be embedded to have forward compatible implementations.
type UnimplementedRaceServer struct {
}

func (*UnimplementedRaceServer) MatchDetail(ctx context.Context, req *MatchDetailReq) (*MatchDetailRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchDetail not implemented")
}
func (*UnimplementedRaceServer) ChessSum(ctx context.Context, req *ChessSumReq) (*CommonRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChessSum not implemented")
}
func (*UnimplementedRaceServer) CatchSum(ctx context.Context, req *CatchSumReq) (*CatchSumRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CatchSum not implemented")
}
func (*UnimplementedRaceServer) CatchRoundSum(ctx context.Context, req *CatchRoundSumReq) (*CommonRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CatchRoundSum not implemented")
}
func (*UnimplementedRaceServer) RoundRank(ctx context.Context, req *RoundReq) (*RoundRankRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoundRank not implemented")
}
func (*UnimplementedRaceServer) DayRank(ctx context.Context, req *DayRankReq) (*DayRankRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DayRank not implemented")
}
func (*UnimplementedRaceServer) CatchDayRank(ctx context.Context, req *CatchDayRankReq) (*CatchDayRankRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CatchDayRank not implemented")
}
func (*UnimplementedRaceServer) WeekRank(ctx context.Context, req *WeekRankReq) (*WeekRankRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WeekRank not implemented")
}
func (*UnimplementedRaceServer) GetRankReward(ctx context.Context, req *RankRewardReq) (*RankRewardRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRankReward not implemented")
}
func (*UnimplementedRaceServer) MatchSign(ctx context.Context, req *MatchSignReq) (*MatchSignRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchSign not implemented")
}
func (*UnimplementedRaceServer) WeekResult(ctx context.Context, req *WeekResultReq) (*WeekResultRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WeekResult not implemented")
}
func (*UnimplementedRaceServer) GetUserRank(ctx context.Context, req *CommonReq) (*UserRankRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserRank not implemented")
}
func (*UnimplementedRaceServer) UserDayRank(ctx context.Context, req *CommonReq) (*UserRankRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserDayRank not implemented")
}
func (*UnimplementedRaceServer) RoundEnd(ctx context.Context, req *RoundReq) (*RoundEndRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoundEnd not implemented")
}
func (*UnimplementedRaceServer) MatchEnd(ctx context.Context, req *MatchEndReq) (*CommonRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchEnd not implemented")
}
func (*UnimplementedRaceServer) WeekRewardReport(ctx context.Context, req *WeekRewardReportReq) (*CommonRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WeekRewardReport not implemented")
}
func (*UnimplementedRaceServer) CheckUserReward(ctx context.Context, req *UserRewardReq) (*UserRewardRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckUserReward not implemented")
}
func (*UnimplementedRaceServer) GetFloatBonusPool(ctx context.Context, req *FloatBonusPoolReq) (*FloatBonusPoolRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFloatBonusPool not implemented")
}
func (*UnimplementedRaceServer) GetFamousHall(ctx context.Context, req *FamousHallReq) (*FamousHallRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFamousHall not implemented")
}
func (*UnimplementedRaceServer) PullRewardList(ctx context.Context, req *RewardListReq) (*RewardListRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullRewardList not implemented")
}
func (*UnimplementedRaceServer) MatchStatus(ctx context.Context, req *MatchStatusReq) (*MatchStatusRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchStatus not implemented")
}
func (*UnimplementedRaceServer) FullMatchSign(ctx context.Context, req *FullMatchSignReq) (*FullMatchSignRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FullMatchSign not implemented")
}
func (*UnimplementedRaceServer) CancelMatchSign(ctx context.Context, req *CancelMatchSignReq) (*CancelMatchSignRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelMatchSign not implemented")
}
func (*UnimplementedRaceServer) GetOnlineRound(ctx context.Context, req *GetOnlineRoundReq) (*GetOnlineRoundRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOnlineRound not implemented")
}

func RegisterRaceServer(s *grpc.Server, srv RaceServer) {
	s.RegisterService(&_Race_serviceDesc, srv)
}

func _Race_MatchDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).MatchDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/MatchDetail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).MatchDetail(ctx, req.(*MatchDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_ChessSum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChessSumReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).ChessSum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/ChessSum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).ChessSum(ctx, req.(*ChessSumReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_CatchSum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CatchSumReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).CatchSum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/CatchSum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).CatchSum(ctx, req.(*CatchSumReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_CatchRoundSum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CatchRoundSumReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).CatchRoundSum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/CatchRoundSum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).CatchRoundSum(ctx, req.(*CatchRoundSumReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_RoundRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoundReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).RoundRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/RoundRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).RoundRank(ctx, req.(*RoundReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_DayRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DayRankReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).DayRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/DayRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).DayRank(ctx, req.(*DayRankReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_CatchDayRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CatchDayRankReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).CatchDayRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/CatchDayRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).CatchDayRank(ctx, req.(*CatchDayRankReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_WeekRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WeekRankReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).WeekRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/WeekRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).WeekRank(ctx, req.(*WeekRankReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_GetRankReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RankRewardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).GetRankReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/GetRankReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).GetRankReward(ctx, req.(*RankRewardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_MatchSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchSignReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).MatchSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/MatchSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).MatchSign(ctx, req.(*MatchSignReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_WeekResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WeekResultReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).WeekResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/WeekResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).WeekResult(ctx, req.(*WeekResultReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_GetUserRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommonReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).GetUserRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/GetUserRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).GetUserRank(ctx, req.(*CommonReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_UserDayRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommonReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).UserDayRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/UserDayRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).UserDayRank(ctx, req.(*CommonReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_RoundEnd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoundReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).RoundEnd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/RoundEnd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).RoundEnd(ctx, req.(*RoundReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_MatchEnd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchEndReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).MatchEnd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/MatchEnd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).MatchEnd(ctx, req.(*MatchEndReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_WeekRewardReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WeekRewardReportReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).WeekRewardReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/WeekRewardReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).WeekRewardReport(ctx, req.(*WeekRewardReportReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_CheckUserReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRewardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).CheckUserReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/CheckUserReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).CheckUserReward(ctx, req.(*UserRewardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_GetFloatBonusPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FloatBonusPoolReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).GetFloatBonusPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/GetFloatBonusPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).GetFloatBonusPool(ctx, req.(*FloatBonusPoolReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_GetFamousHall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FamousHallReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).GetFamousHall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/GetFamousHall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).GetFamousHall(ctx, req.(*FamousHallReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_PullRewardList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RewardListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).PullRewardList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/PullRewardList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).PullRewardList(ctx, req.(*RewardListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_MatchStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).MatchStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/MatchStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).MatchStatus(ctx, req.(*MatchStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_FullMatchSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FullMatchSignReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).FullMatchSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/FullMatchSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).FullMatchSign(ctx, req.(*FullMatchSignReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_CancelMatchSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelMatchSignReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).CancelMatchSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/CancelMatchSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).CancelMatchSign(ctx, req.(*CancelMatchSignReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Race_GetOnlineRound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOnlineRoundReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaceServer).GetOnlineRound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/match.service.v1.race/GetOnlineRound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaceServer).GetOnlineRound(ctx, req.(*GetOnlineRoundReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Race_serviceDesc = grpc.ServiceDesc{
	ServiceName: "match.service.v1.race",
	HandlerType: (*RaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MatchDetail",
			Handler:    _Race_MatchDetail_Handler,
		},
		{
			MethodName: "ChessSum",
			Handler:    _Race_ChessSum_Handler,
		},
		{
			MethodName: "CatchSum",
			Handler:    _Race_CatchSum_Handler,
		},
		{
			MethodName: "CatchRoundSum",
			Handler:    _Race_CatchRoundSum_Handler,
		},
		{
			MethodName: "RoundRank",
			Handler:    _Race_RoundRank_Handler,
		},
		{
			MethodName: "DayRank",
			Handler:    _Race_DayRank_Handler,
		},
		{
			MethodName: "CatchDayRank",
			Handler:    _Race_CatchDayRank_Handler,
		},
		{
			MethodName: "WeekRank",
			Handler:    _Race_WeekRank_Handler,
		},
		{
			MethodName: "GetRankReward",
			Handler:    _Race_GetRankReward_Handler,
		},
		{
			MethodName: "MatchSign",
			Handler:    _Race_MatchSign_Handler,
		},
		{
			MethodName: "WeekResult",
			Handler:    _Race_WeekResult_Handler,
		},
		{
			MethodName: "GetUserRank",
			Handler:    _Race_GetUserRank_Handler,
		},
		{
			MethodName: "UserDayRank",
			Handler:    _Race_UserDayRank_Handler,
		},
		{
			MethodName: "RoundEnd",
			Handler:    _Race_RoundEnd_Handler,
		},
		{
			MethodName: "MatchEnd",
			Handler:    _Race_MatchEnd_Handler,
		},
		{
			MethodName: "WeekRewardReport",
			Handler:    _Race_WeekRewardReport_Handler,
		},
		{
			MethodName: "CheckUserReward",
			Handler:    _Race_CheckUserReward_Handler,
		},
		{
			MethodName: "GetFloatBonusPool",
			Handler:    _Race_GetFloatBonusPool_Handler,
		},
		{
			MethodName: "GetFamousHall",
			Handler:    _Race_GetFamousHall_Handler,
		},
		{
			MethodName: "PullRewardList",
			Handler:    _Race_PullRewardList_Handler,
		},
		{
			MethodName: "MatchStatus",
			Handler:    _Race_MatchStatus_Handler,
		},
		{
			MethodName: "FullMatchSign",
			Handler:    _Race_FullMatchSign_Handler,
		},
		{
			MethodName: "CancelMatchSign",
			Handler:    _Race_CancelMatchSign_Handler,
		},
		{
			MethodName: "GetOnlineRound",
			Handler:    _Race_GetOnlineRound_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *MatchDetailReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchDetailReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchDetailReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Vip != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Vip))
		i--
		dAtA[i] = 0x18
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchDetailRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchDetailRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchDetailRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MatchList) > 0 {
		for iNdEx := len(m.MatchList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WeekRankRewardTime != nil {
		{
			size, err := m.WeekRankRewardTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.NextTimesRate != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NextTimesRate))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.NextVipRate != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NextVipRate))
		i--
		dAtA[i] = 0x78
	}
	if len(m.DatePropert) > 0 {
		i -= len(m.DatePropert)
		copy(dAtA[i:], m.DatePropert)
		i = encodeVarintApi(dAtA, i, uint64(len(m.DatePropert)))
		i--
		dAtA[i] = 0x72
	}
	if m.MatchStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchStatus))
		i--
		dAtA[i] = 0x68
	}
	if m.SignPay != nil {
		{
			size, err := m.SignPay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.SignConditon) > 0 {
		for iNdEx := len(m.SignConditon) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignConditon[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.MatchDate != nil {
		{
			size, err := m.MatchDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.EndType != nil {
		{
			size, err := m.EndType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.BeginType != nil {
		{
			size, err := m.BeginType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.EnterDeadline) > 0 {
		i -= len(m.EnterDeadline)
		copy(dAtA[i:], m.EnterDeadline)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EnterDeadline)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Order != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x30
	}
	if m.LimitTimes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LimitTimes))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.ID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardTimeDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardTimeDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardTimeDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardTime) > 0 {
		i -= len(m.RewardTime)
		copy(dAtA[i:], m.RewardTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RewardTime)))
		i--
		dAtA[i] = 0x12
	}
	if m.RewardDay != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RewardDay))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BeginDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeginDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeginDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CycleRate != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CycleRate))
		i--
		dAtA[i] = 0x20
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FullNums != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.FullNums))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BeginType) > 0 {
		i -= len(m.BeginType)
		copy(dAtA[i:], m.BeginType)
		i = encodeVarintApi(dAtA, i, uint64(len(m.BeginType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EndDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LimitTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LimitTime))
		i--
		dAtA[i] = 0x20
	}
	if m.EndTotal != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EndTotal))
		i--
		dAtA[i] = 0x18
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EndType) > 0 {
		i -= len(m.EndType)
		copy(dAtA[i:], m.EndType)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DateDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DateDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DateDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Day) > 0 {
		dAtA7 := make([]byte, len(m.Day)*10)
		var j6 int
		for _, num1 := range m.Day {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintApi(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Month) > 0 {
		dAtA9 := make([]byte, len(m.Month)*10)
		var j8 int
		for _, num1 := range m.Month {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintApi(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Week) > 0 {
		dAtA11 := make([]byte, len(m.Week)*10)
		var j10 int
		for _, num1 := range m.Week {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintApi(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PayDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pay) > 0 {
		for iNdEx := len(m.Pay) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pay[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MatchTimes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchTimes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ThingsDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThingsDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThingsDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Num != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChessSumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChessSumReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChessSumReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x30
	}
	if m.BetAmount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BetAmount))
		i--
		dAtA[i] = 0x28
	}
	if len(m.UserList) > 0 {
		for iNdEx := len(m.UserList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Vip != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Vip))
		i--
		dAtA[i] = 0x18
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommonRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DayRankReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DayRankReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DayRankReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x38
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x30
	}
	if m.EndRankPoint != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EndRankPoint))
		i--
		dAtA[i] = 0x28
	}
	if m.BeforeDay != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BeforeDay))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DayRankRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DayRankRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DayRankRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DayRankList) > 0 {
		for iNdEx := len(m.DayRankList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DayRankList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.SelfRankScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SelfRankScore))
		i--
		dAtA[i] = 0x20
	}
	if m.SelfRank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SelfRank))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CatchDayRankReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatchDayRankReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatchDayRankReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CatchDayRankRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatchDayRankRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatchDayRankRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DayRankList) > 0 {
		for iNdEx := len(m.DayRankList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DayRankList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.SelfRankScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SelfRankScore))
		i--
		dAtA[i] = 0x20
	}
	if m.SelfRank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SelfRank))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WeekRankReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeekRankReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeekRankReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x38
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x30
	}
	if m.EndRankPoint != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EndRankPoint))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x20
	}
	if m.WeekBefore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.WeekBefore))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WeekRankRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeekRankRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeekRankRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.WeekRankList) > 0 {
		for iNdEx := len(m.WeekRankList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WeekRankList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.SelfRankScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SelfRankScore))
		i--
		dAtA[i] = 0x20
	}
	if m.SelfRank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SelfRank))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RankDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RankRewardList) > 0 {
		for iNdEx := len(m.RankRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RankRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x18
	}
	if m.RankScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankScore))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CatchRankDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatchRankDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatchRankDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RankRewardList) > 0 {
		for iNdEx := len(m.RankRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RankRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.FinalScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.FinalScore))
		i--
		dAtA[i] = 0x18
	}
	if m.FinalUserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.FinalUserID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Rank) > 0 {
		dAtA13 := make([]byte, len(m.Rank)*10)
		var j12 int
		for _, num1 := range m.Rank {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintApi(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommonReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x28
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RankRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankRewardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankRewardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardID) > 0 {
		i -= len(m.RewardID)
		copy(dAtA[i:], m.RewardID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RewardID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RankRewardRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankRewardRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankRewardRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchSignReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchSignReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchSignReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SignThinsList) > 0 {
		for iNdEx := len(m.SignThinsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignThinsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchSignRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchSignRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchSignRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MatchSignCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchSignCount))
		i--
		dAtA[i] = 0x28
	}
	if m.Join {
		i--
		if m.Join {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.CostList) > 0 {
		for iNdEx := len(m.CostList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CostList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CatchSumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatchSumReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatchSumReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x38
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x30
	}
	if m.Vip != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Vip))
		i--
		dAtA[i] = 0x28
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x20
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CatchSumRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatchSumRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatchSumRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NextTimesAddRate != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NextTimesAddRate))
		i--
		dAtA[i] = 0x48
	}
	if m.TimesAddRate != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TimesAddRate))
		i--
		dAtA[i] = 0x40
	}
	if m.VipAddRate != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.VipAddRate))
		i--
		dAtA[i] = 0x38
	}
	if m.RankTotal != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankTotal))
		i--
		dAtA[i] = 0x30
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MaxScore))
		i--
		dAtA[i] = 0x20
	}
	if m.CurScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CurScore))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WeekResultReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeekResultReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeekResultReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x28
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WeekResultRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeekResultRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeekResultRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserRankList) > 0 {
		for iNdEx := len(m.UserRankList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserRankList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.WeekRank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.WeekRank))
		i--
		dAtA[i] = 0x20
	}
	if m.WeekScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.WeekScore))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserRankDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRankDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRankDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RankStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankStatus))
		i--
		dAtA[i] = 0x20
	}
	if m.RankRanking != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankRanking))
		i--
		dAtA[i] = 0x18
	}
	if m.RankScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankScore))
		i--
		dAtA[i] = 0x10
	}
	if m.RankDay != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankDay))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserRankRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRankRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRankRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WeekSumScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.WeekSumScore))
		i--
		dAtA[i] = 0x38
	}
	if m.DifScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DifScore))
		i--
		dAtA[i] = 0x30
	}
	if m.RankTotal != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankTotal))
		i--
		dAtA[i] = 0x28
	}
	if m.RankScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankScore))
		i--
		dAtA[i] = 0x20
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchEndReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchEndReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchEndReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WeekRewardReportReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeekRewardReportReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeekRewardReportReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRewardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRewardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserRewardRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRewardRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRewardRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x38
	}
	if len(m.ThingsList) > 0 {
		for iNdEx := len(m.ThingsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ThingsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RewardTime) > 0 {
		i -= len(m.RewardTime)
		copy(dAtA[i:], m.RewardTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RewardTime)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RankScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankScore))
		i--
		dAtA[i] = 0x20
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RewardID) > 0 {
		i -= len(m.RewardID)
		copy(dAtA[i:], m.RewardID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RewardID)))
		i--
		dAtA[i] = 0x12
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FloatBonusPoolReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatBonusPoolReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FloatBonusPoolReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FloatBonusPoolRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatBonusPoolRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FloatBonusPoolRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BonusPoolNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BonusPoolNum))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FamousHallReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FamousHallReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FamousHallReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FamousHallRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FamousHallRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FamousHallRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ChampionList) > 0 {
		for iNdEx := len(m.ChampionList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChampionList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChampionDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChampionDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChampionDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RankScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankScore))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EndDate) > 0 {
		i -= len(m.EndDate)
		copy(dAtA[i:], m.EndDate)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndDate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BeginDate) > 0 {
		i -= len(m.BeginDate)
		copy(dAtA[i:], m.BeginDate)
		i = encodeVarintApi(dAtA, i, uint64(len(m.BeginDate)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardType) > 0 {
		i -= len(m.RewardType)
		copy(dAtA[i:], m.RewardType)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RewardType)))
		i--
		dAtA[i] = 0x12
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardListRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardListRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MatchRewardList) > 0 {
		for iNdEx := len(m.MatchRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchRewardDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchRewardDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchRewardDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x10
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RankRewardDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankRewardDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankRewardDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ThingsList) > 0 {
		for iNdEx := len(m.ThingsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ThingsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Rank) > 0 {
		dAtA15 := make([]byte, len(m.Rank)*10)
		var j14 int
		for _, num1 := range m.Rank {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintApi(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MatchStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchStatusReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchStatusReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchStatusRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchStatusRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchStatusRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MatchStatusList) > 0 {
		for iNdEx := len(m.MatchStatusList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchStatusList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchStatusDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchStatusDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchStatusDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WeekRankRewardTime != nil {
		{
			size, err := m.WeekRankRewardTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.MatchStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchStatus))
		i--
		dAtA[i] = 0x50
	}
	if m.MatchDate != nil {
		{
			size, err := m.MatchDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DatePropert) > 0 {
		i -= len(m.DatePropert)
		copy(dAtA[i:], m.DatePropert)
		i = encodeVarintApi(dAtA, i, uint64(len(m.DatePropert)))
		i--
		dAtA[i] = 0x42
	}
	if m.EndType != nil {
		{
			size, err := m.EndType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.BeginType != nil {
		{
			size, err := m.BeginType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.EnterDeadline) > 0 {
		i -= len(m.EnterDeadline)
		copy(dAtA[i:], m.EnterDeadline)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EnterDeadline)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x10
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FullMatchSignReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FullMatchSignReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FullMatchSignReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PersonList) > 0 {
		for iNdEx := len(m.PersonList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PersonList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.RoundID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RoundID))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PersonDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PersonDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PersonDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SignThinsList) > 0 {
		for iNdEx := len(m.SignThinsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignThinsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FullMatchSignRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FullMatchSignRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FullMatchSignRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SignStatusList) > 0 {
		for iNdEx := len(m.SignStatusList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignStatusList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CancelMatchSignReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelMatchSignReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelMatchSignReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserList) > 0 {
		dAtA21 := make([]byte, len(m.UserList)*10)
		var j20 int
		for _, num1 := range m.UserList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintApi(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x32
	}
	if m.RoundID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RoundID))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CancelMatchSignRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelMatchSignRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelMatchSignRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserList) > 0 {
		for iNdEx := len(m.UserList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CancelSignDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelSignDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelSignDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CostList) > 0 {
		for iNdEx := len(m.CostList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CostList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IsCancel {
		i--
		if m.IsCancel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SignStatusDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignStatusDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignStatusDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CostList) > 0 {
		for iNdEx := len(m.CostList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CostList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.MatchSignCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchSignCount))
		i--
		dAtA[i] = 0x18
	}
	if m.Join {
		i--
		if m.Join {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CatchRoundSumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatchRoundSumReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatchRoundSumReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RoundID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RoundID))
		i--
		dAtA[i] = 0x40
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x38
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x30
	}
	if m.Vip != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Vip))
		i--
		dAtA[i] = 0x28
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x20
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoundReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoundReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoundReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RoundID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RoundID))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoundRankRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoundRankRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoundRankRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DayRankList) > 0 {
		for iNdEx := len(m.DayRankList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DayRankList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.RoundFinalTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RoundFinalTime))
		i--
		dAtA[i] = 0x20
	}
	if m.RoundStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RoundStatus))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoundEndRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoundEndRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoundEndRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoundRankList) > 0 {
		for iNdEx := len(m.RoundRankList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoundRankList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoundRankDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoundRankDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoundRankDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RankRewardList) > 0 {
		for iNdEx := len(m.RankRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RankRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x18
	}
	if m.RankScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankScore))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetOnlineRoundRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOnlineRoundRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOnlineRoundRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoundID) > 0 {
		dAtA23 := make([]byte, len(m.RoundID)*10)
		var j22 int
		for _, num1 := range m.RoundID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintApi(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetOnlineRoundReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOnlineRoundReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOnlineRoundReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MatchDetailReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.Vip != 0 {
		n += 1 + sovApi(uint64(m.Vip))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchDetailRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.MatchList) > 0 {
		for _, e := range m.MatchList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.LimitTimes != 0 {
		n += 1 + sovApi(uint64(m.LimitTimes))
	}
	if m.Order != 0 {
		n += 1 + sovApi(uint64(m.Order))
	}
	l = len(m.EnterDeadline)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BeginType != nil {
		l = m.BeginType.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EndType != nil {
		l = m.EndType.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchDate != nil {
		l = m.MatchDate.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.SignConditon) > 0 {
		for _, e := range m.SignConditon {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.SignPay != nil {
		l = m.SignPay.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchStatus != 0 {
		n += 1 + sovApi(uint64(m.MatchStatus))
	}
	l = len(m.DatePropert)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NextVipRate != 0 {
		n += 1 + sovApi(uint64(m.NextVipRate))
	}
	if m.NextTimesRate != 0 {
		n += 2 + sovApi(uint64(m.NextTimesRate))
	}
	if m.WeekRankRewardTime != nil {
		l = m.WeekRankRewardTime.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardTimeDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RewardDay != 0 {
		n += 1 + sovApi(uint64(m.RewardDay))
	}
	l = len(m.RewardTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BeginDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BeginType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.FullNums != 0 {
		n += 1 + sovApi(uint64(m.FullNums))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.CycleRate != 0 {
		n += 1 + sovApi(uint64(m.CycleRate))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EndDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EndType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EndTotal != 0 {
		n += 1 + sovApi(uint64(m.EndTotal))
	}
	if m.LimitTime != 0 {
		n += 1 + sovApi(uint64(m.LimitTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DateDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Week) > 0 {
		l = 0
		for _, e := range m.Week {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.Month) > 0 {
		l = 0
		for _, e := range m.Month {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.Day) > 0 {
		l = 0
		for _, e := range m.Day {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PayDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchTimes != 0 {
		n += 1 + sovApi(uint64(m.MatchTimes))
	}
	if len(m.Pay) > 0 {
		for _, e := range m.Pay {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ThingsDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChessSumReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if len(m.UserList) > 0 {
		for _, e := range m.UserList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.BetAmount != 0 {
		n += 1 + sovApi(uint64(m.BetAmount))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.Vip != 0 {
		n += 1 + sovApi(uint64(m.Vip))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DayRankReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.BeforeDay != 0 {
		n += 1 + sovApi(uint64(m.BeforeDay))
	}
	if m.EndRankPoint != 0 {
		n += 1 + sovApi(uint64(m.EndRankPoint))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DayRankRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.SelfRank != 0 {
		n += 1 + sovApi(uint64(m.SelfRank))
	}
	if m.SelfRankScore != 0 {
		n += 1 + sovApi(uint64(m.SelfRankScore))
	}
	if len(m.DayRankList) > 0 {
		for _, e := range m.DayRankList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CatchDayRankReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CatchDayRankRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.SelfRank != 0 {
		n += 1 + sovApi(uint64(m.SelfRank))
	}
	if m.SelfRankScore != 0 {
		n += 1 + sovApi(uint64(m.SelfRankScore))
	}
	if len(m.DayRankList) > 0 {
		for _, e := range m.DayRankList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WeekRankReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.WeekBefore != 0 {
		n += 1 + sovApi(uint64(m.WeekBefore))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.EndRankPoint != 0 {
		n += 1 + sovApi(uint64(m.EndRankPoint))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WeekRankRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.SelfRank != 0 {
		n += 1 + sovApi(uint64(m.SelfRank))
	}
	if m.SelfRankScore != 0 {
		n += 1 + sovApi(uint64(m.SelfRankScore))
	}
	if len(m.WeekRankList) > 0 {
		for _, e := range m.WeekRankList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.RankScore != 0 {
		n += 1 + sovApi(uint64(m.RankScore))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if len(m.RankRewardList) > 0 {
		for _, e := range m.RankRewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CatchRankDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rank) > 0 {
		l = 0
		for _, e := range m.Rank {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.FinalUserID != 0 {
		n += 1 + sovApi(uint64(m.FinalUserID))
	}
	if m.FinalScore != 0 {
		n += 1 + sovApi(uint64(m.FinalScore))
	}
	if len(m.RankRewardList) > 0 {
		for _, e := range m.RankRewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankRewardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	l = len(m.RewardID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankRewardRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchSignReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if len(m.SignThinsList) > 0 {
		for _, e := range m.SignThinsList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchSignRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.CostList) > 0 {
		for _, e := range m.CostList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Join {
		n += 2
	}
	if m.MatchSignCount != 0 {
		n += 1 + sovApi(uint64(m.MatchSignCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CatchSumReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.Vip != 0 {
		n += 1 + sovApi(uint64(m.Vip))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CatchSumRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.CurScore != 0 {
		n += 1 + sovApi(uint64(m.CurScore))
	}
	if m.MaxScore != 0 {
		n += 1 + sovApi(uint64(m.MaxScore))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.RankTotal != 0 {
		n += 1 + sovApi(uint64(m.RankTotal))
	}
	if m.VipAddRate != 0 {
		n += 1 + sovApi(uint64(m.VipAddRate))
	}
	if m.TimesAddRate != 0 {
		n += 1 + sovApi(uint64(m.TimesAddRate))
	}
	if m.NextTimesAddRate != 0 {
		n += 1 + sovApi(uint64(m.NextTimesAddRate))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WeekResultReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WeekResultRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.WeekScore != 0 {
		n += 1 + sovApi(uint64(m.WeekScore))
	}
	if m.WeekRank != 0 {
		n += 1 + sovApi(uint64(m.WeekRank))
	}
	if len(m.UserRankList) > 0 {
		for _, e := range m.UserRankList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserRankDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankDay != 0 {
		n += 1 + sovApi(uint64(m.RankDay))
	}
	if m.RankScore != 0 {
		n += 1 + sovApi(uint64(m.RankScore))
	}
	if m.RankRanking != 0 {
		n += 1 + sovApi(uint64(m.RankRanking))
	}
	if m.RankStatus != 0 {
		n += 1 + sovApi(uint64(m.RankStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserRankRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.RankScore != 0 {
		n += 1 + sovApi(uint64(m.RankScore))
	}
	if m.RankTotal != 0 {
		n += 1 + sovApi(uint64(m.RankTotal))
	}
	if m.DifScore != 0 {
		n += 1 + sovApi(uint64(m.DifScore))
	}
	if m.WeekSumScore != 0 {
		n += 1 + sovApi(uint64(m.WeekSumScore))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchEndReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WeekRewardReportReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserRewardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserRewardRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	l = len(m.RewardID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.RankScore != 0 {
		n += 1 + sovApi(uint64(m.RankScore))
	}
	l = len(m.RewardTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.ThingsList) > 0 {
		for _, e := range m.ThingsList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FloatBonusPoolReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FloatBonusPoolRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BonusPoolNum != 0 {
		n += 1 + sovApi(uint64(m.BonusPoolNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FamousHallReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FamousHallRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.ChampionList) > 0 {
		for _, e := range m.ChampionList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChampionDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	l = len(m.BeginDate)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndDate)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.RankScore != 0 {
		n += 1 + sovApi(uint64(m.RankScore))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	l = len(m.RewardType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.MatchRewardList) > 0 {
		for _, e := range m.MatchRewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchRewardDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankRewardDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rank) > 0 {
		l = 0
		for _, e := range m.Rank {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.ThingsList) > 0 {
		for _, e := range m.ThingsList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchStatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchStatusRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.MatchStatusList) > 0 {
		for _, e := range m.MatchStatusList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchStatusDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EnterDeadline)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BeginType != nil {
		l = m.BeginType.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EndType != nil {
		l = m.EndType.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DatePropert)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchDate != nil {
		l = m.MatchDate.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchStatus != 0 {
		n += 1 + sovApi(uint64(m.MatchStatus))
	}
	if m.WeekRankRewardTime != nil {
		l = m.WeekRankRewardTime.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FullMatchSignReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.RoundID != 0 {
		n += 1 + sovApi(uint64(m.RoundID))
	}
	if len(m.PersonList) > 0 {
		for _, e := range m.PersonList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PersonDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if len(m.SignThinsList) > 0 {
		for _, e := range m.SignThinsList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FullMatchSignRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.SignStatusList) > 0 {
		for _, e := range m.SignStatusList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelMatchSignReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.RoundID != 0 {
		n += 1 + sovApi(uint64(m.RoundID))
	}
	if len(m.UserList) > 0 {
		l = 0
		for _, e := range m.UserList {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelMatchSignRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.UserList) > 0 {
		for _, e := range m.UserList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelSignDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.IsCancel {
		n += 2
	}
	if len(m.CostList) > 0 {
		for _, e := range m.CostList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignStatusDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.Join {
		n += 2
	}
	if m.MatchSignCount != 0 {
		n += 1 + sovApi(uint64(m.MatchSignCount))
	}
	if len(m.CostList) > 0 {
		for _, e := range m.CostList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CatchRoundSumReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.Vip != 0 {
		n += 1 + sovApi(uint64(m.Vip))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.RoundID != 0 {
		n += 1 + sovApi(uint64(m.RoundID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoundReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.RoundID != 0 {
		n += 1 + sovApi(uint64(m.RoundID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoundRankRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.RoundStatus != 0 {
		n += 1 + sovApi(uint64(m.RoundStatus))
	}
	if m.RoundFinalTime != 0 {
		n += 1 + sovApi(uint64(m.RoundFinalTime))
	}
	if len(m.DayRankList) > 0 {
		for _, e := range m.DayRankList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoundEndRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.RoundRankList) > 0 {
		for _, e := range m.RoundRankList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoundRankDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.RankScore != 0 {
		n += 1 + sovApi(uint64(m.RankScore))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if len(m.RankRewardList) > 0 {
		for _, e := range m.RankRewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetOnlineRoundRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.RoundID) > 0 {
		l = 0
		for _, e := range m.RoundID {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetOnlineRoundReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MatchDetailReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchDetailReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchDetailReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchDetailRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchDetailRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchDetailRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchList = append(m.MatchList, &MatchDetail{})
			if err := m.MatchList[len(m.MatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitTimes", wireType)
			}
			m.LimitTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterDeadline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnterDeadline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BeginType == nil {
				m.BeginType = &BeginDetail{}
			}
			if err := m.BeginType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndType == nil {
				m.EndType = &EndDetail{}
			}
			if err := m.EndType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchDate == nil {
				m.MatchDate = &DateDetail{}
			}
			if err := m.MatchDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignConditon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignConditon = append(m.SignConditon, &ThingsDetail{})
			if err := m.SignConditon[len(m.SignConditon)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignPay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignPay == nil {
				m.SignPay = &PayDetail{}
			}
			if err := m.SignPay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchStatus", wireType)
			}
			m.MatchStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatePropert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatePropert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextVipRate", wireType)
			}
			m.NextVipRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextVipRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTimesRate", wireType)
			}
			m.NextTimesRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextTimesRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekRankRewardTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WeekRankRewardTime == nil {
				m.WeekRankRewardTime = &RewardTimeDetail{}
			}
			if err := m.WeekRankRewardTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardTimeDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardTimeDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardTimeDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardDay", wireType)
			}
			m.RewardDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardDay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeginDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeginDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeginDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BeginType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullNums", wireType)
			}
			m.FullNums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullNums |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CycleRate", wireType)
			}
			m.CycleRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CycleRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTotal", wireType)
			}
			m.EndTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitTime", wireType)
			}
			m.LimitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DateDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DateDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DateDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Week = append(m.Week, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Week) == 0 {
					m.Week = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Week = append(m.Week, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Week", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Month = append(m.Month, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Month) == 0 {
					m.Month = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Month = append(m.Month, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Month", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Day = append(m.Day, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Day) == 0 {
					m.Day = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Day = append(m.Day, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Day", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchTimes", wireType)
			}
			m.MatchTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pay = append(m.Pay, &ThingsDetail{})
			if err := m.Pay[len(m.Pay)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThingsDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThingsDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThingsDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChessSumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChessSumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChessSumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserList = append(m.UserList, &UserDetails{})
			if err := m.UserList[len(m.UserList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetAmount", wireType)
			}
			m.BetAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BetAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DayRankReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DayRankReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DayRankReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeforeDay", wireType)
			}
			m.BeforeDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeforeDay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndRankPoint", wireType)
			}
			m.EndRankPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndRankPoint |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DayRankRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DayRankRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DayRankRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfRank", wireType)
			}
			m.SelfRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfRank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfRankScore", wireType)
			}
			m.SelfRankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfRankScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayRankList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DayRankList = append(m.DayRankList, &RankDetail{})
			if err := m.DayRankList[len(m.DayRankList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatchDayRankReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatchDayRankReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatchDayRankReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatchDayRankRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatchDayRankRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatchDayRankRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfRank", wireType)
			}
			m.SelfRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfRank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfRankScore", wireType)
			}
			m.SelfRankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfRankScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayRankList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DayRankList = append(m.DayRankList, &CatchRankDetail{})
			if err := m.DayRankList[len(m.DayRankList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeekRankReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeekRankReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeekRankReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekBefore", wireType)
			}
			m.WeekBefore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeekBefore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndRankPoint", wireType)
			}
			m.EndRankPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndRankPoint |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeekRankRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeekRankRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeekRankRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfRank", wireType)
			}
			m.SelfRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfRank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfRankScore", wireType)
			}
			m.SelfRankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfRankScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekRankList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WeekRankList = append(m.WeekRankList, &RankDetail{})
			if err := m.WeekRankList[len(m.WeekRankList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankScore", wireType)
			}
			m.RankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankRewardList = append(m.RankRewardList, &ThingsDetail{})
			if err := m.RankRewardList[len(m.RankRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatchRankDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatchRankDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatchRankDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Rank = append(m.Rank, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Rank) == 0 {
					m.Rank = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Rank = append(m.Rank, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalUserID", wireType)
			}
			m.FinalUserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalUserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalScore", wireType)
			}
			m.FinalScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankRewardList = append(m.RankRewardList, &ThingsDetail{})
			if err := m.RankRewardList[len(m.RankRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankRewardRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankRewardRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankRewardRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ThingsDetail{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchSignReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchSignReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchSignReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignThinsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignThinsList = append(m.SignThinsList, &ThingsDetail{})
			if err := m.SignThinsList[len(m.SignThinsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchSignRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchSignRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchSignRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CostList = append(m.CostList, &ThingsDetail{})
			if err := m.CostList[len(m.CostList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Join = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchSignCount", wireType)
			}
			m.MatchSignCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchSignCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatchSumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatchSumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatchSumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatchSumRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatchSumRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatchSumRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurScore", wireType)
			}
			m.CurScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxScore", wireType)
			}
			m.MaxScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankTotal", wireType)
			}
			m.RankTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipAddRate", wireType)
			}
			m.VipAddRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipAddRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimesAddRate", wireType)
			}
			m.TimesAddRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimesAddRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTimesAddRate", wireType)
			}
			m.NextTimesAddRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextTimesAddRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeekResultReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeekResultReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeekResultReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeekResultRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeekResultRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeekResultRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekScore", wireType)
			}
			m.WeekScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeekScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekRank", wireType)
			}
			m.WeekRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeekRank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserRankList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserRankList = append(m.UserRankList, &UserRankDetail{})
			if err := m.UserRankList[len(m.UserRankList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRankDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRankDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRankDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankDay", wireType)
			}
			m.RankDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankDay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankScore", wireType)
			}
			m.RankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankRanking", wireType)
			}
			m.RankRanking = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankRanking |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankStatus", wireType)
			}
			m.RankStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRankRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRankRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRankRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankScore", wireType)
			}
			m.RankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankTotal", wireType)
			}
			m.RankTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DifScore", wireType)
			}
			m.DifScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DifScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekSumScore", wireType)
			}
			m.WeekSumScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeekSumScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchEndReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchEndReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchEndReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeekRewardReportReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeekRewardReportReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeekRewardReportReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRewardRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRewardRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRewardRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &RewardDetail{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankScore", wireType)
			}
			m.RankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThingsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThingsList = append(m.ThingsList, &ThingsDetail{})
			if err := m.ThingsList[len(m.ThingsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatBonusPoolReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatBonusPoolReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatBonusPoolReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatBonusPoolRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatBonusPoolRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatBonusPoolRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusPoolNum", wireType)
			}
			m.BonusPoolNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BonusPoolNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FamousHallReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FamousHallReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FamousHallReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FamousHallRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FamousHallRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FamousHallRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChampionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChampionList = append(m.ChampionList, &ChampionDetail{})
			if err := m.ChampionList[len(m.ChampionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChampionDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChampionDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChampionDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BeginDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankScore", wireType)
			}
			m.RankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchRewardList = append(m.MatchRewardList, &MatchRewardDetail{})
			if err := m.MatchRewardList[len(m.MatchRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchRewardDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchRewardDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchRewardDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &RankRewardDetail{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankRewardDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankRewardDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankRewardDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Rank = append(m.Rank, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Rank) == 0 {
					m.Rank = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Rank = append(m.Rank, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThingsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThingsList = append(m.ThingsList, &ThingsDetail{})
			if err := m.ThingsList[len(m.ThingsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchStatusRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchStatusRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchStatusRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchStatusList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchStatusList = append(m.MatchStatusList, &MatchStatusDetail{})
			if err := m.MatchStatusList[len(m.MatchStatusList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchStatusDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchStatusDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchStatusDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterDeadline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnterDeadline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BeginType == nil {
				m.BeginType = &BeginDetail{}
			}
			if err := m.BeginType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndType == nil {
				m.EndType = &EndDetail{}
			}
			if err := m.EndType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatePropert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatePropert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchDate == nil {
				m.MatchDate = &DateDetail{}
			}
			if err := m.MatchDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchStatus", wireType)
			}
			m.MatchStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekRankRewardTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WeekRankRewardTime == nil {
				m.WeekRankRewardTime = &RewardTimeDetail{}
			}
			if err := m.WeekRankRewardTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FullMatchSignReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FullMatchSignReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FullMatchSignReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundID", wireType)
			}
			m.RoundID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonList = append(m.PersonList, &PersonDetail{})
			if err := m.PersonList[len(m.PersonList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersonDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersonDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersonDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignThinsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignThinsList = append(m.SignThinsList, &ThingsDetail{})
			if err := m.SignThinsList[len(m.SignThinsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FullMatchSignRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FullMatchSignRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FullMatchSignRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignStatusList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignStatusList = append(m.SignStatusList, &SignStatusDetail{})
			if err := m.SignStatusList[len(m.SignStatusList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelMatchSignReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelMatchSignReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelMatchSignReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundID", wireType)
			}
			m.RoundID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserList = append(m.UserList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserList) == 0 {
					m.UserList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserList = append(m.UserList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelMatchSignRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelMatchSignRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelMatchSignRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserList = append(m.UserList, &CancelSignDetail{})
			if err := m.UserList[len(m.UserList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelSignDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelSignDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelSignDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCancel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCancel = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CostList = append(m.CostList, &ThingsDetail{})
			if err := m.CostList[len(m.CostList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignStatusDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignStatusDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignStatusDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Join = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchSignCount", wireType)
			}
			m.MatchSignCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchSignCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CostList = append(m.CostList, &ThingsDetail{})
			if err := m.CostList[len(m.CostList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatchRoundSumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatchRoundSumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatchRoundSumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundID", wireType)
			}
			m.RoundID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoundReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoundReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoundReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundID", wireType)
			}
			m.RoundID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoundRankRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoundRankRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoundRankRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundStatus", wireType)
			}
			m.RoundStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundFinalTime", wireType)
			}
			m.RoundFinalTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundFinalTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayRankList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DayRankList = append(m.DayRankList, &RankDetail{})
			if err := m.DayRankList[len(m.DayRankList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoundEndRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoundEndRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoundEndRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundRankList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoundRankList = append(m.RoundRankList, &RoundRankDetail{})
			if err := m.RoundRankList[len(m.RoundRankList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoundRankDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoundRankDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoundRankDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankScore", wireType)
			}
			m.RankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankRewardList = append(m.RankRewardList, &RewardDetail{})
			if err := m.RankRewardList[len(m.RankRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOnlineRoundRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOnlineRoundRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOnlineRoundRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RoundID = append(m.RoundID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RoundID) == 0 {
					m.RoundID = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RoundID = append(m.RoundID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOnlineRoundReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOnlineRoundReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOnlineRoundReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
