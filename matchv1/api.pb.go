// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

// package 命名使用 {appid}.{version} 的方式, version 形如 v1, v2 ..

package api

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type MatchV1ErrCode int32

const (
	MatchV1ErrCode_ThingNotModify       MatchV1ErrCode = 0
	MatchV1ErrCode_GetConfigFail        MatchV1ErrCode = 20100
	MatchV1ErrCode_UserNotSign          MatchV1ErrCode = 20101
	MatchV1ErrCode_NotFullSignCondition MatchV1ErrCode = 20102
	MatchV1ErrCode_NotFullSignPay       MatchV1ErrCode = 20103
	MatchV1ErrCode_SignFail             MatchV1ErrCode = 20104
	MatchV1ErrCode_CancelSignFail       MatchV1ErrCode = 20105
)

var MatchV1ErrCode_name = map[int32]string{
	0:     "ThingNotModify",
	20100: "GetConfigFail",
	20101: "UserNotSign",
	20102: "NotFullSignCondition",
	20103: "NotFullSignPay",
	20104: "SignFail",
	20105: "CancelSignFail",
}

var MatchV1ErrCode_value = map[string]int32{
	"ThingNotModify":       0,
	"GetConfigFail":        20100,
	"UserNotSign":          20101,
	"NotFullSignCondition": 20102,
	"NotFullSignPay":       20103,
	"SignFail":             20104,
	"CancelSignFail":       20105,
}

func (x MatchV1ErrCode) String() string {
	return proto.EnumName(MatchV1ErrCode_name, int32(x))
}

func (MatchV1ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

type MatchV1StatusCode int32

const (
	MatchV1StatusCode_MatchStatusInit   MatchV1StatusCode = 0
	MatchV1StatusCode_MatchNotBegin     MatchV1StatusCode = 1
	MatchV1StatusCode_Matching          MatchV1StatusCode = 2
	MatchV1StatusCode_MatchPre          MatchV1StatusCode = 3
	MatchV1StatusCode_MatchFinal        MatchV1StatusCode = 4
	MatchV1StatusCode_MatchEnd          MatchV1StatusCode = 5
	MatchV1StatusCode_MatchDeadLine     MatchV1StatusCode = 6
	MatchV1StatusCode_NotMatchDate      MatchV1StatusCode = 7
	MatchV1StatusCode_MatchBonusPreHeat MatchV1StatusCode = 8
)

var MatchV1StatusCode_name = map[int32]string{
	0: "MatchStatusInit",
	1: "MatchNotBegin",
	2: "Matching",
	3: "MatchPre",
	4: "MatchFinal",
	5: "MatchEnd",
	6: "MatchDeadLine",
	7: "NotMatchDate",
	8: "MatchBonusPreHeat",
}

var MatchV1StatusCode_value = map[string]int32{
	"MatchStatusInit":   0,
	"MatchNotBegin":     1,
	"Matching":          2,
	"MatchPre":          3,
	"MatchFinal":        4,
	"MatchEnd":          5,
	"MatchDeadLine":     6,
	"NotMatchDate":      7,
	"MatchBonusPreHeat": 8,
}

func (x MatchV1StatusCode) String() string {
	return proto.EnumName(MatchV1StatusCode_name, int32(x))
}

func (MatchV1StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}

type MatchV1UserStatusCode int32

const (
	MatchV1UserStatusCode_UserStatusInit MatchV1UserStatusCode = 0
	MatchV1UserStatusCode_UserSignNot    MatchV1UserStatusCode = 1
	MatchV1UserStatusCode_UserOut        MatchV1UserStatusCode = 2
	MatchV1UserStatusCode_UserAllowEnter MatchV1UserStatusCode = 3
	MatchV1UserStatusCode_UserNotEnter   MatchV1UserStatusCode = 4
)

var MatchV1UserStatusCode_name = map[int32]string{
	0: "UserStatusInit",
	1: "UserSignNot",
	2: "UserOut",
	3: "UserAllowEnter",
	4: "UserNotEnter",
}

var MatchV1UserStatusCode_value = map[string]int32{
	"UserStatusInit": 0,
	"UserSignNot":    1,
	"UserOut":        2,
	"UserAllowEnter": 3,
	"UserNotEnter":   4,
}

func (x MatchV1UserStatusCode) String() string {
	return proto.EnumName(MatchV1UserStatusCode_name, int32(x))
}

func (MatchV1UserStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}

type MatchListReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchListReq) Reset()         { *m = MatchListReq{} }
func (m *MatchListReq) String() string { return proto.CompactTextString(m) }
func (*MatchListReq) ProtoMessage()    {}
func (*MatchListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *MatchListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchListReq.Merge(m, src)
}
func (m *MatchListReq) XXX_Size() int {
	return m.Size()
}
func (m *MatchListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchListReq.DiscardUnknown(m)
}

var xxx_messageInfo_MatchListReq proto.InternalMessageInfo

type MatchListRsp struct {
	MatchList            []*TargetMatchDetail `protobuf:"bytes,3,rep,name=MatchList,proto3" json:"MatchList"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *MatchListRsp) Reset()         { *m = MatchListRsp{} }
func (m *MatchListRsp) String() string { return proto.CompactTextString(m) }
func (*MatchListRsp) ProtoMessage()    {}
func (*MatchListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *MatchListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchListRsp.Merge(m, src)
}
func (m *MatchListRsp) XXX_Size() int {
	return m.Size()
}
func (m *MatchListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_MatchListRsp proto.InternalMessageInfo

type TargetMatchDetail struct {
	Name                 string                `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name" form:"Name" `
	ID                   int32                 `protobuf:"varint,2,opt,name=ID,proto3" json:"ID" form:"ID" `
	ArenaID              int32                 `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID" `
	ArenaTimeID          int32                 `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID" `
	LimitTimes           int32                 `protobuf:"varint,5,opt,name=LimitTimes,proto3" json:"LimitTimes" form:"LimitTimes" `
	Order                int32                 `protobuf:"varint,6,opt,name=Order,proto3" json:"Order" form:"Order" `
	EnterDeadline        string                `protobuf:"bytes,7,opt,name=EnterDeadline,proto3" json:"EnterDeadline" form:"EnterDeadline" `
	BeginType            *BeginDetail          `protobuf:"bytes,8,opt,name=BeginType,proto3" json:"BeginType" form:"BeginType" `
	EndType              *EndDetail            `protobuf:"bytes,9,opt,name=EndType,proto3" json:"EndType" form:"EndType" `
	MatchDate            *DateDetail           `protobuf:"bytes,10,opt,name=MatchDate,proto3" json:"MatchDate" form:"MatchDate" `
	SignCondition        []*ThingsDetail       `protobuf:"bytes,11,rep,name=SignCondition,proto3" json:"SignCondition" form:"SignCondition" `
	SignPay              *PayDetail            `protobuf:"bytes,12,opt,name=SignPay,proto3" json:"SignPay" form:"SignPay" `
	MatchStatus          MatchV1StatusCode     `protobuf:"varint,13,opt,name=MatchStatus,proto3,enum=matchv1.service.v1.MatchV1StatusCode" json:"MatchStatus" form:"MatchStatus" `
	DateProperty         string                `protobuf:"bytes,14,opt,name=DateProperty,proto3" json:"DateProperty" form:"DateProperty" `
	EnterUserNum         int64                 `protobuf:"varint,15,opt,name=EnterUserNum,proto3" json:"EnterUserNum" form:"EnterUserNum" `
	UserStatus           MatchV1UserStatusCode `protobuf:"varint,16,opt,name=UserStatus,proto3,enum=matchv1.service.v1.MatchV1UserStatusCode" json:"UserStatus" form:"UserStatus" `
	ShowRankReward       []*RewardConfig       `protobuf:"bytes,17,rep,name=ShowRankReward,proto3" json:"ShowRankReward" form:"ShowRankReward" `
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TargetMatchDetail) Reset()         { *m = TargetMatchDetail{} }
func (m *TargetMatchDetail) String() string { return proto.CompactTextString(m) }
func (*TargetMatchDetail) ProtoMessage()    {}
func (*TargetMatchDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *TargetMatchDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetMatchDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetMatchDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetMatchDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetMatchDetail.Merge(m, src)
}
func (m *TargetMatchDetail) XXX_Size() int {
	return m.Size()
}
func (m *TargetMatchDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetMatchDetail.DiscardUnknown(m)
}

var xxx_messageInfo_TargetMatchDetail proto.InternalMessageInfo

type BeginDetail struct {
	BeginType            string   `protobuf:"bytes,1,opt,name=BeginType,proto3" json:"BeginType" form:"BeginType" `
	FullNums             int32    `protobuf:"varint,2,opt,name=FullNums,proto3" json:"FullNums" form:"FullNums" `
	StartTime            string   `protobuf:"bytes,3,opt,name=StartTime,proto3" json:"StartTime" form:"StartTime" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BeginDetail) Reset()         { *m = BeginDetail{} }
func (m *BeginDetail) String() string { return proto.CompactTextString(m) }
func (*BeginDetail) ProtoMessage()    {}
func (*BeginDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *BeginDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeginDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeginDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeginDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeginDetail.Merge(m, src)
}
func (m *BeginDetail) XXX_Size() int {
	return m.Size()
}
func (m *BeginDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_BeginDetail.DiscardUnknown(m)
}

var xxx_messageInfo_BeginDetail proto.InternalMessageInfo

type EndDetail struct {
	EndType              string   `protobuf:"bytes,1,opt,name=EndType,proto3" json:"BeginType" form:"BeginType"`
	EndTime              string   `protobuf:"bytes,2,opt,name=EndTime,proto3" json:"EndTime" form:"EndTime"`
	EndTotal             int32    `protobuf:"varint,3,opt,name=EndTotal,proto3" json:"EndTotal" form:"EndTotal"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EndDetail) Reset()         { *m = EndDetail{} }
func (m *EndDetail) String() string { return proto.CompactTextString(m) }
func (*EndDetail) ProtoMessage()    {}
func (*EndDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *EndDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EndDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EndDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndDetail.Merge(m, src)
}
func (m *EndDetail) XXX_Size() int {
	return m.Size()
}
func (m *EndDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_EndDetail.DiscardUnknown(m)
}

var xxx_messageInfo_EndDetail proto.InternalMessageInfo

type DateDetail struct {
	Week                 []int32  `protobuf:"varint,1,rep,packed,name=Week,proto3" json:"Week" form:"Week"`
	Month                []int32  `protobuf:"varint,2,rep,packed,name=Month,proto3" json:"Month" form:"Month"`
	Day                  []int32  `protobuf:"varint,3,rep,packed,name=Day,proto3" json:"Day" form:"Day"`
	MonthEndDay          []string `protobuf:"bytes,4,rep,name=MonthEndDay,proto3" json:"MonthEndDay" form:"MonthEndDay"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DateDetail) Reset()         { *m = DateDetail{} }
func (m *DateDetail) String() string { return proto.CompactTextString(m) }
func (*DateDetail) ProtoMessage()    {}
func (*DateDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *DateDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DateDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DateDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DateDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DateDetail.Merge(m, src)
}
func (m *DateDetail) XXX_Size() int {
	return m.Size()
}
func (m *DateDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_DateDetail.DiscardUnknown(m)
}

var xxx_messageInfo_DateDetail proto.InternalMessageInfo

type PayDetail struct {
	MatchTimes           int32           `protobuf:"varint,1,opt,name=MatchTimes,proto3" json:"MatchTimes" form:"MatchTimes"`
	Pay                  []*ThingsDetail `protobuf:"bytes,2,rep,name=Pay,proto3" json:"ThingsDetail" form:"ThingsDetail"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PayDetail) Reset()         { *m = PayDetail{} }
func (m *PayDetail) String() string { return proto.CompactTextString(m) }
func (*PayDetail) ProtoMessage()    {}
func (*PayDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *PayDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayDetail.Merge(m, src)
}
func (m *PayDetail) XXX_Size() int {
	return m.Size()
}
func (m *PayDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_PayDetail.DiscardUnknown(m)
}

var xxx_messageInfo_PayDetail proto.InternalMessageInfo

type ThingsDetail struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID" form:"ID"`
	Num                  int64    `protobuf:"varint,2,opt,name=Num,proto3" json:"Num" form:"Num"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ThingsDetail) Reset()         { *m = ThingsDetail{} }
func (m *ThingsDetail) String() string { return proto.CompactTextString(m) }
func (*ThingsDetail) ProtoMessage()    {}
func (*ThingsDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *ThingsDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThingsDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThingsDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThingsDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThingsDetail.Merge(m, src)
}
func (m *ThingsDetail) XXX_Size() int {
	return m.Size()
}
func (m *ThingsDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_ThingsDetail.DiscardUnknown(m)
}

var xxx_messageInfo_ThingsDetail proto.InternalMessageInfo

type GetRewardConfigReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	UserID               int64    `protobuf:"varint,4,opt,name=UserID,proto3" json:"UserID" form:"UserID" `
	ArenaTimeID          int32    `protobuf:"varint,5,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRewardConfigReq) Reset()         { *m = GetRewardConfigReq{} }
func (m *GetRewardConfigReq) String() string { return proto.CompactTextString(m) }
func (*GetRewardConfigReq) ProtoMessage()    {}
func (*GetRewardConfigReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *GetRewardConfigReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRewardConfigReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRewardConfigReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRewardConfigReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRewardConfigReq.Merge(m, src)
}
func (m *GetRewardConfigReq) XXX_Size() int {
	return m.Size()
}
func (m *GetRewardConfigReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRewardConfigReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetRewardConfigReq proto.InternalMessageInfo

type GetRewardConfigRsp struct {
	RewardConfigList     []*RewardConfig `protobuf:"bytes,1,rep,name=RewardConfigList,proto3" json:"RewardConfigList" form:"RewardConfigList" `
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetRewardConfigRsp) Reset()         { *m = GetRewardConfigRsp{} }
func (m *GetRewardConfigRsp) String() string { return proto.CompactTextString(m) }
func (*GetRewardConfigRsp) ProtoMessage()    {}
func (*GetRewardConfigRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *GetRewardConfigRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRewardConfigRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRewardConfigRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRewardConfigRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRewardConfigRsp.Merge(m, src)
}
func (m *GetRewardConfigRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetRewardConfigRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRewardConfigRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetRewardConfigRsp proto.InternalMessageInfo

type RewardConfig struct {
	Rank                 []int32              `protobuf:"varint,1,rep,packed,name=Rank,proto3" json:"Rank" form:"Rank" `
	DayRankList          []*RewardThinsDetail `protobuf:"bytes,2,rep,name=DayRankList,proto3" json:"DayRankList" form:"DayRankList" `
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *RewardConfig) Reset()         { *m = RewardConfig{} }
func (m *RewardConfig) String() string { return proto.CompactTextString(m) }
func (*RewardConfig) ProtoMessage()    {}
func (*RewardConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *RewardConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardConfig.Merge(m, src)
}
func (m *RewardConfig) XXX_Size() int {
	return m.Size()
}
func (m *RewardConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RewardConfig proto.InternalMessageInfo

type RewardThinsDetail struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID" form:"ID"`
	IsRate               bool     `protobuf:"varint,2,opt,name=IsRate,proto3" json:"IsRate" form:"IsRate"`
	Num                  int64    `protobuf:"varint,3,opt,name=Num,proto3" json:"Num" form:"Num"`
	Rate                 float32  `protobuf:"fixed32,4,opt,name=Rate,proto3" json:"Rate" form:"Rate"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RewardThinsDetail) Reset()         { *m = RewardThinsDetail{} }
func (m *RewardThinsDetail) String() string { return proto.CompactTextString(m) }
func (*RewardThinsDetail) ProtoMessage()    {}
func (*RewardThinsDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *RewardThinsDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardThinsDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardThinsDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardThinsDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardThinsDetail.Merge(m, src)
}
func (m *RewardThinsDetail) XXX_Size() int {
	return m.Size()
}
func (m *RewardThinsDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardThinsDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RewardThinsDetail proto.InternalMessageInfo

type RewardDetail struct {
	Rank                 []int32       `protobuf:"varint,1,rep,packed,name=Rank,proto3" json:"Rank" form:"Rank" `
	DayRankList          []*RankDetail `protobuf:"bytes,2,rep,name=DayRankList,proto3" json:"DayRankList" form:"DayRankList" `
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RewardDetail) Reset()         { *m = RewardDetail{} }
func (m *RewardDetail) String() string { return proto.CompactTextString(m) }
func (*RewardDetail) ProtoMessage()    {}
func (*RewardDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *RewardDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardDetail.Merge(m, src)
}
func (m *RewardDetail) XXX_Size() int {
	return m.Size()
}
func (m *RewardDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RewardDetail proto.InternalMessageInfo

type ScoreUploadReq struct {
	GameID               int32          `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32          `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32          `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32          `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	UserList             []*UserDetails `protobuf:"bytes,5,rep,name=UserList,proto3" json:"UserList" form:"UserList" validate:"required"`
	BetAmount            int64          `protobuf:"varint,6,opt,name=BetAmount,proto3" json:"BetAmount" form:"BetAmount" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ScoreUploadReq) Reset()         { *m = ScoreUploadReq{} }
func (m *ScoreUploadReq) String() string { return proto.CompactTextString(m) }
func (*ScoreUploadReq) ProtoMessage()    {}
func (*ScoreUploadReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *ScoreUploadReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScoreUploadReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScoreUploadReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScoreUploadReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScoreUploadReq.Merge(m, src)
}
func (m *ScoreUploadReq) XXX_Size() int {
	return m.Size()
}
func (m *ScoreUploadReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ScoreUploadReq.DiscardUnknown(m)
}

var xxx_messageInfo_ScoreUploadReq proto.InternalMessageInfo

type CommonRsp struct {
	Success              bool     `protobuf:"varint,1,opt,name=Success,proto3" json:"Success" form:"Success" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonRsp) Reset()         { *m = CommonRsp{} }
func (m *CommonRsp) String() string { return proto.CompactTextString(m) }
func (*CommonRsp) ProtoMessage()    {}
func (*CommonRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *CommonRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonRsp.Merge(m, src)
}
func (m *CommonRsp) XXX_Size() int {
	return m.Size()
}
func (m *CommonRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CommonRsp proto.InternalMessageInfo

type UserDetails struct {
	UserID               int64    `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	Score                int64    `protobuf:"varint,2,opt,name=Score,proto3" json:"Score" form:"Score"`
	VirtualBet           int64    `protobuf:"varint,3,opt,name=VirtualBet,proto3" json:"VirtualBet" form:"VirtualBet" `
	AddScore             int64    `protobuf:"varint,4,opt,name=AddScore,proto3" json:"AddScore" form:"AddScore"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserDetails) Reset()         { *m = UserDetails{} }
func (m *UserDetails) String() string { return proto.CompactTextString(m) }
func (*UserDetails) ProtoMessage()    {}
func (*UserDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *UserDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserDetails.Merge(m, src)
}
func (m *UserDetails) XXX_Size() int {
	return m.Size()
}
func (m *UserDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_UserDetails.DiscardUnknown(m)
}

var xxx_messageInfo_UserDetails proto.InternalMessageInfo

type ImmediateRankReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	StartPoint           int64    `protobuf:"varint,4,opt,name=StartPoint,proto3" json:"StartPoint" form:"StartPoint"`
	EndPoint             int64    `protobuf:"varint,5,opt,name=EndPoint,proto3" json:"EndPoint" form:"EndPoint"`
	UserID               int64    `protobuf:"varint,6,opt,name=UserID,proto3" json:"UserID" form:"UserID"`
	ArenaTimeID          int32    `protobuf:"varint,7,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImmediateRankReq) Reset()         { *m = ImmediateRankReq{} }
func (m *ImmediateRankReq) String() string { return proto.CompactTextString(m) }
func (*ImmediateRankReq) ProtoMessage()    {}
func (*ImmediateRankReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *ImmediateRankReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImmediateRankReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImmediateRankReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImmediateRankReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImmediateRankReq.Merge(m, src)
}
func (m *ImmediateRankReq) XXX_Size() int {
	return m.Size()
}
func (m *ImmediateRankReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ImmediateRankReq.DiscardUnknown(m)
}

var xxx_messageInfo_ImmediateRankReq proto.InternalMessageInfo

type ImmediateRankRsp struct {
	DayRankList          []*RankDetail `protobuf:"bytes,1,rep,name=DayRankList,proto3" json:"DayRankList" form:"DayRankList" `
	SelfMatchRank        *RankDetail   `protobuf:"bytes,2,opt,name=SelfMatchRank,proto3" json:"SelfMatchRank" form:"SelfMatchRank" `
	BeginTime            int64         `protobuf:"varint,3,opt,name=BeginTime,proto3" json:"BeginTime" form:"BeginTime"`
	EndTime              int64         `protobuf:"varint,4,opt,name=EndTime,proto3" json:"EndTime" form:"EndTime"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ImmediateRankRsp) Reset()         { *m = ImmediateRankRsp{} }
func (m *ImmediateRankRsp) String() string { return proto.CompactTextString(m) }
func (*ImmediateRankRsp) ProtoMessage()    {}
func (*ImmediateRankRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *ImmediateRankRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImmediateRankRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImmediateRankRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImmediateRankRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImmediateRankRsp.Merge(m, src)
}
func (m *ImmediateRankRsp) XXX_Size() int {
	return m.Size()
}
func (m *ImmediateRankRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ImmediateRankRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ImmediateRankRsp proto.InternalMessageInfo

type LastRankReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	LastRankNum          int32    `protobuf:"varint,4,opt,name=LastRankNum,proto3" json:"LastRankNum" form:"LastRankNum" validate:"required"`
	StartPoint           int64    `protobuf:"varint,5,opt,name=StartPoint,proto3" json:"StartPoint" form:"StartPoint"`
	EndPoint             int64    `protobuf:"varint,6,opt,name=EndPoint,proto3" json:"EndPoint" form:"EndPoint"`
	UserID               int64    `protobuf:"varint,7,opt,name=UserID,proto3" json:"UserID" form:"UserID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LastRankReq) Reset()         { *m = LastRankReq{} }
func (m *LastRankReq) String() string { return proto.CompactTextString(m) }
func (*LastRankReq) ProtoMessage()    {}
func (*LastRankReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{18}
}
func (m *LastRankReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LastRankReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LastRankReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LastRankReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LastRankReq.Merge(m, src)
}
func (m *LastRankReq) XXX_Size() int {
	return m.Size()
}
func (m *LastRankReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LastRankReq.DiscardUnknown(m)
}

var xxx_messageInfo_LastRankReq proto.InternalMessageInfo

type LastRankRsp struct {
	SelfRankInfo         *RankDetail   `protobuf:"bytes,1,opt,name=SelfRankInfo,proto3" json:"SelfRankInfo" form:"SelfRankInfo" `
	ArenaTimeID          int32         `protobuf:"varint,2,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	DayRankList          []*RankDetail `protobuf:"bytes,3,rep,name=DayRankList,proto3" json:"DayRankList" form:"DayRankList" `
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LastRankRsp) Reset()         { *m = LastRankRsp{} }
func (m *LastRankRsp) String() string { return proto.CompactTextString(m) }
func (*LastRankRsp) ProtoMessage()    {}
func (*LastRankRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{19}
}
func (m *LastRankRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LastRankRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LastRankRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LastRankRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LastRankRsp.Merge(m, src)
}
func (m *LastRankRsp) XXX_Size() int {
	return m.Size()
}
func (m *LastRankRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_LastRankRsp.DiscardUnknown(m)
}

var xxx_messageInfo_LastRankRsp proto.InternalMessageInfo

type RankDetail struct {
	UserID               int64           `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID" form:"UserID"`
	RankScore            int64           `protobuf:"varint,2,opt,name=RankScore,proto3" json:"RankScore" form:"RankScore"`
	Rank                 int64           `protobuf:"varint,3,opt,name=Rank,proto3" json:"Rank" form:"Rank"`
	RankRewardList       []*ThingsDetail `protobuf:"bytes,4,rep,name=RankRewardList,proto3" json:"RankRewardList" form:"RankRewardList"`
	AddScore             int64           `protobuf:"varint,5,opt,name=AddScore,proto3" json:"AddScore" form:"AddScore"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RankDetail) Reset()         { *m = RankDetail{} }
func (m *RankDetail) String() string { return proto.CompactTextString(m) }
func (*RankDetail) ProtoMessage()    {}
func (*RankDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{20}
}
func (m *RankDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankDetail.Merge(m, src)
}
func (m *RankDetail) XXX_Size() int {
	return m.Size()
}
func (m *RankDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RankDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RankDetail proto.InternalMessageInfo

type FloatPoolReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FloatPoolReq) Reset()         { *m = FloatPoolReq{} }
func (m *FloatPoolReq) String() string { return proto.CompactTextString(m) }
func (*FloatPoolReq) ProtoMessage()    {}
func (*FloatPoolReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{21}
}
func (m *FloatPoolReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FloatPoolReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FloatPoolReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FloatPoolReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatPoolReq.Merge(m, src)
}
func (m *FloatPoolReq) XXX_Size() int {
	return m.Size()
}
func (m *FloatPoolReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatPoolReq.DiscardUnknown(m)
}

var xxx_messageInfo_FloatPoolReq proto.InternalMessageInfo

type FloatPoolRsp struct {
	BonusPoolNum         int64    `protobuf:"varint,1,opt,name=BonusPoolNum,proto3" json:"BonusPoolNum" form:"BonusPoolNum"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FloatPoolRsp) Reset()         { *m = FloatPoolRsp{} }
func (m *FloatPoolRsp) String() string { return proto.CompactTextString(m) }
func (*FloatPoolRsp) ProtoMessage()    {}
func (*FloatPoolRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{22}
}
func (m *FloatPoolRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FloatPoolRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FloatPoolRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FloatPoolRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatPoolRsp.Merge(m, src)
}
func (m *FloatPoolRsp) XXX_Size() int {
	return m.Size()
}
func (m *FloatPoolRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatPoolRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FloatPoolRsp proto.InternalMessageInfo

type QueryUserRewardReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryUserRewardReq) Reset()         { *m = QueryUserRewardReq{} }
func (m *QueryUserRewardReq) String() string { return proto.CompactTextString(m) }
func (*QueryUserRewardReq) ProtoMessage()    {}
func (*QueryUserRewardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{23}
}
func (m *QueryUserRewardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUserRewardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUserRewardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUserRewardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUserRewardReq.Merge(m, src)
}
func (m *QueryUserRewardReq) XXX_Size() int {
	return m.Size()
}
func (m *QueryUserRewardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUserRewardReq.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUserRewardReq proto.InternalMessageInfo

type QueryUserRewardRsp struct {
	UserRewardList       []*UserRewardDetail `protobuf:"bytes,1,rep,name=UserRewardList,proto3" json:"UserRewardList" form:"UserRewardList"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *QueryUserRewardRsp) Reset()         { *m = QueryUserRewardRsp{} }
func (m *QueryUserRewardRsp) String() string { return proto.CompactTextString(m) }
func (*QueryUserRewardRsp) ProtoMessage()    {}
func (*QueryUserRewardRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{24}
}
func (m *QueryUserRewardRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUserRewardRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUserRewardRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUserRewardRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUserRewardRsp.Merge(m, src)
}
func (m *QueryUserRewardRsp) XXX_Size() int {
	return m.Size()
}
func (m *QueryUserRewardRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUserRewardRsp.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUserRewardRsp proto.InternalMessageInfo

type UserRewardDetail struct {
	MatchID              int32           `protobuf:"varint,1,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID"`
	ArenaID              int32           `protobuf:"varint,2,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32           `protobuf:"varint,3,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	RewardID             string          `protobuf:"bytes,4,opt,name=RewardID,proto3" json:"RewardID" form:"RewardID"`
	Rank                 int64           `protobuf:"varint,5,opt,name=Rank,proto3" json:"Rank" form:"Rank"`
	RankScore            int64           `protobuf:"varint,6,opt,name=RankScore,proto3" json:"RankScore" form:"RankScore"`
	RewardTime           int64           `protobuf:"varint,7,opt,name=RewardTime,proto3" json:"RewardTime" form:"RewardTime"`
	ThingsList           []*ThingsDetail `protobuf:"bytes,8,rep,name=ThingsList,proto3" json:"ThingsList" form:"ThingsList"`
	MatchName            string          `protobuf:"bytes,9,opt,name=MatchName,proto3" json:"MatchName" form:"MatchName"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UserRewardDetail) Reset()         { *m = UserRewardDetail{} }
func (m *UserRewardDetail) String() string { return proto.CompactTextString(m) }
func (*UserRewardDetail) ProtoMessage()    {}
func (*UserRewardDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{25}
}
func (m *UserRewardDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRewardDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRewardDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRewardDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRewardDetail.Merge(m, src)
}
func (m *UserRewardDetail) XXX_Size() int {
	return m.Size()
}
func (m *UserRewardDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRewardDetail.DiscardUnknown(m)
}

var xxx_messageInfo_UserRewardDetail proto.InternalMessageInfo

type GetUserRewardReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	RewardID             string   `protobuf:"bytes,3,opt,name=RewardID,proto3" json:"RewardID" form:"RewardID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUserRewardReq) Reset()         { *m = GetUserRewardReq{} }
func (m *GetUserRewardReq) String() string { return proto.CompactTextString(m) }
func (*GetUserRewardReq) ProtoMessage()    {}
func (*GetUserRewardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{26}
}
func (m *GetUserRewardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserRewardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserRewardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserRewardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserRewardReq.Merge(m, src)
}
func (m *GetUserRewardReq) XXX_Size() int {
	return m.Size()
}
func (m *GetUserRewardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserRewardReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserRewardReq proto.InternalMessageInfo

type GetUserRewardRsp struct {
	RewardList           []*ThingsDetail `protobuf:"bytes,1,rep,name=RewardList,proto3" json:"RewardList" form:"RewardList"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetUserRewardRsp) Reset()         { *m = GetUserRewardRsp{} }
func (m *GetUserRewardRsp) String() string { return proto.CompactTextString(m) }
func (*GetUserRewardRsp) ProtoMessage()    {}
func (*GetUserRewardRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{27}
}
func (m *GetUserRewardRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserRewardRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserRewardRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserRewardRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserRewardRsp.Merge(m, src)
}
func (m *GetUserRewardRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetUserRewardRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserRewardRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserRewardRsp proto.InternalMessageInfo

type MatchSignReq struct {
	GameID               int32           `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32           `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32           `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32           `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	UserID               int64           `protobuf:"varint,5,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	SignThinsList        []*ThingsDetail `protobuf:"bytes,6,rep,name=SignThinsList,proto3" json:"SignThinsList" form:"SignThinsList" `
	SaveScore            bool            `protobuf:"varint,7,opt,name=SaveScore,proto3" json:"SaveScore" form:"SaveScore" `
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MatchSignReq) Reset()         { *m = MatchSignReq{} }
func (m *MatchSignReq) String() string { return proto.CompactTextString(m) }
func (*MatchSignReq) ProtoMessage()    {}
func (*MatchSignReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{28}
}
func (m *MatchSignReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchSignReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchSignReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchSignReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchSignReq.Merge(m, src)
}
func (m *MatchSignReq) XXX_Size() int {
	return m.Size()
}
func (m *MatchSignReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchSignReq.DiscardUnknown(m)
}

var xxx_messageInfo_MatchSignReq proto.InternalMessageInfo

type MatchSignRsp struct {
	CostList             []*ThingsDetail `protobuf:"bytes,1,rep,name=CostList,proto3" json:"CostList" form:"CostList" `
	Join                 bool            `protobuf:"varint,2,opt,name=Join,proto3" json:"Join" form:"Join" `
	MatchSignCount       int32           `protobuf:"varint,3,opt,name=MatchSignCount,proto3" json:"MatchSignCount" form:"MatchSignCount" `
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MatchSignRsp) Reset()         { *m = MatchSignRsp{} }
func (m *MatchSignRsp) String() string { return proto.CompactTextString(m) }
func (*MatchSignRsp) ProtoMessage()    {}
func (*MatchSignRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{29}
}
func (m *MatchSignRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchSignRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchSignRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchSignRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchSignRsp.Merge(m, src)
}
func (m *MatchSignRsp) XXX_Size() int {
	return m.Size()
}
func (m *MatchSignRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchSignRsp.DiscardUnknown(m)
}

var xxx_messageInfo_MatchSignRsp proto.InternalMessageInfo

type UserMatchRecordReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserMatchRecordReq) Reset()         { *m = UserMatchRecordReq{} }
func (m *UserMatchRecordReq) String() string { return proto.CompactTextString(m) }
func (*UserMatchRecordReq) ProtoMessage()    {}
func (*UserMatchRecordReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{30}
}
func (m *UserMatchRecordReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserMatchRecordReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserMatchRecordReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserMatchRecordReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMatchRecordReq.Merge(m, src)
}
func (m *UserMatchRecordReq) XXX_Size() int {
	return m.Size()
}
func (m *UserMatchRecordReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMatchRecordReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserMatchRecordReq proto.InternalMessageInfo

type UserMatchRecordRsp struct {
	UserMatchRecordList  []*MatchRecordDetail `protobuf:"bytes,1,rep,name=UserMatchRecordList,proto3" json:"UserMatchRecordList" form:"UserMatchRecordList" `
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UserMatchRecordRsp) Reset()         { *m = UserMatchRecordRsp{} }
func (m *UserMatchRecordRsp) String() string { return proto.CompactTextString(m) }
func (*UserMatchRecordRsp) ProtoMessage()    {}
func (*UserMatchRecordRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{31}
}
func (m *UserMatchRecordRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserMatchRecordRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserMatchRecordRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserMatchRecordRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMatchRecordRsp.Merge(m, src)
}
func (m *UserMatchRecordRsp) XXX_Size() int {
	return m.Size()
}
func (m *UserMatchRecordRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMatchRecordRsp.DiscardUnknown(m)
}

var xxx_messageInfo_UserMatchRecordRsp proto.InternalMessageInfo

type MatchRecordDetail struct {
	MatchID              int32           `protobuf:"varint,1,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID"`
	MatchName            string          `protobuf:"bytes,2,opt,name=MatchName,proto3" json:"MatchName" form:"MatchName" `
	DateProperty         string          `protobuf:"bytes,3,opt,name=DateProperty,proto3" json:"DateProperty" form:"DateProperty" `
	ArenaID              int32           `protobuf:"varint,4,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32           `protobuf:"varint,5,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	Rank                 int64           `protobuf:"varint,6,opt,name=Rank,proto3" json:"Rank" form:"Rank"`
	RankScore            int64           `protobuf:"varint,7,opt,name=RankScore,proto3" json:"RankScore" form:"RankScore"`
	RewardTime           int64           `protobuf:"varint,8,opt,name=RewardTime,proto3" json:"RewardTime" form:"RewardTime"`
	ThingsList           []*ThingsDetail `protobuf:"bytes,9,rep,name=ThingsList,proto3" json:"ThingsList" form:"ThingsList"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MatchRecordDetail) Reset()         { *m = MatchRecordDetail{} }
func (m *MatchRecordDetail) String() string { return proto.CompactTextString(m) }
func (*MatchRecordDetail) ProtoMessage()    {}
func (*MatchRecordDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{32}
}
func (m *MatchRecordDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchRecordDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchRecordDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchRecordDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchRecordDetail.Merge(m, src)
}
func (m *MatchRecordDetail) XXX_Size() int {
	return m.Size()
}
func (m *MatchRecordDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchRecordDetail.DiscardUnknown(m)
}

var xxx_messageInfo_MatchRecordDetail proto.InternalMessageInfo

type TargetMatchStatusReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TargetMatchStatusReq) Reset()         { *m = TargetMatchStatusReq{} }
func (m *TargetMatchStatusReq) String() string { return proto.CompactTextString(m) }
func (*TargetMatchStatusReq) ProtoMessage()    {}
func (*TargetMatchStatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{33}
}
func (m *TargetMatchStatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetMatchStatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetMatchStatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetMatchStatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetMatchStatusReq.Merge(m, src)
}
func (m *TargetMatchStatusReq) XXX_Size() int {
	return m.Size()
}
func (m *TargetMatchStatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetMatchStatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_TargetMatchStatusReq proto.InternalMessageInfo

type TargetMatchStatusRsp struct {
	MatchStatus          MatchV1StatusCode `protobuf:"varint,1,opt,name=MatchStatus,proto3,enum=matchv1.service.v1.MatchV1StatusCode" json:"MatchStatus" form:"MatchStatus" `
	EnterUserNum         int64             `protobuf:"varint,2,opt,name=EnterUserNum,proto3" json:"EnterUserNum" form:"EnterUserNum" `
	MatchStartPoint      int64             `protobuf:"varint,3,opt,name=MatchStartPoint,proto3" json:"MatchStartPoint" form:"MatchStartPoint" `
	MatchEndPoint        int64             `protobuf:"varint,4,opt,name=MatchEndPoint,proto3" json:"MatchEndPoint" form:"MatchEndPoint" `
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TargetMatchStatusRsp) Reset()         { *m = TargetMatchStatusRsp{} }
func (m *TargetMatchStatusRsp) String() string { return proto.CompactTextString(m) }
func (*TargetMatchStatusRsp) ProtoMessage()    {}
func (*TargetMatchStatusRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{34}
}
func (m *TargetMatchStatusRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetMatchStatusRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetMatchStatusRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetMatchStatusRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetMatchStatusRsp.Merge(m, src)
}
func (m *TargetMatchStatusRsp) XXX_Size() int {
	return m.Size()
}
func (m *TargetMatchStatusRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetMatchStatusRsp.DiscardUnknown(m)
}

var xxx_messageInfo_TargetMatchStatusRsp proto.InternalMessageInfo

type UserMatchInfoReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID"`
	UserID               int64    `protobuf:"varint,5,opt,name=UserID,proto3" json:"UserID" form:"UserID" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserMatchInfoReq) Reset()         { *m = UserMatchInfoReq{} }
func (m *UserMatchInfoReq) String() string { return proto.CompactTextString(m) }
func (*UserMatchInfoReq) ProtoMessage()    {}
func (*UserMatchInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{35}
}
func (m *UserMatchInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserMatchInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserMatchInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserMatchInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMatchInfoReq.Merge(m, src)
}
func (m *UserMatchInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *UserMatchInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMatchInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserMatchInfoReq proto.InternalMessageInfo

type UserMatchInfoRsp struct {
	VirtualBet           int64                 `protobuf:"varint,1,opt,name=VirtualBet,proto3" json:"VirtualBet" form:"VirtualBet" `
	Rank                 int64                 `protobuf:"varint,2,opt,name=Rank,proto3" json:"Rank" form:"Rank"`
	RankScore            int64                 `protobuf:"varint,3,opt,name=RankScore,proto3" json:"RankScore" form:"RankScore"`
	UserStatus           MatchV1UserStatusCode `protobuf:"varint,4,opt,name=UserStatus,proto3,enum=matchv1.service.v1.MatchV1UserStatusCode" json:"UserStatus" form:"UserStatus"`
	EnterUserNum         int64                 `protobuf:"varint,5,opt,name=EnterUserNum,proto3" json:"EnterUserNum" form:"EnterUserNum" `
	LastDifScore         int64                 `protobuf:"varint,6,opt,name=LastDifScore,proto3" json:"LastDifScore" form:"LastDifScore" `
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *UserMatchInfoRsp) Reset()         { *m = UserMatchInfoRsp{} }
func (m *UserMatchInfoRsp) String() string { return proto.CompactTextString(m) }
func (*UserMatchInfoRsp) ProtoMessage()    {}
func (*UserMatchInfoRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{36}
}
func (m *UserMatchInfoRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserMatchInfoRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserMatchInfoRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserMatchInfoRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMatchInfoRsp.Merge(m, src)
}
func (m *UserMatchInfoRsp) XXX_Size() int {
	return m.Size()
}
func (m *UserMatchInfoRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMatchInfoRsp.DiscardUnknown(m)
}

var xxx_messageInfo_UserMatchInfoRsp proto.InternalMessageInfo

type UserEnterReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID" `
	UserID               int64    `protobuf:"varint,5,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserEnterReq) Reset()         { *m = UserEnterReq{} }
func (m *UserEnterReq) String() string { return proto.CompactTextString(m) }
func (*UserEnterReq) ProtoMessage()    {}
func (*UserEnterReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{37}
}
func (m *UserEnterReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserEnterReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserEnterReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserEnterReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserEnterReq.Merge(m, src)
}
func (m *UserEnterReq) XXX_Size() int {
	return m.Size()
}
func (m *UserEnterReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserEnterReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserEnterReq proto.InternalMessageInfo

type UserEnterRsp struct {
	UserEnter            bool     `protobuf:"varint,1,opt,name=UserEnter,proto3" json:"UserEnter" form:"UserEnter"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserEnterRsp) Reset()         { *m = UserEnterRsp{} }
func (m *UserEnterRsp) String() string { return proto.CompactTextString(m) }
func (*UserEnterRsp) ProtoMessage()    {}
func (*UserEnterRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{38}
}
func (m *UserEnterRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserEnterRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserEnterRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserEnterRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserEnterRsp.Merge(m, src)
}
func (m *UserEnterRsp) XXX_Size() int {
	return m.Size()
}
func (m *UserEnterRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserEnterRsp.DiscardUnknown(m)
}

var xxx_messageInfo_UserEnterRsp proto.InternalMessageInfo

type UserEnterListReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserEnterListReq) Reset()         { *m = UserEnterListReq{} }
func (m *UserEnterListReq) String() string { return proto.CompactTextString(m) }
func (*UserEnterListReq) ProtoMessage()    {}
func (*UserEnterListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{39}
}
func (m *UserEnterListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserEnterListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserEnterListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserEnterListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserEnterListReq.Merge(m, src)
}
func (m *UserEnterListReq) XXX_Size() int {
	return m.Size()
}
func (m *UserEnterListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserEnterListReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserEnterListReq proto.InternalMessageInfo

type UserEnterListRsp struct {
	UserEnterList        []*UserEnterDetail `protobuf:"bytes,1,rep,name=UserEnterList,proto3" json:"UserEnterList" form:"UserEnterList"`
	MatchStatus          MatchV1StatusCode  `protobuf:"varint,2,opt,name=MatchStatus,proto3,enum=matchv1.service.v1.MatchV1StatusCode" json:"MatchStatus" form:"MatchStatus" `
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *UserEnterListRsp) Reset()         { *m = UserEnterListRsp{} }
func (m *UserEnterListRsp) String() string { return proto.CompactTextString(m) }
func (*UserEnterListRsp) ProtoMessage()    {}
func (*UserEnterListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{40}
}
func (m *UserEnterListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserEnterListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserEnterListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserEnterListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserEnterListRsp.Merge(m, src)
}
func (m *UserEnterListRsp) XXX_Size() int {
	return m.Size()
}
func (m *UserEnterListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserEnterListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_UserEnterListRsp proto.InternalMessageInfo

type UserEnterDetail struct {
	UserID               int64    `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID" form:"UserID" `
	Score                int64    `protobuf:"varint,2,opt,name=Score,proto3" json:"Score" form:"Score"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserEnterDetail) Reset()         { *m = UserEnterDetail{} }
func (m *UserEnterDetail) String() string { return proto.CompactTextString(m) }
func (*UserEnterDetail) ProtoMessage()    {}
func (*UserEnterDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{41}
}
func (m *UserEnterDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserEnterDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserEnterDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserEnterDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserEnterDetail.Merge(m, src)
}
func (m *UserEnterDetail) XXX_Size() int {
	return m.Size()
}
func (m *UserEnterDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_UserEnterDetail.DiscardUnknown(m)
}

var xxx_messageInfo_UserEnterDetail proto.InternalMessageInfo

type TargetMatchAllRewardReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchID              int32    `protobuf:"varint,2,opt,name=MatchID,proto3" json:"MatchID" form:"MatchID" validate:"required"`
	ArenaID              int32    `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID"`
	ArenaTimeID          int32    `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TargetMatchAllRewardReq) Reset()         { *m = TargetMatchAllRewardReq{} }
func (m *TargetMatchAllRewardReq) String() string { return proto.CompactTextString(m) }
func (*TargetMatchAllRewardReq) ProtoMessage()    {}
func (*TargetMatchAllRewardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{42}
}
func (m *TargetMatchAllRewardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetMatchAllRewardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetMatchAllRewardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetMatchAllRewardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetMatchAllRewardReq.Merge(m, src)
}
func (m *TargetMatchAllRewardReq) XXX_Size() int {
	return m.Size()
}
func (m *TargetMatchAllRewardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetMatchAllRewardReq.DiscardUnknown(m)
}

var xxx_messageInfo_TargetMatchAllRewardReq proto.InternalMessageInfo

type TargetMatchAllRewardRsp struct {
	UserReward           []*AwardDetail `protobuf:"bytes,1,rep,name=UserReward,proto3" json:"UserReward" form:"UserReward"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TargetMatchAllRewardRsp) Reset()         { *m = TargetMatchAllRewardRsp{} }
func (m *TargetMatchAllRewardRsp) String() string { return proto.CompactTextString(m) }
func (*TargetMatchAllRewardRsp) ProtoMessage()    {}
func (*TargetMatchAllRewardRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{43}
}
func (m *TargetMatchAllRewardRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetMatchAllRewardRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetMatchAllRewardRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetMatchAllRewardRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetMatchAllRewardRsp.Merge(m, src)
}
func (m *TargetMatchAllRewardRsp) XXX_Size() int {
	return m.Size()
}
func (m *TargetMatchAllRewardRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetMatchAllRewardRsp.DiscardUnknown(m)
}

var xxx_messageInfo_TargetMatchAllRewardRsp proto.InternalMessageInfo

type AwardDetail struct {
	UserID               int64           `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID" form:"UserID" `
	RewardList           []*ThingsDetail `protobuf:"bytes,2,rep,name=RewardList,proto3" json:"RewardList" form:"RewardList"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *AwardDetail) Reset()         { *m = AwardDetail{} }
func (m *AwardDetail) String() string { return proto.CompactTextString(m) }
func (*AwardDetail) ProtoMessage()    {}
func (*AwardDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{44}
}
func (m *AwardDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardDetail.Merge(m, src)
}
func (m *AwardDetail) XXX_Size() int {
	return m.Size()
}
func (m *AwardDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardDetail.DiscardUnknown(m)
}

var xxx_messageInfo_AwardDetail proto.InternalMessageInfo

type MatchListTimeReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchListTimeReq) Reset()         { *m = MatchListTimeReq{} }
func (m *MatchListTimeReq) String() string { return proto.CompactTextString(m) }
func (*MatchListTimeReq) ProtoMessage()    {}
func (*MatchListTimeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{45}
}
func (m *MatchListTimeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchListTimeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchListTimeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchListTimeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchListTimeReq.Merge(m, src)
}
func (m *MatchListTimeReq) XXX_Size() int {
	return m.Size()
}
func (m *MatchListTimeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchListTimeReq.DiscardUnknown(m)
}

var xxx_messageInfo_MatchListTimeReq proto.InternalMessageInfo

type MatchListTimeRsp struct {
	MatchList            []*MatchTimeDetail `protobuf:"bytes,3,rep,name=MatchList,proto3" json:"MatchList"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *MatchListTimeRsp) Reset()         { *m = MatchListTimeRsp{} }
func (m *MatchListTimeRsp) String() string { return proto.CompactTextString(m) }
func (*MatchListTimeRsp) ProtoMessage()    {}
func (*MatchListTimeRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{46}
}
func (m *MatchListTimeRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchListTimeRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchListTimeRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchListTimeRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchListTimeRsp.Merge(m, src)
}
func (m *MatchListTimeRsp) XXX_Size() int {
	return m.Size()
}
func (m *MatchListTimeRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchListTimeRsp.DiscardUnknown(m)
}

var xxx_messageInfo_MatchListTimeRsp proto.InternalMessageInfo

type MatchTimeDetail struct {
	Name                 string               `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name" form:"Name" `
	ID                   int32                `protobuf:"varint,2,opt,name=ID,proto3" json:"ID" form:"ID" `
	ArenaID              int32                `protobuf:"varint,3,opt,name=ArenaID,proto3" json:"ArenaID" form:"ArenaID" `
	ArenaTimeID          int32                `protobuf:"varint,4,opt,name=ArenaTimeID,proto3" json:"ArenaTimeID" form:"ArenaTimeID" `
	BeginTime            int64                `protobuf:"varint,5,opt,name=BeginTime,proto3" json:"BeginTime" form:"BeginTime" `
	EndTime              int64                `protobuf:"varint,6,opt,name=EndTime,proto3" json:"EndTime" form:"EndTime" `
	DateProperty         string               `protobuf:"bytes,7,opt,name=DateProperty,proto3" json:"DateProperty" form:"DateProperty" `
	MatchStatus          MatchV1StatusCode    `protobuf:"varint,8,opt,name=MatchStatus,proto3,enum=matchv1.service.v1.MatchV1StatusCode" json:"MatchStatus" form:"MatchStatus" `
	ShowRewardList       []*RewardThinsDetail `protobuf:"bytes,9,rep,name=ShowRewardList,proto3" json:"ShowRewardList" form:"ShowRewardList" `
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *MatchTimeDetail) Reset()         { *m = MatchTimeDetail{} }
func (m *MatchTimeDetail) String() string { return proto.CompactTextString(m) }
func (*MatchTimeDetail) ProtoMessage()    {}
func (*MatchTimeDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{47}
}
func (m *MatchTimeDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchTimeDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchTimeDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchTimeDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchTimeDetail.Merge(m, src)
}
func (m *MatchTimeDetail) XXX_Size() int {
	return m.Size()
}
func (m *MatchTimeDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchTimeDetail.DiscardUnknown(m)
}

var xxx_messageInfo_MatchTimeDetail proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("matchv1.service.v1.MatchV1ErrCode", MatchV1ErrCode_name, MatchV1ErrCode_value)
	proto.RegisterEnum("matchv1.service.v1.MatchV1StatusCode", MatchV1StatusCode_name, MatchV1StatusCode_value)
	proto.RegisterEnum("matchv1.service.v1.MatchV1UserStatusCode", MatchV1UserStatusCode_name, MatchV1UserStatusCode_value)
	proto.RegisterType((*MatchListReq)(nil), "matchv1.service.v1.MatchListReq")
	proto.RegisterType((*MatchListRsp)(nil), "matchv1.service.v1.MatchListRsp")
	proto.RegisterType((*TargetMatchDetail)(nil), "matchv1.service.v1.TargetMatchDetail")
	proto.RegisterType((*BeginDetail)(nil), "matchv1.service.v1.BeginDetail")
	proto.RegisterType((*EndDetail)(nil), "matchv1.service.v1.EndDetail")
	proto.RegisterType((*DateDetail)(nil), "matchv1.service.v1.DateDetail")
	proto.RegisterType((*PayDetail)(nil), "matchv1.service.v1.PayDetail")
	proto.RegisterType((*ThingsDetail)(nil), "matchv1.service.v1.ThingsDetail")
	proto.RegisterType((*GetRewardConfigReq)(nil), "matchv1.service.v1.GetRewardConfigReq")
	proto.RegisterType((*GetRewardConfigRsp)(nil), "matchv1.service.v1.GetRewardConfigRsp")
	proto.RegisterType((*RewardConfig)(nil), "matchv1.service.v1.RewardConfig")
	proto.RegisterType((*RewardThinsDetail)(nil), "matchv1.service.v1.RewardThinsDetail")
	proto.RegisterType((*RewardDetail)(nil), "matchv1.service.v1.RewardDetail")
	proto.RegisterType((*ScoreUploadReq)(nil), "matchv1.service.v1.ScoreUploadReq")
	proto.RegisterType((*CommonRsp)(nil), "matchv1.service.v1.CommonRsp")
	proto.RegisterType((*UserDetails)(nil), "matchv1.service.v1.UserDetails")
	proto.RegisterType((*ImmediateRankReq)(nil), "matchv1.service.v1.ImmediateRankReq")
	proto.RegisterType((*ImmediateRankRsp)(nil), "matchv1.service.v1.ImmediateRankRsp")
	proto.RegisterType((*LastRankReq)(nil), "matchv1.service.v1.LastRankReq")
	proto.RegisterType((*LastRankRsp)(nil), "matchv1.service.v1.LastRankRsp")
	proto.RegisterType((*RankDetail)(nil), "matchv1.service.v1.RankDetail")
	proto.RegisterType((*FloatPoolReq)(nil), "matchv1.service.v1.FloatPoolReq")
	proto.RegisterType((*FloatPoolRsp)(nil), "matchv1.service.v1.FloatPoolRsp")
	proto.RegisterType((*QueryUserRewardReq)(nil), "matchv1.service.v1.QueryUserRewardReq")
	proto.RegisterType((*QueryUserRewardRsp)(nil), "matchv1.service.v1.QueryUserRewardRsp")
	proto.RegisterType((*UserRewardDetail)(nil), "matchv1.service.v1.UserRewardDetail")
	proto.RegisterType((*GetUserRewardReq)(nil), "matchv1.service.v1.GetUserRewardReq")
	proto.RegisterType((*GetUserRewardRsp)(nil), "matchv1.service.v1.GetUserRewardRsp")
	proto.RegisterType((*MatchSignReq)(nil), "matchv1.service.v1.MatchSignReq")
	proto.RegisterType((*MatchSignRsp)(nil), "matchv1.service.v1.MatchSignRsp")
	proto.RegisterType((*UserMatchRecordReq)(nil), "matchv1.service.v1.UserMatchRecordReq")
	proto.RegisterType((*UserMatchRecordRsp)(nil), "matchv1.service.v1.UserMatchRecordRsp")
	proto.RegisterType((*MatchRecordDetail)(nil), "matchv1.service.v1.MatchRecordDetail")
	proto.RegisterType((*TargetMatchStatusReq)(nil), "matchv1.service.v1.TargetMatchStatusReq")
	proto.RegisterType((*TargetMatchStatusRsp)(nil), "matchv1.service.v1.TargetMatchStatusRsp")
	proto.RegisterType((*UserMatchInfoReq)(nil), "matchv1.service.v1.UserMatchInfoReq")
	proto.RegisterType((*UserMatchInfoRsp)(nil), "matchv1.service.v1.UserMatchInfoRsp")
	proto.RegisterType((*UserEnterReq)(nil), "matchv1.service.v1.UserEnterReq")
	proto.RegisterType((*UserEnterRsp)(nil), "matchv1.service.v1.UserEnterRsp")
	proto.RegisterType((*UserEnterListReq)(nil), "matchv1.service.v1.UserEnterListReq")
	proto.RegisterType((*UserEnterListRsp)(nil), "matchv1.service.v1.UserEnterListRsp")
	proto.RegisterType((*UserEnterDetail)(nil), "matchv1.service.v1.UserEnterDetail")
	proto.RegisterType((*TargetMatchAllRewardReq)(nil), "matchv1.service.v1.TargetMatchAllRewardReq")
	proto.RegisterType((*TargetMatchAllRewardRsp)(nil), "matchv1.service.v1.TargetMatchAllRewardRsp")
	proto.RegisterType((*AwardDetail)(nil), "matchv1.service.v1.AwardDetail")
	proto.RegisterType((*MatchListTimeReq)(nil), "matchv1.service.v1.MatchListTimeReq")
	proto.RegisterType((*MatchListTimeRsp)(nil), "matchv1.service.v1.MatchListTimeRsp")
	proto.RegisterType((*MatchTimeDetail)(nil), "matchv1.service.v1.MatchTimeDetail")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 3663 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0xcd, 0x6f, 0x1c, 0xc7,
	0x95, 0x57, 0xf7, 0x70, 0x48, 0x4e, 0x0d, 0x39, 0x1c, 0x96, 0x24, 0x6b, 0x34, 0xb2, 0xd8, 0xad,
	0x22, 0x2d, 0xd3, 0xb2, 0x97, 0xb4, 0x2c, 0xaf, 0xd7, 0x6b, 0x2f, 0x60, 0x6b, 0x48, 0x89, 0xe6,
	0x5a, 0xa2, 0xb8, 0x4d, 0xd9, 0x5e, 0xac, 0x16, 0x8b, 0x6d, 0x71, 0x9a, 0x54, 0x47, 0x33, 0xdd,
	0xed, 0xe9, 0x1e, 0x39, 0x83, 0x18, 0x09, 0x1c, 0x38, 0xca, 0xc7, 0x21, 0x3e, 0x24, 0x30, 0x72,
	0x51, 0x90, 0x00, 0x89, 0x0f, 0x09, 0x62, 0x20, 0xf9, 0x03, 0x72, 0xc9, 0xc5, 0xb7, 0x04, 0xc9,
	0x35, 0x68, 0xd8, 0x72, 0x02, 0x04, 0x73, 0x89, 0x31, 0x41, 0x80, 0xe4, 0x16, 0xd4, 0xab, 0xea,
	0xae, 0xea, 0x9e, 0x1e, 0x72, 0x48, 0x4a, 0x81, 0x21, 0xe8, 0x44, 0xd6, 0xaf, 0x5e, 0xbd, 0xaa,
	0x7e, 0xf5, 0xbe, 0xaa, 0xea, 0x0d, 0x2a, 0x98, 0x9e, 0xbd, 0xe0, 0xb5, 0xdc, 0xc0, 0xc5, 0xb8,
	0x69, 0x06, 0x9b, 0x37, 0x6e, 0x9d, 0x5d, 0xf0, 0xad, 0xd6, 0x2d, 0x7b, 0xd3, 0x5a, 0xb8, 0x75,
	0xb6, 0xfa, 0x2f, 0xdb, 0x76, 0x70, 0xa3, 0x7d, 0x7d, 0x61, 0xd3, 0x6d, 0x2e, 0x6e, 0xbb, 0xdb,
	0xee, 0x22, 0x90, 0x5e, 0x6f, 0x6f, 0x41, 0x0b, 0x1a, 0xf0, 0x1f, 0x63, 0x51, 0x3d, 0xb1, 0xed,
	0xba, 0xdb, 0x0d, 0x4b, 0x50, 0x59, 0x4d, 0x2f, 0xe8, 0xf0, 0xce, 0x47, 0x79, 0xa7, 0xe9, 0xd9,
	0x8b, 0xa6, 0xe3, 0xb8, 0x81, 0x19, 0xd8, 0xae, 0xe3, 0xb3, 0x5e, 0xf2, 0x03, 0x05, 0x4d, 0x5c,
	0xa6, 0x0b, 0xb8, 0x64, 0xfb, 0x81, 0x61, 0xbd, 0x89, 0x57, 0xd0, 0xe8, 0x8a, 0xd9, 0xb4, 0x56,
	0x97, 0x2b, 0x8a, 0xae, 0xcc, 0xe7, 0x6b, 0x8b, 0xdd, 0x50, 0xe3, 0x48, 0x2f, 0xd4, 0x4e, 0x6d,
	0xb9, 0xad, 0xe6, 0x0b, 0x84, 0xb5, 0x89, 0x7e, 0xcb, 0x6c, 0xd8, 0x75, 0x33, 0xb0, 0x5e, 0x20,
	0x2d, 0xeb, 0xcd, 0xb6, 0xdd, 0xb2, 0xea, 0xc4, 0xe0, 0xc4, 0x94, 0xd1, 0x6b, 0xbe, 0xd5, 0x5a,
	0x5d, 0xae, 0xa8, 0xba, 0x32, 0x9f, 0x63, 0x8c, 0x18, 0x22, 0x18, 0xb1, 0xf6, 0x00, 0x46, 0xbc,
	0xf3, 0xba, 0xbc, 0x42, 0xdf, 0xc3, 0x06, 0x2a, 0xc4, 0xed, 0x4a, 0x4e, 0xcf, 0xcd, 0x17, 0x9f,
	0x79, 0x6c, 0xa1, 0x5f, 0x88, 0x0b, 0x57, 0xcd, 0xd6, 0xb6, 0x15, 0x00, 0xe9, 0xb2, 0x15, 0x98,
	0x76, 0xa3, 0x36, 0xd9, 0x0d, 0x35, 0x31, 0xd6, 0x10, 0xff, 0x92, 0xf7, 0x8b, 0x68, 0xba, 0x8f,
	0x1e, 0x3f, 0x85, 0x46, 0xd6, 0xcc, 0xa6, 0x05, 0x92, 0x28, 0xd4, 0x2a, 0xdd, 0x50, 0x83, 0x76,
	0x2f, 0xd4, 0x26, 0xd8, 0xf2, 0x69, 0x8b, 0xe8, 0x06, 0xa0, 0x78, 0x0e, 0xa9, 0xfc, 0x63, 0xf3,
	0xb5, 0x23, 0xdd, 0x50, 0x53, 0xe1, 0x43, 0x11, 0xa3, 0xa4, 0x1f, 0x69, 0xa8, 0xab, 0xcb, 0xf8,
	0x79, 0x34, 0x76, 0xbe, 0x65, 0x39, 0xe6, 0xea, 0x72, 0x25, 0x07, 0xa4, 0x33, 0xdd, 0x50, 0x8b,
	0xa0, 0x5e, 0xa8, 0x4d, 0x31, 0x7a, 0x0e, 0x10, 0xdd, 0x88, 0xfa, 0xf0, 0x2b, 0xa8, 0x08, 0xff,
	0x5e, 0xb5, 0x61, 0x7b, 0x46, 0x60, 0xf4, 0xe9, 0x6e, 0xa8, 0xc9, 0x70, 0x2f, 0xd4, 0x0e, 0x4b,
	0x1c, 0x18, 0x48, 0x74, 0x43, 0xa6, 0xc1, 0xcb, 0x08, 0x5d, 0xb2, 0x9b, 0x76, 0x40, 0x9b, 0x7e,
	0x25, 0x0f, 0x8c, 0xe6, 0xba, 0xa1, 0x26, 0xa1, 0xbd, 0x50, 0xc3, 0x8c, 0x8f, 0xc0, 0x88, 0x6e,
	0x48, 0x14, 0xf8, 0x69, 0x94, 0xbf, 0xd2, 0xaa, 0x5b, 0xad, 0xca, 0x28, 0x30, 0xa8, 0x76, 0x43,
	0x8d, 0x01, 0xbd, 0x50, 0x9b, 0x64, 0x63, 0xa1, 0x49, 0x74, 0x83, 0xe1, 0x78, 0x1d, 0x4d, 0x5e,
	0x70, 0x02, 0xab, 0xb5, 0x6c, 0x99, 0xf5, 0x86, 0xed, 0x58, 0x95, 0x31, 0x10, 0xec, 0x99, 0x6e,
	0xa8, 0x25, 0x3b, 0x7a, 0xa1, 0x76, 0x94, 0x71, 0x48, 0xc0, 0x44, 0x37, 0x92, 0x74, 0xd8, 0x44,
	0x85, 0x9a, 0xb5, 0x6d, 0x3b, 0x57, 0x3b, 0x9e, 0x55, 0x19, 0xd7, 0x95, 0xf9, 0xe2, 0x33, 0x5a,
	0x96, 0x2e, 0x00, 0x11, 0xd7, 0x02, 0x42, 0xb5, 0x20, 0x1e, 0xd5, 0x0b, 0xb5, 0x69, 0x36, 0x55,
	0x0c, 0x11, 0xdd, 0x10, 0xfd, 0xf8, 0x0d, 0x34, 0x76, 0xc1, 0xa9, 0xc3, 0x04, 0x05, 0x98, 0xe0,
	0x64, 0xd6, 0x04, 0x17, 0x9c, 0x3a, 0x67, 0x0f, 0xfb, 0xc9, 0x47, 0x88, 0xfd, 0xe4, 0x00, 0xdd,
	0x4f, 0xfe, 0x2f, 0xfe, 0x7f, 0xae, 0xc7, 0xcb, 0x66, 0x60, 0x55, 0x10, 0xb0, 0x9e, 0xc9, 0x62,
	0x4d, 0xfb, 0xe5, 0xa5, 0xc7, 0x83, 0xc4, 0xd2, 0x63, 0x88, 0x2e, 0x3d, 0x6e, 0xe0, 0x16, 0x9a,
	0xdc, 0xb0, 0xb7, 0x9d, 0x25, 0xd7, 0xa9, 0xdb, 0xd4, 0xe8, 0x2b, 0x45, 0xb0, 0x16, 0x3d, 0xd3,
	0x5a, 0x6e, 0xd8, 0xce, 0xb6, 0xcf, 0xe7, 0x81, 0x1d, 0x49, 0x0c, 0x15, 0x3b, 0x92, 0x80, 0xe9,
	0x8e, 0x24, 0x00, 0x2a, 0x2e, 0x0a, 0xac, 0x9b, 0x9d, 0xca, 0xc4, 0x60, 0x71, 0xad, 0x9b, 0x1d,
	0x59, 0x5c, 0x7c, 0x84, 0x10, 0x17, 0x07, 0xa8, 0xb8, 0xf8, 0xbf, 0xd8, 0x45, 0x45, 0xf8, 0xb2,
	0x8d, 0xc0, 0x0c, 0xda, 0x7e, 0x65, 0x52, 0x57, 0xe6, 0x4b, 0xd9, 0x86, 0x0f, 0x64, 0xaf, 0x9f,
	0x65, 0x84, 0x4b, 0x6e, 0xdd, 0x62, 0x56, 0x22, 0x8d, 0x16, 0x56, 0x22, 0x81, 0xd4, 0x4a, 0xa4,
	0x26, 0xbe, 0x84, 0x26, 0xa8, 0x14, 0xd7, 0x5b, 0xae, 0x67, 0xb5, 0x82, 0x4e, 0xa5, 0x04, 0xca,
	0x3a, 0xdf, 0x0d, 0xb5, 0x04, 0xde, 0x0b, 0xb5, 0x23, 0x8c, 0x97, 0x8c, 0x12, 0xdd, 0x48, 0x50,
	0x51, 0x6e, 0xa0, 0xba, 0xd4, 0xa9, 0xad, 0xb5, 0x9b, 0x95, 0x29, 0x70, 0x8a, 0xc0, 0x4d, 0xc6,
	0x05, 0x37, 0x19, 0xa5, 0xdc, 0xe4, 0x36, 0x76, 0x11, 0xa2, 0xff, 0x72, 0x59, 0x94, 0x41, 0x16,
	0x4f, 0xec, 0x20, 0x0b, 0x41, 0x0c, 0xf2, 0x00, 0x63, 0x17, 0x98, 0x30, 0x76, 0x81, 0x51, 0x63,
	0x17, 0x2d, 0x7c, 0x0b, 0x95, 0x36, 0x6e, 0xb8, 0x6f, 0x19, 0xa6, 0x73, 0xd3, 0xb0, 0xde, 0x32,
	0x5b, 0xf5, 0xca, 0xf4, 0x60, 0x5d, 0x62, 0x14, 0x4b, 0xae, 0xb3, 0x65, 0x6f, 0xd7, 0x9e, 0xea,
	0x86, 0x5a, 0x6a, 0x6c, 0x2f, 0xd4, 0x1e, 0xe1, 0xfb, 0x9c, 0xc0, 0x89, 0x6e, 0xa4, 0x28, 0xc9,
	0xaf, 0x15, 0x54, 0x94, 0x8c, 0x17, 0xbf, 0x2c, 0x1b, 0x3c, 0xf3, 0xcb, 0x7b, 0xb4, 0xe7, 0xff,
	0x40, 0xe3, 0x17, 0xdb, 0x8d, 0xc6, 0x5a, 0xbb, 0xe9, 0x73, 0x67, 0xad, 0x77, 0x43, 0x2d, 0xc6,
	0x7a, 0xa1, 0x56, 0x66, 0xe3, 0x23, 0x84, 0xe8, 0x46, 0xdc, 0x4b, 0xe7, 0xdf, 0x08, 0xcc, 0x16,
	0xb8, 0x40, 0x70, 0xe0, 0x7c, 0xfe, 0x18, 0x14, 0xf3, 0xc7, 0x10, 0x9d, 0x5f, 0x34, 0x7e, 0xa9,
	0xa0, 0x42, 0xec, 0x2d, 0xf0, 0x8b, 0xc2, 0xbb, 0xb0, 0xaf, 0x39, 0x95, 0xfe, 0x9a, 0x72, 0xfa,
	0x6b, 0x84, 0x07, 0xf9, 0x37, 0x36, 0x98, 0x2e, 0x45, 0x85, 0xc1, 0x27, 0x23, 0xdf, 0xc3, 0x16,
	0x52, 0x12, 0xbe, 0x87, 0xce, 0x6c, 0x44, 0x5d, 0xf8, 0x45, 0x34, 0x4e, 0xff, 0x75, 0x03, 0xb3,
	0xc1, 0xa3, 0x90, 0x46, 0x65, 0x10, 0x61, 0x49, 0xb7, 0x45, 0x11, 0x62, 0xc4, 0x9d, 0xe4, 0xf7,
	0x0a, 0x42, 0xc2, 0x27, 0xe1, 0x27, 0xd1, 0xc8, 0x1b, 0x96, 0x75, 0xb3, 0xa2, 0xe8, 0xb9, 0xf9,
	0x7c, 0xed, 0x18, 0x0d, 0x92, 0xb4, 0xdd, 0x0b, 0xb5, 0x22, 0xe3, 0x41, 0x5b, 0xc4, 0x00, 0x10,
	0x2f, 0xa2, 0xfc, 0x65, 0xd7, 0x09, 0x6e, 0x54, 0x54, 0xa0, 0x3e, 0x4e, 0x63, 0x06, 0x00, 0x22,
	0xa6, 0x42, 0x93, 0x18, 0x0c, 0xc6, 0x8f, 0xa3, 0xdc, 0xb2, 0xd9, 0x81, 0x30, 0x9f, 0xaf, 0x1d,
	0xed, 0x86, 0x1a, 0x6d, 0x8a, 0xb0, 0xba, 0x6c, 0x76, 0x88, 0x41, 0x21, 0xbc, 0x82, 0x8a, 0x30,
	0x82, 0x8a, 0xd6, 0xec, 0x54, 0x46, 0xf4, 0xdc, 0x7c, 0xa1, 0xf6, 0x18, 0xd8, 0xbd, 0x80, 0x85,
	0xa2, 0x4b, 0x20, 0x31, 0x64, 0x12, 0xf2, 0x33, 0x05, 0x15, 0x62, 0xf7, 0x84, 0x97, 0x10, 0x02,
	0x13, 0x62, 0xa1, 0x92, 0xa5, 0x44, 0xb3, 0xd4, 0x7a, 0x04, 0x9a, 0x72, 0xc3, 0x2c, 0x54, 0x1a,
	0x12, 0x01, 0xbe, 0x86, 0x72, 0xd4, 0x1f, 0xaa, 0x43, 0x7a, 0xdf, 0xc7, 0xa9, 0x53, 0x90, 0x11,
	0xe1, 0xae, 0x64, 0x94, 0x18, 0x94, 0x2b, 0xf9, 0x5f, 0x94, 0xa0, 0xc5, 0xb3, 0x90, 0x86, 0xb0,
	0x95, 0x1e, 0x8e, 0xd3, 0x90, 0x42, 0x9c, 0x86, 0x40, 0x16, 0xf2, 0x38, 0xca, 0x51, 0x27, 0xc4,
	0x32, 0x33, 0x10, 0x2b, 0xf3, 0x3d, 0x5c, 0xac, 0xd4, 0xe5, 0x18, 0x14, 0x22, 0x77, 0x55, 0x84,
	0x57, 0xac, 0x40, 0xb6, 0xe8, 0x7b, 0x9a, 0x25, 0xbe, 0x8a, 0xc6, 0x40, 0x50, 0x71, 0xe6, 0x74,
	0x96, 0xaa, 0x30, 0x87, 0x7a, 0xa1, 0x46, 0x24, 0xc9, 0x0e, 0xe2, 0x15, 0x91, 0x53, 0x7b, 0x48,
	0xe6, 0x56, 0x27, 0x93, 0xb9, 0x55, 0x29, 0x99, 0x5b, 0x89, 0xd4, 0xea, 0xd9, 0x38, 0x57, 0x1d,
	0x01, 0x89, 0x3c, 0x9a, 0xc8, 0x55, 0x4b, 0xc9, 0x5c, 0x35, 0x4a, 0x4c, 0xa9, 0xca, 0xc9, 0x09,
	0x19, 0xcb, 0xa3, 0x1e, 0xeb, 0x4f, 0xc8, 0x70, 0x7f, 0x42, 0x96, 0xc8, 0xc7, 0xc8, 0x77, 0x95,
	0x7e, 0x21, 0xfb, 0x1e, 0xfe, 0x32, 0x2a, 0xcb, 0x10, 0xe4, 0xbb, 0xca, 0x90, 0x5e, 0xf7, 0xe9,
	0x6e, 0xa8, 0xf5, 0x8d, 0xee, 0x85, 0x5a, 0x85, 0xad, 0x25, 0xdd, 0x43, 0x74, 0xa3, 0x8f, 0x9a,
	0x5a, 0xc2, 0x84, 0x0c, 0xd2, 0x7c, 0x98, 0xba, 0x66, 0x6e, 0xea, 0x90, 0x0f, 0xd3, 0xb6, 0xb0,
	0x5d, 0xda, 0xa2, 0xf9, 0x30, 0xfd, 0x4b, 0x03, 0xf6, 0xb2, 0xd9, 0xa1, 0xff, 0xc2, 0xca, 0xd5,
	0xc1, 0x99, 0x3a, 0x9b, 0x84, 0x6a, 0x71, 0x64, 0x02, 0x10, 0xb0, 0xa5, 0xd1, 0xc2, 0x02, 0x24,
	0x90, 0x06, 0x6c, 0xb9, 0xf9, 0x2b, 0x05, 0x4d, 0xf7, 0xb1, 0x1a, 0xce, 0x1e, 0xce, 0xa1, 0xd1,
	0x55, 0xdf, 0xa0, 0x89, 0x18, 0xd5, 0xc2, 0xf1, 0xda, 0x09, 0xaa, 0x00, 0x0c, 0x11, 0xd9, 0x2c,
	0x6b, 0x13, 0x83, 0x77, 0x44, 0x46, 0x94, 0xdb, 0xcd, 0x88, 0xa8, 0x8b, 0x04, 0xde, 0x54, 0xb9,
	0x54, 0xe6, 0x22, 0x39, 0xe7, 0x62, 0x24, 0x37, 0xca, 0x17, 0x40, 0xf2, 0x41, 0x2c, 0x75, 0x71,
	0x0a, 0xd9, 0x83, 0xd4, 0x6f, 0x64, 0x49, 0x3d, 0x33, 0xaf, 0xa4, 0x34, 0x07, 0x11, 0xf7, 0x9f,
	0x73, 0xa8, 0xb4, 0xb1, 0xe9, 0xb6, 0xac, 0xd7, 0xbc, 0x86, 0x6b, 0xd6, 0x1f, 0x40, 0xb7, 0xb0,
	0x92, 0x75, 0xe2, 0xda, 0x87, 0x81, 0x63, 0x0f, 0x8d, 0x53, 0x9f, 0x01, 0x3b, 0x92, 0x87, 0x1d,
	0xc9, 0x3c, 0xa5, 0x50, 0x1a, 0xb6, 0x23, 0x7e, 0xed, 0x1c, 0x0d, 0xc8, 0xd1, 0xa0, 0x5e, 0xa8,
	0xcd, 0x0a, 0x27, 0xc4, 0x36, 0x23, 0xeb, 0x93, 0xe3, 0x01, 0x78, 0x83, 0xe6, 0x49, 0xc1, 0xf9,
	0xa6, 0xdb, 0x76, 0x02, 0x38, 0xa0, 0xe5, 0x6a, 0xff, 0xca, 0x32, 0x0b, 0x0e, 0xf6, 0x42, 0x6d,
	0x2e, 0xca, 0x2c, 0x38, 0x94, 0xcd, 0x53, 0x0c, 0x21, 0x17, 0x50, 0x61, 0xc9, 0x6d, 0x36, 0x5d,
	0x87, 0x7a, 0xa7, 0xe7, 0xd1, 0xd8, 0x46, 0x7b, 0x73, 0xd3, 0xf2, 0x59, 0x58, 0x1c, 0xe7, 0x99,
	0x3c, 0x83, 0xa4, 0x4c, 0x9e, 0x01, 0x90, 0xc9, 0xf3, 0x7f, 0xbf, 0xa5, 0xa2, 0xa2, 0xf4, 0xa9,
	0xd2, 0x4d, 0x81, 0x72, 0xa0, 0x9b, 0x02, 0x9a, 0x5d, 0x80, 0x42, 0xf2, 0xb8, 0x06, 0xd9, 0x05,
	0x00, 0xc2, 0x56, 0xa0, 0x49, 0x0c, 0x06, 0xd3, 0x83, 0xf0, 0xeb, 0x76, 0x2b, 0x68, 0x9b, 0x8d,
	0x9a, 0x15, 0x70, 0x43, 0x86, 0xdc, 0x58, 0xa0, 0x62, 0x7b, 0x05, 0x46, 0x73, 0x63, 0xd1, 0xa2,
	0xd9, 0xd4, 0xf9, 0x7a, 0x9d, 0xcd, 0xcc, 0xe2, 0x07, 0x64, 0x53, 0x11, 0x26, 0x1d, 0xea, 0x39,
	0x42, 0x8c, 0xb8, 0x93, 0x7c, 0x92, 0x43, 0xe5, 0xd5, 0x66, 0xd3, 0xaa, 0xdb, 0x66, 0x60, 0xb1,
	0xc4, 0xf7, 0x81, 0xb3, 0xa3, 0x25, 0x84, 0x20, 0xff, 0x5d, 0x77, 0x6d, 0x27, 0xe0, 0x22, 0x82,
	0x24, 0x4a, 0xa0, 0xa9, 0xb4, 0x19, 0x30, 0x62, 0x48, 0x04, 0x3c, 0x67, 0x65, 0x2c, 0xf2, 0x42,
	0xca, 0x11, 0x96, 0xc8, 0x59, 0xf9, 0xf0, 0xb8, 0x93, 0xfa, 0x77, 0xae, 0x62, 0xcc, 0x16, 0x4e,
	0x24, 0x54, 0x6c, 0x32, 0xa1, 0x62, 0x83, 0xe2, 0xfb, 0xd8, 0xbe, 0xe3, 0xfb, 0x9f, 0xd4, 0xf4,
	0x1e, 0xfb, 0x5e, 0xda, 0x51, 0x2b, 0xf7, 0xcd, 0x51, 0x63, 0x0f, 0x4d, 0x6e, 0x58, 0x8d, 0x2d,
	0xd8, 0x46, 0x88, 0x24, 0xea, 0xe0, 0xcb, 0x06, 0x69, 0x2e, 0x76, 0x09, 0x20, 0x0f, 0x94, 0x2e,
	0x01, 0x64, 0x18, 0x2e, 0x01, 0x64, 0x00, 0xbf, 0x14, 0x9d, 0xd2, 0xa2, 0x53, 0x52, 0x4e, 0x3e,
	0xd7, 0xb0, 0xc3, 0x49, 0xe2, 0x5c, 0x03, 0xc7, 0x13, 0xd1, 0x2d, 0x9f, 0x6c, 0x98, 0xba, 0x0c,
	0x79, 0xb2, 0x21, 0x9f, 0xe5, 0x50, 0xf1, 0x92, 0xe9, 0x07, 0x0f, 0xa8, 0x25, 0x5d, 0x13, 0x5f,
	0x47, 0x53, 0x0f, 0x16, 0x91, 0xfe, 0x9d, 0x2a, 0x85, 0x04, 0xf7, 0x42, 0xed, 0x34, 0xbf, 0xbb,
	0x13, 0x60, 0xf6, 0x8a, 0xe4, 0x61, 0x29, 0x33, 0xcd, 0x1f, 0xdc, 0x4c, 0x47, 0xf7, 0x6f, 0xa6,
	0x63, 0x43, 0x9b, 0x29, 0xf9, 0x50, 0x95, 0xb6, 0xdc, 0xf7, 0x70, 0x03, 0x4d, 0x50, 0x6d, 0xa4,
	0xcd, 0x55, 0x67, 0xcb, 0x85, 0x8d, 0xdf, 0x5d, 0xdb, 0xe1, 0x26, 0x46, 0x1e, 0x27, 0x6e, 0x62,
	0x64, 0x94, 0xe8, 0x46, 0x82, 0x2a, 0xed, 0x24, 0xd4, 0x7d, 0xe7, 0x08, 0x29, 0x7f, 0x90, 0xbb,
	0x7f, 0x89, 0xdb, 0xa7, 0x2a, 0x42, 0x82, 0x87, 0x24, 0x74, 0x65, 0x78, 0xdf, 0xf8, 0x12, 0x2a,
	0x50, 0x16, 0x72, 0xb8, 0x05, 0x0b, 0x8f, 0x41, 0x61, 0xe1, 0x31, 0x44, 0x0c, 0xd1, 0xcd, 0x72,
	0x62, 0xe7, 0x26, 0xf7, 0x0e, 0xc7, 0xa4, 0xac, 0xb6, 0x28, 0x65, 0xb5, 0x3c, 0xa9, 0x6d, 0xa3,
	0x92, 0xb8, 0x13, 0x02, 0xf1, 0x8c, 0x0c, 0x79, 0x96, 0x7e, 0xb2, 0x1b, 0x6a, 0xa9, 0xb1, 0xc2,
	0x8b, 0x25, 0x71, 0x62, 0xa4, 0x08, 0x13, 0x81, 0x3d, 0xbf, 0xd7, 0xc0, 0xfe, 0x81, 0x8a, 0x26,
	0x2e, 0x36, 0x5c, 0x33, 0x58, 0x77, 0xdd, 0xc6, 0xc3, 0xe4, 0x78, 0x70, 0x74, 0xbc, 0x26, 0xcb,
	0xc9, 0xf7, 0xf0, 0xab, 0x68, 0xa2, 0xe6, 0x3a, 0x6d, 0x9f, 0xb6, 0xa9, 0x93, 0x63, 0x5a, 0x09,
	0x97, 0x22, 0x32, 0x2e, 0x54, 0x5d, 0x46, 0x89, 0x91, 0x20, 0xa2, 0xa7, 0x29, 0xfc, 0x5f, 0x6d,
	0xab, 0xd5, 0xa1, 0x7a, 0xcb, 0xb6, 0xf6, 0xf3, 0xf9, 0xca, 0xf5, 0x5e, 0xc6, 0x42, 0x7d, 0x0f,
	0x77, 0x50, 0x49, 0x00, 0x52, 0xa2, 0x30, 0x37, 0xe8, 0xfc, 0x20, 0x1f, 0x1d, 0x99, 0xf6, 0x27,
	0xc7, 0x0b, 0xed, 0x4f, 0xe2, 0xc4, 0x48, 0x11, 0x92, 0x3f, 0x8e, 0xa0, 0x72, 0x9a, 0x23, 0x55,
	0x97, 0x48, 0xf7, 0x14, 0xa1, 0x2e, 0x42, 0xf7, 0x4a, 0x49, 0xdd, 0xcb, 0xd4, 0x33, 0xf5, 0x20,
	0x7a, 0x96, 0xdb, 0xb7, 0x83, 0x7d, 0x11, 0x8d, 0xb3, 0x4f, 0xe1, 0xda, 0x5a, 0x60, 0xd6, 0x1c,
	0x61, 0xc2, 0x9a, 0x23, 0x84, 0x18, 0x71, 0x67, 0xec, 0xae, 0xf2, 0xc3, 0xb8, 0xab, 0x84, 0x73,
	0x1c, 0xdd, 0x87, 0x73, 0x5c, 0x42, 0x88, 0x5f, 0x64, 0xd0, 0x0c, 0x68, 0x4c, 0x44, 0x62, 0x81,
	0x8a, 0x48, 0x2c, 0x30, 0x62, 0x48, 0x04, 0xd8, 0x42, 0x88, 0xb9, 0x42, 0x50, 0x9b, 0xf1, 0x21,
	0x1d, 0x26, 0x4c, 0x23, 0xc6, 0x89, 0x69, 0x04, 0x46, 0x0c, 0x89, 0x80, 0x7e, 0x2c, 0xec, 0x31,
	0xbc, 0x94, 0x16, 0xc4, 0x1d, 0x76, 0x0c, 0x8a, 0x8f, 0x8d, 0x21, 0x62, 0x88, 0x6e, 0xf2, 0x57,
	0x05, 0x95, 0x57, 0xac, 0xe0, 0x73, 0x6e, 0xa0, 0xf8, 0x8a, 0xa4, 0x3e, 0xec, 0xe2, 0xff, 0x5c,
	0x4a, 0x7d, 0x66, 0x53, 0xea, 0x93, 0x7d, 0x44, 0x8f, 0xbb, 0x3b, 0xe9, 0xcf, 0xf6, 0x3d, 0xba,
	0x67, 0x7d, 0xa6, 0x3e, 0xe4, 0x9e, 0x25, 0x4c, 0x3c, 0xa1, 0x1a, 0x7c, 0xcf, 0xa4, 0xc6, 0x8f,
	0x47, 0xf8, 0x9b, 0xfa, 0x86, 0xbd, 0xed, 0x3c, 0x8c, 0x4d, 0x83, 0x7d, 0x86, 0xd0, 0x9e, 0xfc,
	0xc1, 0xb4, 0x87, 0x3f, 0xc5, 0xc2, 0xc5, 0x24, 0xec, 0xed, 0xe8, 0x5e, 0x9f, 0x62, 0xe3, 0xa1,
	0xc9, 0xa7, 0xd8, 0x18, 0x8e, 0x9e, 0x62, 0x63, 0x00, 0xde, 0xaa, 0xcc, 0x5b, 0x16, 0x73, 0x43,
	0x63, 0x70, 0x47, 0xc3, 0xde, 0xaa, 0x22, 0x50, 0xca, 0xe6, 0x23, 0x08, 0xde, 0xaa, 0xe2, 0x46,
	0x4f, 0x91, 0xf5, 0xc4, 0xf7, 0xf0, 0xff, 0xa1, 0xf1, 0x25, 0xd7, 0x0f, 0xf6, 0xa4, 0x9d, 0xf0,
	0xbc, 0x16, 0x8d, 0x12, 0xce, 0x20, 0x42, 0x88, 0x6e, 0xc4, 0xbd, 0xf8, 0x29, 0x34, 0xf2, 0x9f,
	0xae, 0xed, 0xf0, 0x5b, 0x58, 0xb8, 0xeb, 0xa4, 0x6d, 0x71, 0x7f, 0x43, 0x5b, 0x44, 0x37, 0x00,
	0xc5, 0x57, 0x51, 0x29, 0x5e, 0xdd, 0x12, 0xdc, 0x74, 0x31, 0x35, 0x81, 0x27, 0xc7, 0x64, 0x8f,
	0x78, 0x72, 0x4c, 0xe2, 0x44, 0x37, 0x52, 0x94, 0x90, 0x32, 0xd0, 0x5d, 0x63, 0xc7, 0x59, 0x6b,
	0xd3, 0xfd, 0xbc, 0xa6, 0x0c, 0x59, 0x0b, 0xf5, 0x3d, 0xfc, 0x9e, 0x82, 0x0e, 0xa7, 0x60, 0x69,
	0xbf, 0x06, 0xbf, 0x98, 0x33, 0x52, 0xbe, 0x69, 0xcf, 0x75, 0x43, 0x2d, 0x8b, 0x4b, 0x2f, 0xd4,
	0x4e, 0x88, 0x15, 0xa6, 0x3a, 0x89, 0x6e, 0x64, 0x8d, 0x21, 0x7f, 0x1b, 0x41, 0xd3, 0x7d, 0x53,
	0xec, 0x3f, 0x95, 0x78, 0x59, 0x8e, 0x38, 0xaa, 0x78, 0x83, 0x95, 0x23, 0xce, 0x74, 0x3a, 0xe2,
	0xe8, 0x52, 0xc8, 0xe9, 0x7b, 0xda, 0xcf, 0x1d, 0xe8, 0x69, 0x5f, 0x72, 0x53, 0x23, 0x07, 0x71,
	0x53, 0xfb, 0x7e, 0x40, 0x8a, 0xb3, 0x93, 0xd1, 0x3d, 0x67, 0x27, 0x63, 0x07, 0xce, 0x4e, 0xc6,
	0xef, 0x45, 0x76, 0x52, 0xb8, 0x4f, 0xd9, 0x09, 0xf9, 0x50, 0x45, 0x47, 0xa4, 0xc2, 0x2e, 0x56,
	0xcd, 0xf0, 0x30, 0xe2, 0x0d, 0x3e, 0x8d, 0xbd, 0x93, 0xcb, 0x12, 0x98, 0xef, 0xa5, 0xeb, 0x6f,
	0x94, 0x7f, 0x46, 0xfd, 0x4d, 0xa2, 0x62, 0x46, 0x3d, 0x50, 0xc5, 0xcc, 0x7f, 0xa3, 0xa9, 0x88,
	0x79, 0x74, 0xc3, 0xc5, 0xae, 0x1e, 0x16, 0xba, 0xa1, 0x96, 0xee, 0xea, 0x85, 0xda, 0xb1, 0xe4,
	0xfa, 0xa2, 0xbb, 0x2e, 0xdd, 0x48, 0xd3, 0xe2, 0x75, 0x34, 0x09, 0x50, 0x7c, 0xed, 0xc5, 0x6e,
	0x2c, 0x21, 0x70, 0x27, 0x3a, 0x44, 0xe0, 0x4e, 0xc0, 0x34, 0x70, 0x27, 0x81, 0x8f, 0x55, 0x76,
	0xf2, 0x62, 0x5a, 0xe1, 0x6c, 0xb9, 0x0f, 0x15, 0x76, 0xb0, 0xef, 0x7b, 0x36, 0x95, 0xa2, 0x0d,
	0xf5, 0x76, 0x4f, 0x7e, 0x9b, 0x4b, 0x8b, 0xd8, 0xf7, 0x52, 0xcf, 0x41, 0xca, 0x3e, 0x9f, 0x83,
	0x22, 0x67, 0xac, 0xee, 0xd9, 0x19, 0xe7, 0xf6, 0xe1, 0x8c, 0x9d, 0x44, 0x25, 0xd8, 0xc8, 0x5e,
	0x2b, 0xc1, 0x66, 0xfb, 0x2a, 0xc1, 0xa6, 0xfb, 0x2a, 0xc1, 0x12, 0x85, 0x60, 0x69, 0xab, 0xcc,
	0x1f, 0xc8, 0x2a, 0x2f, 0xa1, 0x89, 0x4b, 0xa6, 0x1f, 0x2c, 0xdb, 0x5b, 0xf2, 0x61, 0x19, 0xb8,
	0xc9, 0xb8, 0xe0, 0x26, 0xa3, 0x94, 0x5b, 0xa2, 0xfd, 0x99, 0x8a, 0x26, 0x28, 0x67, 0x98, 0xe2,
	0x01, 0xb4, 0x99, 0x7b, 0x57, 0x01, 0x7c, 0xaf, 0xce, 0x35, 0xe4, 0x8a, 0x2c, 0x71, 0xdf, 0xa3,
	0xfa, 0x1c, 0xb7, 0xf9, 0xbb, 0x30, 0xe8, 0x73, 0x0c, 0x0a, 0x7d, 0x8e, 0x21, 0x62, 0x88, 0x6e,
	0xf2, 0x53, 0xee, 0xfb, 0xa0, 0x75, 0xcf, 0x8b, 0xd2, 0x1f, 0xb0, 0x7d, 0x24, 0x7f, 0x57, 0xd2,
	0xd2, 0xf2, 0x3d, 0x1c, 0xa0, 0xc9, 0x04, 0xc6, 0x33, 0xff, 0xd9, 0x41, 0x57, 0x86, 0xbc, 0xa4,
	0x1a, 0x12, 0xac, 0x27, 0x68, 0xd4, 0x4a, 0x8c, 0x16, 0xb6, 0x97, 0x80, 0x89, 0x91, 0x24, 0x4b,
	0xe7, 0x07, 0xea, 0xfd, 0xce, 0x0f, 0xc8, 0x17, 0xd1, 0x54, 0x6a, 0xf5, 0x52, 0x2c, 0x50, 0xf6,
	0x50, 0xc7, 0xb5, 0xd7, 0xb2, 0x01, 0xf2, 0x0b, 0x15, 0x1d, 0x93, 0x72, 0xa4, 0xf3, 0x8d, 0xc6,
	0x7d, 0xb8, 0xb8, 0x7a, 0xd0, 0x54, 0xf5, 0x2b, 0x03, 0x64, 0xe6, 0x7b, 0xb8, 0xce, 0x62, 0x18,
	0x2f, 0x2c, 0x56, 0x06, 0x17, 0xc8, 0x9c, 0x97, 0xee, 0xb6, 0xe3, 0xc8, 0x15, 0xd7, 0x14, 0x4f,
	0xa7, 0xef, 0xb5, 0x79, 0xe4, 0xe2, 0x8d, 0x9f, 0x28, 0xa8, 0x28, 0x31, 0xd8, 0xa7, 0xb2, 0x24,
	0x6f, 0xe8, 0xd4, 0xfb, 0x75, 0x43, 0x77, 0x0d, 0x95, 0xe3, 0x5f, 0xa7, 0x50, 0x01, 0xde, 0x4b,
	0xd5, 0x22, 0xf5, 0x34, 0x73, 0xdf, 0xc3, 0xeb, 0xfd, 0xbf, 0xaa, 0x99, 0x1d, 0x68, 0xbc, 0x74,
	0xd0, 0xae, 0xbf, 0xa9, 0xf9, 0x61, 0x9e, 0xa7, 0xdc, 0x82, 0xfa, 0x81, 0xfd, 0x45, 0xcd, 0xcb,
	0x72, 0xc1, 0x03, 0x0b, 0xa9, 0x24, 0x5d, 0xf0, 0x30, 0x9d, 0x2e, 0x78, 0xd0, 0xe5, 0x8a, 0x87,
	0xe7, 0x45, 0xc5, 0x03, 0x4b, 0x82, 0x66, 0x92, 0x15, 0x0f, 0x53, 0xc9, 0x8a, 0x07, 0x5d, 0x14,
	0x73, 0xa7, 0x2f, 0x33, 0xc6, 0x0e, 0x74, 0x99, 0x91, 0x72, 0xe3, 0xe3, 0xf7, 0xfd, 0x98, 0xf7,
	0x25, 0xfe, 0xcb, 0x02, 0x61, 0x54, 0x85, 0xbd, 0x54, 0x8a, 0x8a, 0x9f, 0x17, 0xc8, 0xd6, 0x25,
	0xff, 0xbc, 0x40, 0x18, 0x55, 0xf4, 0xf3, 0x82, 0x18, 0x39, 0xf3, 0x23, 0x85, 0x5f, 0x21, 0xbe,
	0x7e, 0xf6, 0x42, 0xab, 0x45, 0x3f, 0x02, 0x63, 0x54, 0x02, 0xd3, 0x5d, 0x73, 0x83, 0xcb, 0x6e,
	0xdd, 0xde, 0xea, 0x94, 0x0f, 0xe1, 0xc3, 0x68, 0x72, 0xc5, 0x0a, 0x58, 0x15, 0xec, 0x45, 0xd3,
	0x6e, 0x94, 0xdf, 0xbd, 0xa3, 0xe0, 0x69, 0x56, 0xc5, 0xb6, 0xe6, 0x06, 0x1b, 0xf6, 0xb6, 0x53,
	0xfe, 0xda, 0x1d, 0x05, 0x57, 0xd1, 0x91, 0x35, 0x37, 0xb8, 0xd8, 0x6e, 0x34, 0x12, 0x3f, 0x8a,
	0x29, 0xdf, 0xbe, 0xa3, 0xe0, 0x23, 0xa8, 0x24, 0xf5, 0xad, 0x9b, 0x9d, 0xf2, 0xd7, 0xef, 0x28,
	0xb8, 0x84, 0xc6, 0x69, 0x13, 0x98, 0x7e, 0x83, 0x51, 0x2d, 0x99, 0xce, 0xa6, 0xd5, 0x88, 0xd1,
	0x6f, 0xde, 0x51, 0xce, 0xfc, 0x5c, 0xe1, 0x17, 0x68, 0xb2, 0xb8, 0xf1, 0x61, 0x71, 0xa4, 0x0d,
	0xda, 0xfe, 0xaa, 0x63, 0x07, 0xe5, 0x43, 0x78, 0x9a, 0x9f, 0x46, 0xd7, 0xdc, 0x00, 0x94, 0xab,
	0xac, 0xe0, 0x09, 0x34, 0x0e, 0x90, 0xed, 0x6c, 0x97, 0xd5, 0xb8, 0xb5, 0xde, 0xb2, 0xca, 0x39,
	0x5c, 0xe2, 0xf5, 0xed, 0x17, 0x6d, 0xc7, 0x6c, 0x94, 0x47, 0xe2, 0xde, 0x0b, 0x4e, 0xbd, 0x9c,
	0x8f, 0x99, 0x2d, 0x5b, 0x66, 0xfd, 0x92, 0xed, 0x58, 0xe5, 0x51, 0x5c, 0x46, 0x13, 0x54, 0x32,
	0xd1, 0x6f, 0x8c, 0xca, 0x63, 0xf8, 0x28, 0x5f, 0x1b, 0x7b, 0x77, 0x6d, 0x59, 0xaf, 0x58, 0x66,
	0x50, 0x1e, 0x3f, 0xe3, 0xa2, 0xa3, 0x99, 0x47, 0x0e, 0x2a, 0x60, 0x81, 0xf0, 0x55, 0x4f, 0x31,
	0x59, 0xd2, 0x8f, 0x5e, 0x73, 0x83, 0xb2, 0x82, 0x8b, 0x68, 0x8c, 0x02, 0x57, 0xda, 0x41, 0x59,
	0x8d, 0x46, 0x9c, 0x6f, 0x34, 0xdc, 0xb7, 0x20, 0xdc, 0x97, 0x73, 0x74, 0x1d, 0x5c, 0xfa, 0x0c,
	0x19, 0x79, 0xe6, 0x2f, 0x65, 0x34, 0xc6, 0x55, 0x06, 0x3f, 0x87, 0x46, 0xd6, 0x6d, 0x67, 0x1b,
	0x3f, 0xb2, 0xc0, 0x7e, 0xfd, 0xb8, 0x10, 0xfd, 0x34, 0x72, 0xe1, 0x42, 0xd3, 0x0b, 0x3a, 0xd5,
	0x01, 0x38, 0x7e, 0x53, 0xf2, 0x82, 0x58, 0x1f, 0xa8, 0xf5, 0x3c, 0x2f, 0xad, 0xee, 0x42, 0xe1,
	0x7b, 0x44, 0xff, 0xea, 0xef, 0xfe, 0xf0, 0x1d, 0xb5, 0x4a, 0x2a, 0x8b, 0x97, 0x19, 0xe5, 0x22,
	0x3c, 0xf2, 0x2e, 0x8a, 0x59, 0x6e, 0x2b, 0x68, 0x2a, 0x55, 0xfc, 0x8d, 0x4f, 0x67, 0xf1, 0xed,
	0x2f, 0xc3, 0xaf, 0x0e, 0x45, 0xe7, 0x7b, 0x64, 0x16, 0x56, 0x71, 0x92, 0x9c, 0x48, 0xad, 0x22,
	0x31, 0xa9, 0x8b, 0x8a, 0x52, 0x39, 0x2f, 0x26, 0x59, 0xbc, 0x93, 0xf5, 0xbe, 0xd5, 0xcc, 0xdf,
	0x76, 0xc5, 0x25, 0xa2, 0xe4, 0x24, 0x4c, 0x7b, 0x8c, 0x1c, 0x8d, 0xa7, 0x65, 0x43, 0x17, 0xd9,
	0xd1, 0xf5, 0x76, 0xf4, 0xe4, 0x9d, 0xa8, 0x8d, 0xc3, 0x99, 0x4f, 0xdb, 0xe9, 0x12, 0xc9, 0xea,
	0x10, 0x54, 0xbe, 0x47, 0xe6, 0x60, 0x05, 0x33, 0xe4, 0xd1, 0xd4, 0x87, 0x27, 0x67, 0x6c, 0xa1,
	0x49, 0x80, 0xa3, 0x2a, 0x22, 0x9c, 0x99, 0x7c, 0x48, 0x65, 0x65, 0xd5, 0x9d, 0x09, 0x7c, 0x8f,
	0x68, 0x30, 0xf1, 0x71, 0x72, 0x2c, 0x35, 0x71, 0x3c, 0xc5, 0xdb, 0x68, 0x7a, 0xc5, 0x0a, 0xa0,
	0xf0, 0x21, 0x2e, 0x58, 0xc8, 0xd6, 0x38, 0xb9, 0x88, 0xa4, 0xba, 0x0b, 0xc5, 0x0e, 0x7b, 0x2d,
	0x97, 0x45, 0xe0, 0x77, 0x15, 0x34, 0x95, 0xaa, 0x36, 0xc8, 0x56, 0xba, 0xfe, 0xda, 0x89, 0xea,
	0x50, 0x74, 0xbe, 0x47, 0x4e, 0xc1, 0x42, 0x4e, 0x90, 0xe3, 0xa9, 0x85, 0x48, 0x53, 0xbe, 0x0d,
	0x7e, 0x55, 0x02, 0xe6, 0x06, 0x28, 0x74, 0x72, 0x05, 0x43, 0x50, 0x65, 0x6e, 0xc1, 0x8a, 0x15,
	0xc8, 0xb3, 0x7f, 0x81, 0x1b, 0x3b, 0xf5, 0x3a, 0x3b, 0x18, 0x3b, 0x7f, 0x23, 0xad, 0xee, 0x42,
	0xe1, 0x7b, 0xe4, 0x38, 0xcc, 0x78, 0x98, 0x4c, 0x0b, 0x7d, 0xe7, 0x4e, 0x0d, 0x7f, 0x5b, 0x41,
	0x47, 0x62, 0x19, 0x49, 0x6f, 0x21, 0xd9, 0x52, 0xef, 0x7f, 0x7e, 0xaa, 0x0e, 0x45, 0xe7, 0x7b,
	0xe4, 0x34, 0xac, 0x41, 0x27, 0x33, 0x19, 0x52, 0x97, 0xe7, 0x7d, 0x5f, 0x41, 0x8f, 0x40, 0x4f,
	0xdf, 0x65, 0x2f, 0x9e, 0xdf, 0xe5, 0xd7, 0xd4, 0xf1, 0x25, 0x7a, 0x75, 0x48, 0x4a, 0xdf, 0x23,
	0xf3, 0xb0, 0x2c, 0x42, 0xf4, 0xd4, 0xb2, 0xfa, 0x67, 0xbf, 0x2d, 0x17, 0xc2, 0xc4, 0xd7, 0x73,
	0x78, 0x6e, 0xc7, 0xef, 0xe7, 0x97, 0xa4, 0xd5, 0x21, 0xa8, 0x76, 0xf0, 0x0a, 0xc9, 0x19, 0x6f,
	0xa1, 0xd2, 0xd2, 0x0d, 0x6b, 0xf3, 0x66, 0x7c, 0xc8, 0xcc, 0xd6, 0x11, 0xf9, 0xc2, 0xa9, 0xba,
	0x0b, 0x45, 0x66, 0x40, 0x80, 0x49, 0x16, 0xc5, 0x2c, 0x09, 0x01, 0x88, 0xf3, 0xf5, 0xdc, 0x8e,
	0xac, 0xa3, 0x88, 0x34, 0x04, 0xd5, 0x2e, 0x02, 0x10, 0x33, 0x7e, 0x5f, 0x41, 0xc7, 0x56, 0xac,
	0x20, 0xeb, 0xd4, 0x86, 0x9f, 0xdc, 0x65, 0xe7, 0xe5, 0x33, 0x71, 0x75, 0x78, 0x62, 0xdf, 0x23,
	0x4f, 0xc0, 0xda, 0x66, 0xc9, 0xa9, 0x84, 0xd9, 0x66, 0x2e, 0xe2, 0x1d, 0x85, 0xe7, 0x27, 0xd1,
	0x41, 0x26, 0x5b, 0x48, 0xe9, 0x83, 0x54, 0x75, 0x08, 0xaa, 0x1d, 0x84, 0x94, 0x20, 0xac, 0x1d,
	0xff, 0xe8, 0x93, 0x99, 0x43, 0x1f, 0xdd, 0x9d, 0x51, 0x7e, 0x73, 0x77, 0x46, 0xf9, 0xf8, 0xee,
	0x8c, 0xf2, 0xbd, 0x4f, 0x67, 0x0e, 0xfd, 0x4f, 0xce, 0xf4, 0xec, 0xeb, 0xa3, 0x90, 0x5c, 0x9c,
	0xfb, 0x47, 0x00, 0x00, 0x00, 0xff, 0xff, 0x96, 0x54, 0x9b, 0xaa, 0xed, 0x41, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Matchv1Client is the client API for Matchv1 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type Matchv1Client interface {
	Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	//1,获取比赛列表，此处的ArenatimeID不会单独列出来作为一个比赛
	MatchList(ctx context.Context, in *MatchListReq, opts ...grpc.CallOption) (*MatchListRsp, error)
	//2,拉去特定场次的奖励的列表
	GetRewardConfig(ctx context.Context, in *GetRewardConfigReq, opts ...grpc.CallOption) (*GetRewardConfigRsp, error)
	//3,每局结算
	ScoreUpload(ctx context.Context, in *ScoreUploadReq, opts ...grpc.CallOption) (*CommonRsp, error)
	//4,获取实时排行
	QueryImmediateRank(ctx context.Context, in *ImmediateRankReq, opts ...grpc.CallOption) (*ImmediateRankRsp, error)
	//5,获取往期排行
	QueryLastRank(ctx context.Context, in *LastRankReq, opts ...grpc.CallOption) (*LastRankRsp, error)
	//6,获取浮动奖金池
	GetFloatBonusPool(ctx context.Context, in *FloatPoolReq, opts ...grpc.CallOption) (*FloatPoolRsp, error)
	//7,查询玩家奖励
	QueryUserReward(ctx context.Context, in *QueryUserRewardReq, opts ...grpc.CallOption) (*QueryUserRewardRsp, error)
	//8,领取玩家奖励
	GetUserReward(ctx context.Context, in *GetUserRewardReq, opts ...grpc.CallOption) (*GetUserRewardRsp, error)
	//9，比赛报名
	MatchSign(ctx context.Context, in *MatchSignReq, opts ...grpc.CallOption) (*MatchSignRsp, error)
	//10，查询个人战绩
	QueryUserMatchRecord(ctx context.Context, in *UserMatchRecordReq, opts ...grpc.CallOption) (*UserMatchRecordRsp, error)
	//11，查询特定场次的比赛的状态
	QueryTargetMatchStatus(ctx context.Context, in *TargetMatchStatusReq, opts ...grpc.CallOption) (*TargetMatchStatusRsp, error)
	// 12，查询特定场次比赛的用户信息
	QueryUserMatchInfo(ctx context.Context, in *UserMatchInfoReq, opts ...grpc.CallOption) (*UserMatchInfoRsp, error)
	//13.检查用户是否有进入比赛的资格
	CheckUserEnter(ctx context.Context, in *UserEnterReq, opts ...grpc.CallOption) (*UserEnterRsp, error)
	//14获取对应的比赛状态以及进入决赛的人的名单
	QueryUserEnterList(ctx context.Context, in *UserEnterListReq, opts ...grpc.CallOption) (*UserEnterListRsp, error)
	// 15 一次性领取本场比赛所有玩家奖励
	GetTargetMatchAllReward(ctx context.Context, in *TargetMatchAllRewardReq, opts ...grpc.CallOption) (*TargetMatchAllRewardRsp, error)
	//16,获取比赛列表开赛时间
	MatchListTime(ctx context.Context, in *MatchListTimeReq, opts ...grpc.CallOption) (*MatchListTimeRsp, error)
}

type matchv1Client struct {
	cc *grpc.ClientConn
}

func NewMatchv1Client(cc *grpc.ClientConn) Matchv1Client {
	return &matchv1Client{cc}
}

func (c *matchv1Client) Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) MatchList(ctx context.Context, in *MatchListReq, opts ...grpc.CallOption) (*MatchListRsp, error) {
	out := new(MatchListRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/MatchList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) GetRewardConfig(ctx context.Context, in *GetRewardConfigReq, opts ...grpc.CallOption) (*GetRewardConfigRsp, error) {
	out := new(GetRewardConfigRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/GetRewardConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) ScoreUpload(ctx context.Context, in *ScoreUploadReq, opts ...grpc.CallOption) (*CommonRsp, error) {
	out := new(CommonRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/ScoreUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) QueryImmediateRank(ctx context.Context, in *ImmediateRankReq, opts ...grpc.CallOption) (*ImmediateRankRsp, error) {
	out := new(ImmediateRankRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/QueryImmediateRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) QueryLastRank(ctx context.Context, in *LastRankReq, opts ...grpc.CallOption) (*LastRankRsp, error) {
	out := new(LastRankRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/QueryLastRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) GetFloatBonusPool(ctx context.Context, in *FloatPoolReq, opts ...grpc.CallOption) (*FloatPoolRsp, error) {
	out := new(FloatPoolRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/GetFloatBonusPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) QueryUserReward(ctx context.Context, in *QueryUserRewardReq, opts ...grpc.CallOption) (*QueryUserRewardRsp, error) {
	out := new(QueryUserRewardRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/QueryUserReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) GetUserReward(ctx context.Context, in *GetUserRewardReq, opts ...grpc.CallOption) (*GetUserRewardRsp, error) {
	out := new(GetUserRewardRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/GetUserReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) MatchSign(ctx context.Context, in *MatchSignReq, opts ...grpc.CallOption) (*MatchSignRsp, error) {
	out := new(MatchSignRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/MatchSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) QueryUserMatchRecord(ctx context.Context, in *UserMatchRecordReq, opts ...grpc.CallOption) (*UserMatchRecordRsp, error) {
	out := new(UserMatchRecordRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/QueryUserMatchRecord", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) QueryTargetMatchStatus(ctx context.Context, in *TargetMatchStatusReq, opts ...grpc.CallOption) (*TargetMatchStatusRsp, error) {
	out := new(TargetMatchStatusRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/QueryTargetMatchStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) QueryUserMatchInfo(ctx context.Context, in *UserMatchInfoReq, opts ...grpc.CallOption) (*UserMatchInfoRsp, error) {
	out := new(UserMatchInfoRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/QueryUserMatchInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) CheckUserEnter(ctx context.Context, in *UserEnterReq, opts ...grpc.CallOption) (*UserEnterRsp, error) {
	out := new(UserEnterRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/CheckUserEnter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) QueryUserEnterList(ctx context.Context, in *UserEnterListReq, opts ...grpc.CallOption) (*UserEnterListRsp, error) {
	out := new(UserEnterListRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/QueryUserEnterList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) GetTargetMatchAllReward(ctx context.Context, in *TargetMatchAllRewardReq, opts ...grpc.CallOption) (*TargetMatchAllRewardRsp, error) {
	out := new(TargetMatchAllRewardRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/GetTargetMatchAllReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchv1Client) MatchListTime(ctx context.Context, in *MatchListTimeReq, opts ...grpc.CallOption) (*MatchListTimeRsp, error) {
	out := new(MatchListTimeRsp)
	err := c.cc.Invoke(ctx, "/matchv1.service.v1.matchv1/MatchListTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Matchv1Server is the server API for Matchv1 service.
type Matchv1Server interface {
	Ping(context.Context, *empty.Empty) (*empty.Empty, error)
	//1,获取比赛列表，此处的ArenatimeID不会单独列出来作为一个比赛
	MatchList(context.Context, *MatchListReq) (*MatchListRsp, error)
	//2,拉去特定场次的奖励的列表
	GetRewardConfig(context.Context, *GetRewardConfigReq) (*GetRewardConfigRsp, error)
	//3,每局结算
	ScoreUpload(context.Context, *ScoreUploadReq) (*CommonRsp, error)
	//4,获取实时排行
	QueryImmediateRank(context.Context, *ImmediateRankReq) (*ImmediateRankRsp, error)
	//5,获取往期排行
	QueryLastRank(context.Context, *LastRankReq) (*LastRankRsp, error)
	//6,获取浮动奖金池
	GetFloatBonusPool(context.Context, *FloatPoolReq) (*FloatPoolRsp, error)
	//7,查询玩家奖励
	QueryUserReward(context.Context, *QueryUserRewardReq) (*QueryUserRewardRsp, error)
	//8,领取玩家奖励
	GetUserReward(context.Context, *GetUserRewardReq) (*GetUserRewardRsp, error)
	//9，比赛报名
	MatchSign(context.Context, *MatchSignReq) (*MatchSignRsp, error)
	//10，查询个人战绩
	QueryUserMatchRecord(context.Context, *UserMatchRecordReq) (*UserMatchRecordRsp, error)
	//11，查询特定场次的比赛的状态
	QueryTargetMatchStatus(context.Context, *TargetMatchStatusReq) (*TargetMatchStatusRsp, error)
	// 12，查询特定场次比赛的用户信息
	QueryUserMatchInfo(context.Context, *UserMatchInfoReq) (*UserMatchInfoRsp, error)
	//13.检查用户是否有进入比赛的资格
	CheckUserEnter(context.Context, *UserEnterReq) (*UserEnterRsp, error)
	//14获取对应的比赛状态以及进入决赛的人的名单
	QueryUserEnterList(context.Context, *UserEnterListReq) (*UserEnterListRsp, error)
	// 15 一次性领取本场比赛所有玩家奖励
	GetTargetMatchAllReward(context.Context, *TargetMatchAllRewardReq) (*TargetMatchAllRewardRsp, error)
	//16,获取比赛列表开赛时间
	MatchListTime(context.Context, *MatchListTimeReq) (*MatchListTimeRsp, error)
}

// UnimplementedMatchv1Server can be embedded to have forward compatible implementations.
type UnimplementedMatchv1Server struct {
}

func (*UnimplementedMatchv1Server) Ping(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (*UnimplementedMatchv1Server) MatchList(ctx context.Context, req *MatchListReq) (*MatchListRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchList not implemented")
}
func (*UnimplementedMatchv1Server) GetRewardConfig(ctx context.Context, req *GetRewardConfigReq) (*GetRewardConfigRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRewardConfig not implemented")
}
func (*UnimplementedMatchv1Server) ScoreUpload(ctx context.Context, req *ScoreUploadReq) (*CommonRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScoreUpload not implemented")
}
func (*UnimplementedMatchv1Server) QueryImmediateRank(ctx context.Context, req *ImmediateRankReq) (*ImmediateRankRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryImmediateRank not implemented")
}
func (*UnimplementedMatchv1Server) QueryLastRank(ctx context.Context, req *LastRankReq) (*LastRankRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryLastRank not implemented")
}
func (*UnimplementedMatchv1Server) GetFloatBonusPool(ctx context.Context, req *FloatPoolReq) (*FloatPoolRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFloatBonusPool not implemented")
}
func (*UnimplementedMatchv1Server) QueryUserReward(ctx context.Context, req *QueryUserRewardReq) (*QueryUserRewardRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUserReward not implemented")
}
func (*UnimplementedMatchv1Server) GetUserReward(ctx context.Context, req *GetUserRewardReq) (*GetUserRewardRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserReward not implemented")
}
func (*UnimplementedMatchv1Server) MatchSign(ctx context.Context, req *MatchSignReq) (*MatchSignRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchSign not implemented")
}
func (*UnimplementedMatchv1Server) QueryUserMatchRecord(ctx context.Context, req *UserMatchRecordReq) (*UserMatchRecordRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUserMatchRecord not implemented")
}
func (*UnimplementedMatchv1Server) QueryTargetMatchStatus(ctx context.Context, req *TargetMatchStatusReq) (*TargetMatchStatusRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTargetMatchStatus not implemented")
}
func (*UnimplementedMatchv1Server) QueryUserMatchInfo(ctx context.Context, req *UserMatchInfoReq) (*UserMatchInfoRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUserMatchInfo not implemented")
}
func (*UnimplementedMatchv1Server) CheckUserEnter(ctx context.Context, req *UserEnterReq) (*UserEnterRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckUserEnter not implemented")
}
func (*UnimplementedMatchv1Server) QueryUserEnterList(ctx context.Context, req *UserEnterListReq) (*UserEnterListRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUserEnterList not implemented")
}
func (*UnimplementedMatchv1Server) GetTargetMatchAllReward(ctx context.Context, req *TargetMatchAllRewardReq) (*TargetMatchAllRewardRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTargetMatchAllReward not implemented")
}
func (*UnimplementedMatchv1Server) MatchListTime(ctx context.Context, req *MatchListTimeReq) (*MatchListTimeRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchListTime not implemented")
}

func RegisterMatchv1Server(s *grpc.Server, srv Matchv1Server) {
	s.RegisterService(&_Matchv1_serviceDesc, srv)
}

func _Matchv1_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).Ping(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_MatchList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).MatchList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/MatchList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).MatchList(ctx, req.(*MatchListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_GetRewardConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRewardConfigReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).GetRewardConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/GetRewardConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).GetRewardConfig(ctx, req.(*GetRewardConfigReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_ScoreUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScoreUploadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).ScoreUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/ScoreUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).ScoreUpload(ctx, req.(*ScoreUploadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_QueryImmediateRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImmediateRankReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).QueryImmediateRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/QueryImmediateRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).QueryImmediateRank(ctx, req.(*ImmediateRankReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_QueryLastRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LastRankReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).QueryLastRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/QueryLastRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).QueryLastRank(ctx, req.(*LastRankReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_GetFloatBonusPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FloatPoolReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).GetFloatBonusPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/GetFloatBonusPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).GetFloatBonusPool(ctx, req.(*FloatPoolReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_QueryUserReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserRewardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).QueryUserReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/QueryUserReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).QueryUserReward(ctx, req.(*QueryUserRewardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_GetUserReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRewardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).GetUserReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/GetUserReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).GetUserReward(ctx, req.(*GetUserRewardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_MatchSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchSignReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).MatchSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/MatchSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).MatchSign(ctx, req.(*MatchSignReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_QueryUserMatchRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserMatchRecordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).QueryUserMatchRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/QueryUserMatchRecord",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).QueryUserMatchRecord(ctx, req.(*UserMatchRecordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_QueryTargetMatchStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TargetMatchStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).QueryTargetMatchStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/QueryTargetMatchStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).QueryTargetMatchStatus(ctx, req.(*TargetMatchStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_QueryUserMatchInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserMatchInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).QueryUserMatchInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/QueryUserMatchInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).QueryUserMatchInfo(ctx, req.(*UserMatchInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_CheckUserEnter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserEnterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).CheckUserEnter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/CheckUserEnter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).CheckUserEnter(ctx, req.(*UserEnterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_QueryUserEnterList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserEnterListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).QueryUserEnterList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/QueryUserEnterList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).QueryUserEnterList(ctx, req.(*UserEnterListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_GetTargetMatchAllReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TargetMatchAllRewardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).GetTargetMatchAllReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/GetTargetMatchAllReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).GetTargetMatchAllReward(ctx, req.(*TargetMatchAllRewardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Matchv1_MatchListTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchListTimeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Matchv1Server).MatchListTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchv1.service.v1.matchv1/MatchListTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Matchv1Server).MatchListTime(ctx, req.(*MatchListTimeReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Matchv1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "matchv1.service.v1.matchv1",
	HandlerType: (*Matchv1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Matchv1_Ping_Handler,
		},
		{
			MethodName: "MatchList",
			Handler:    _Matchv1_MatchList_Handler,
		},
		{
			MethodName: "GetRewardConfig",
			Handler:    _Matchv1_GetRewardConfig_Handler,
		},
		{
			MethodName: "ScoreUpload",
			Handler:    _Matchv1_ScoreUpload_Handler,
		},
		{
			MethodName: "QueryImmediateRank",
			Handler:    _Matchv1_QueryImmediateRank_Handler,
		},
		{
			MethodName: "QueryLastRank",
			Handler:    _Matchv1_QueryLastRank_Handler,
		},
		{
			MethodName: "GetFloatBonusPool",
			Handler:    _Matchv1_GetFloatBonusPool_Handler,
		},
		{
			MethodName: "QueryUserReward",
			Handler:    _Matchv1_QueryUserReward_Handler,
		},
		{
			MethodName: "GetUserReward",
			Handler:    _Matchv1_GetUserReward_Handler,
		},
		{
			MethodName: "MatchSign",
			Handler:    _Matchv1_MatchSign_Handler,
		},
		{
			MethodName: "QueryUserMatchRecord",
			Handler:    _Matchv1_QueryUserMatchRecord_Handler,
		},
		{
			MethodName: "QueryTargetMatchStatus",
			Handler:    _Matchv1_QueryTargetMatchStatus_Handler,
		},
		{
			MethodName: "QueryUserMatchInfo",
			Handler:    _Matchv1_QueryUserMatchInfo_Handler,
		},
		{
			MethodName: "CheckUserEnter",
			Handler:    _Matchv1_CheckUserEnter_Handler,
		},
		{
			MethodName: "QueryUserEnterList",
			Handler:    _Matchv1_QueryUserEnterList_Handler,
		},
		{
			MethodName: "GetTargetMatchAllReward",
			Handler:    _Matchv1_GetTargetMatchAllReward_Handler,
		},
		{
			MethodName: "MatchListTime",
			Handler:    _Matchv1_MatchListTime_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *MatchListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchListRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchListRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MatchList) > 0 {
		for iNdEx := len(m.MatchList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	return len(dAtA) - i, nil
}

func (m *TargetMatchDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetMatchDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetMatchDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShowRankReward) > 0 {
		for iNdEx := len(m.ShowRankReward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShowRankReward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.UserStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserStatus))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.EnterUserNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EnterUserNum))
		i--
		dAtA[i] = 0x78
	}
	if len(m.DateProperty) > 0 {
		i -= len(m.DateProperty)
		copy(dAtA[i:], m.DateProperty)
		i = encodeVarintApi(dAtA, i, uint64(len(m.DateProperty)))
		i--
		dAtA[i] = 0x72
	}
	if m.MatchStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchStatus))
		i--
		dAtA[i] = 0x68
	}
	if m.SignPay != nil {
		{
			size, err := m.SignPay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.SignCondition) > 0 {
		for iNdEx := len(m.SignCondition) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignCondition[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.MatchDate != nil {
		{
			size, err := m.MatchDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.EndType != nil {
		{
			size, err := m.EndType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.BeginType != nil {
		{
			size, err := m.BeginType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.EnterDeadline) > 0 {
		i -= len(m.EnterDeadline)
		copy(dAtA[i:], m.EnterDeadline)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EnterDeadline)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Order != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x30
	}
	if m.LimitTimes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LimitTimes))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.ID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BeginDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeginDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeginDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FullNums != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.FullNums))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BeginType) > 0 {
		i -= len(m.BeginType)
		copy(dAtA[i:], m.BeginType)
		i = encodeVarintApi(dAtA, i, uint64(len(m.BeginType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EndDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndTotal != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EndTotal))
		i--
		dAtA[i] = 0x18
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EndType) > 0 {
		i -= len(m.EndType)
		copy(dAtA[i:], m.EndType)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DateDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DateDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DateDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MonthEndDay) > 0 {
		for iNdEx := len(m.MonthEndDay) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MonthEndDay[iNdEx])
			copy(dAtA[i:], m.MonthEndDay[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.MonthEndDay[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Day) > 0 {
		dAtA6 := make([]byte, len(m.Day)*10)
		var j5 int
		for _, num1 := range m.Day {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintApi(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Month) > 0 {
		dAtA8 := make([]byte, len(m.Month)*10)
		var j7 int
		for _, num1 := range m.Month {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintApi(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Week) > 0 {
		dAtA10 := make([]byte, len(m.Week)*10)
		var j9 int
		for _, num1 := range m.Week {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintApi(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PayDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pay) > 0 {
		for iNdEx := len(m.Pay) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pay[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MatchTimes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchTimes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ThingsDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThingsDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThingsDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Num != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetRewardConfigReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRewardConfigReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRewardConfigReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x28
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetRewardConfigRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRewardConfigRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRewardConfigRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardConfigList) > 0 {
		for iNdEx := len(m.RewardConfigList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardConfigList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RewardConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DayRankList) > 0 {
		for iNdEx := len(m.DayRankList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DayRankList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Rank) > 0 {
		dAtA12 := make([]byte, len(m.Rank)*10)
		var j11 int
		for _, num1 := range m.Rank {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintApi(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardThinsDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardThinsDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardThinsDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rate))))
		i--
		dAtA[i] = 0x25
	}
	if m.Num != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x18
	}
	if m.IsRate {
		i--
		if m.IsRate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DayRankList) > 0 {
		for iNdEx := len(m.DayRankList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DayRankList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Rank) > 0 {
		dAtA14 := make([]byte, len(m.Rank)*10)
		var j13 int
		for _, num1 := range m.Rank {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintApi(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScoreUploadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScoreUploadReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScoreUploadReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BetAmount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BetAmount))
		i--
		dAtA[i] = 0x30
	}
	if len(m.UserList) > 0 {
		for iNdEx := len(m.UserList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommonRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AddScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AddScore))
		i--
		dAtA[i] = 0x20
	}
	if m.VirtualBet != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.VirtualBet))
		i--
		dAtA[i] = 0x18
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImmediateRankReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImmediateRankReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImmediateRankReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x38
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x30
	}
	if m.EndPoint != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EndPoint))
		i--
		dAtA[i] = 0x28
	}
	if m.StartPoint != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StartPoint))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImmediateRankRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImmediateRankRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImmediateRankRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x20
	}
	if m.BeginTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BeginTime))
		i--
		dAtA[i] = 0x18
	}
	if m.SelfMatchRank != nil {
		{
			size, err := m.SelfMatchRank.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DayRankList) > 0 {
		for iNdEx := len(m.DayRankList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DayRankList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LastRankReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastRankReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LastRankReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x38
	}
	if m.EndPoint != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EndPoint))
		i--
		dAtA[i] = 0x30
	}
	if m.StartPoint != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StartPoint))
		i--
		dAtA[i] = 0x28
	}
	if m.LastRankNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LastRankNum))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LastRankRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastRankRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LastRankRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DayRankList) > 0 {
		for iNdEx := len(m.DayRankList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DayRankList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x10
	}
	if m.SelfRankInfo != nil {
		{
			size, err := m.SelfRankInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RankDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AddScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AddScore))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RankRewardList) > 0 {
		for iNdEx := len(m.RankRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RankRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x18
	}
	if m.RankScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankScore))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FloatPoolReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatPoolReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FloatPoolReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FloatPoolRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatPoolRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FloatPoolRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BonusPoolNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BonusPoolNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryUserRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserRewardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUserRewardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryUserRewardRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserRewardRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUserRewardRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserRewardList) > 0 {
		for iNdEx := len(m.UserRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserRewardDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRewardDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRewardDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MatchName) > 0 {
		i -= len(m.MatchName)
		copy(dAtA[i:], m.MatchName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.MatchName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ThingsList) > 0 {
		for iNdEx := len(m.ThingsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ThingsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.RewardTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RewardTime))
		i--
		dAtA[i] = 0x38
	}
	if m.RankScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankScore))
		i--
		dAtA[i] = 0x30
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RewardID) > 0 {
		i -= len(m.RewardID)
		copy(dAtA[i:], m.RewardID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RewardID)))
		i--
		dAtA[i] = 0x22
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x10
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetUserRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserRewardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserRewardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardID) > 0 {
		i -= len(m.RewardID)
		copy(dAtA[i:], m.RewardID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RewardID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetUserRewardRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserRewardRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserRewardRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatchSignReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchSignReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchSignReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SaveScore {
		i--
		if m.SaveScore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.SignThinsList) > 0 {
		for iNdEx := len(m.SignThinsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignThinsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchSignRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchSignRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchSignRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MatchSignCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchSignCount))
		i--
		dAtA[i] = 0x18
	}
	if m.Join {
		i--
		if m.Join {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CostList) > 0 {
		for iNdEx := len(m.CostList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CostList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserMatchRecordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMatchRecordReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserMatchRecordReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserMatchRecordRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMatchRecordRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserMatchRecordRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserMatchRecordList) > 0 {
		for iNdEx := len(m.UserMatchRecordList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserMatchRecordList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatchRecordDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchRecordDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchRecordDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ThingsList) > 0 {
		for iNdEx := len(m.ThingsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ThingsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.RewardTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RewardTime))
		i--
		dAtA[i] = 0x40
	}
	if m.RankScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankScore))
		i--
		dAtA[i] = 0x38
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x30
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DateProperty) > 0 {
		i -= len(m.DateProperty)
		copy(dAtA[i:], m.DateProperty)
		i = encodeVarintApi(dAtA, i, uint64(len(m.DateProperty)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MatchName) > 0 {
		i -= len(m.MatchName)
		copy(dAtA[i:], m.MatchName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.MatchName)))
		i--
		dAtA[i] = 0x12
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TargetMatchStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetMatchStatusReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetMatchStatusReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TargetMatchStatusRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetMatchStatusRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetMatchStatusRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MatchEndPoint != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchEndPoint))
		i--
		dAtA[i] = 0x20
	}
	if m.MatchStartPoint != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchStartPoint))
		i--
		dAtA[i] = 0x18
	}
	if m.EnterUserNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EnterUserNum))
		i--
		dAtA[i] = 0x10
	}
	if m.MatchStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserMatchInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMatchInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserMatchInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserMatchInfoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMatchInfoRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserMatchInfoRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastDifScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LastDifScore))
		i--
		dAtA[i] = 0x30
	}
	if m.EnterUserNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EnterUserNum))
		i--
		dAtA[i] = 0x28
	}
	if m.UserStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserStatus))
		i--
		dAtA[i] = 0x20
	}
	if m.RankScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RankScore))
		i--
		dAtA[i] = 0x18
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x10
	}
	if m.VirtualBet != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.VirtualBet))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserEnterReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserEnterReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserEnterReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserEnterRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserEnterRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserEnterRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserEnter {
		i--
		if m.UserEnter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserEnterListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserEnterListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserEnterListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserEnterListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserEnterListRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserEnterListRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MatchStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchStatus))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UserEnterList) > 0 {
		for iNdEx := len(m.UserEnterList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserEnterList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserEnterDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserEnterDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserEnterDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TargetMatchAllRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetMatchAllRewardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetMatchAllRewardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TargetMatchAllRewardRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetMatchAllRewardRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetMatchAllRewardRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserReward) > 0 {
		for iNdEx := len(m.UserReward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserReward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AwardDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AwardDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchListTimeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchListTimeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchListTimeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchListTimeRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchListTimeRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchListTimeRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MatchList) > 0 {
		for iNdEx := len(m.MatchList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatchTimeDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchTimeDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchTimeDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShowRewardList) > 0 {
		for iNdEx := len(m.ShowRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShowRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.MatchStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchStatus))
		i--
		dAtA[i] = 0x40
	}
	if len(m.DateProperty) > 0 {
		i -= len(m.DateProperty)
		copy(dAtA[i:], m.DateProperty)
		i = encodeVarintApi(dAtA, i, uint64(len(m.DateProperty)))
		i--
		dAtA[i] = 0x3a
	}
	if m.EndTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x30
	}
	if m.BeginTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BeginTime))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaTimeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaTimeID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x18
	}
	if m.ID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MatchListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MatchList) > 0 {
		for _, e := range m.MatchList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetMatchDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.LimitTimes != 0 {
		n += 1 + sovApi(uint64(m.LimitTimes))
	}
	if m.Order != 0 {
		n += 1 + sovApi(uint64(m.Order))
	}
	l = len(m.EnterDeadline)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BeginType != nil {
		l = m.BeginType.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EndType != nil {
		l = m.EndType.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchDate != nil {
		l = m.MatchDate.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.SignCondition) > 0 {
		for _, e := range m.SignCondition {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.SignPay != nil {
		l = m.SignPay.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchStatus != 0 {
		n += 1 + sovApi(uint64(m.MatchStatus))
	}
	l = len(m.DateProperty)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EnterUserNum != 0 {
		n += 1 + sovApi(uint64(m.EnterUserNum))
	}
	if m.UserStatus != 0 {
		n += 2 + sovApi(uint64(m.UserStatus))
	}
	if len(m.ShowRankReward) > 0 {
		for _, e := range m.ShowRankReward {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BeginDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BeginType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.FullNums != 0 {
		n += 1 + sovApi(uint64(m.FullNums))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EndDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EndType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EndTotal != 0 {
		n += 1 + sovApi(uint64(m.EndTotal))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DateDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Week) > 0 {
		l = 0
		for _, e := range m.Week {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.Month) > 0 {
		l = 0
		for _, e := range m.Month {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.Day) > 0 {
		l = 0
		for _, e := range m.Day {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.MonthEndDay) > 0 {
		for _, s := range m.MonthEndDay {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PayDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchTimes != 0 {
		n += 1 + sovApi(uint64(m.MatchTimes))
	}
	if len(m.Pay) > 0 {
		for _, e := range m.Pay {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ThingsDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRewardConfigReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRewardConfigRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RewardConfigList) > 0 {
		for _, e := range m.RewardConfigList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rank) > 0 {
		l = 0
		for _, e := range m.Rank {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.DayRankList) > 0 {
		for _, e := range m.DayRankList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardThinsDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	if m.IsRate {
		n += 2
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.Rate != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rank) > 0 {
		l = 0
		for _, e := range m.Rank {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.DayRankList) > 0 {
		for _, e := range m.DayRankList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScoreUploadReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if len(m.UserList) > 0 {
		for _, e := range m.UserList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.BetAmount != 0 {
		n += 1 + sovApi(uint64(m.BetAmount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.VirtualBet != 0 {
		n += 1 + sovApi(uint64(m.VirtualBet))
	}
	if m.AddScore != 0 {
		n += 1 + sovApi(uint64(m.AddScore))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ImmediateRankReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.StartPoint != 0 {
		n += 1 + sovApi(uint64(m.StartPoint))
	}
	if m.EndPoint != 0 {
		n += 1 + sovApi(uint64(m.EndPoint))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ImmediateRankRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DayRankList) > 0 {
		for _, e := range m.DayRankList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.SelfMatchRank != nil {
		l = m.SelfMatchRank.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BeginTime != 0 {
		n += 1 + sovApi(uint64(m.BeginTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovApi(uint64(m.EndTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LastRankReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.LastRankNum != 0 {
		n += 1 + sovApi(uint64(m.LastRankNum))
	}
	if m.StartPoint != 0 {
		n += 1 + sovApi(uint64(m.StartPoint))
	}
	if m.EndPoint != 0 {
		n += 1 + sovApi(uint64(m.EndPoint))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LastRankRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelfRankInfo != nil {
		l = m.SelfRankInfo.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if len(m.DayRankList) > 0 {
		for _, e := range m.DayRankList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.RankScore != 0 {
		n += 1 + sovApi(uint64(m.RankScore))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if len(m.RankRewardList) > 0 {
		for _, e := range m.RankRewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.AddScore != 0 {
		n += 1 + sovApi(uint64(m.AddScore))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FloatPoolReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FloatPoolRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BonusPoolNum != 0 {
		n += 1 + sovApi(uint64(m.BonusPoolNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryUserRewardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryUserRewardRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserRewardList) > 0 {
		for _, e := range m.UserRewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserRewardDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	l = len(m.RewardID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.RankScore != 0 {
		n += 1 + sovApi(uint64(m.RankScore))
	}
	if m.RewardTime != 0 {
		n += 1 + sovApi(uint64(m.RewardTime))
	}
	if len(m.ThingsList) > 0 {
		for _, e := range m.ThingsList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.MatchName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUserRewardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	l = len(m.RewardID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUserRewardRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchSignReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if len(m.SignThinsList) > 0 {
		for _, e := range m.SignThinsList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.SaveScore {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchSignRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CostList) > 0 {
		for _, e := range m.CostList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Join {
		n += 2
	}
	if m.MatchSignCount != 0 {
		n += 1 + sovApi(uint64(m.MatchSignCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserMatchRecordReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserMatchRecordRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserMatchRecordList) > 0 {
		for _, e := range m.UserMatchRecordList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchRecordDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	l = len(m.MatchName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DateProperty)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.RankScore != 0 {
		n += 1 + sovApi(uint64(m.RankScore))
	}
	if m.RewardTime != 0 {
		n += 1 + sovApi(uint64(m.RewardTime))
	}
	if len(m.ThingsList) > 0 {
		for _, e := range m.ThingsList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetMatchStatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetMatchStatusRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchStatus != 0 {
		n += 1 + sovApi(uint64(m.MatchStatus))
	}
	if m.EnterUserNum != 0 {
		n += 1 + sovApi(uint64(m.EnterUserNum))
	}
	if m.MatchStartPoint != 0 {
		n += 1 + sovApi(uint64(m.MatchStartPoint))
	}
	if m.MatchEndPoint != 0 {
		n += 1 + sovApi(uint64(m.MatchEndPoint))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserMatchInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserMatchInfoRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VirtualBet != 0 {
		n += 1 + sovApi(uint64(m.VirtualBet))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.RankScore != 0 {
		n += 1 + sovApi(uint64(m.RankScore))
	}
	if m.UserStatus != 0 {
		n += 1 + sovApi(uint64(m.UserStatus))
	}
	if m.EnterUserNum != 0 {
		n += 1 + sovApi(uint64(m.EnterUserNum))
	}
	if m.LastDifScore != 0 {
		n += 1 + sovApi(uint64(m.LastDifScore))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserEnterReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserEnterRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserEnter {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserEnterListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserEnterListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserEnterList) > 0 {
		for _, e := range m.UserEnterList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.MatchStatus != 0 {
		n += 1 + sovApi(uint64(m.MatchStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserEnterDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetMatchAllRewardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchID != 0 {
		n += 1 + sovApi(uint64(m.MatchID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetMatchAllRewardRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserReward) > 0 {
		for _, e := range m.UserReward {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchListTimeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchListTimeRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MatchList) > 0 {
		for _, e := range m.MatchList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchTimeDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.ArenaTimeID != 0 {
		n += 1 + sovApi(uint64(m.ArenaTimeID))
	}
	if m.BeginTime != 0 {
		n += 1 + sovApi(uint64(m.BeginTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovApi(uint64(m.EndTime))
	}
	l = len(m.DateProperty)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchStatus != 0 {
		n += 1 + sovApi(uint64(m.MatchStatus))
	}
	if len(m.ShowRewardList) > 0 {
		for _, e := range m.ShowRewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MatchListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchList = append(m.MatchList, &TargetMatchDetail{})
			if err := m.MatchList[len(m.MatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetMatchDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetMatchDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetMatchDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitTimes", wireType)
			}
			m.LimitTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterDeadline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnterDeadline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BeginType == nil {
				m.BeginType = &BeginDetail{}
			}
			if err := m.BeginType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndType == nil {
				m.EndType = &EndDetail{}
			}
			if err := m.EndType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchDate == nil {
				m.MatchDate = &DateDetail{}
			}
			if err := m.MatchDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignCondition = append(m.SignCondition, &ThingsDetail{})
			if err := m.SignCondition[len(m.SignCondition)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignPay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignPay == nil {
				m.SignPay = &PayDetail{}
			}
			if err := m.SignPay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchStatus", wireType)
			}
			m.MatchStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchStatus |= MatchV1StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateProperty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DateProperty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterUserNum", wireType)
			}
			m.EnterUserNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnterUserNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserStatus", wireType)
			}
			m.UserStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserStatus |= MatchV1UserStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowRankReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShowRankReward = append(m.ShowRankReward, &RewardConfig{})
			if err := m.ShowRankReward[len(m.ShowRankReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeginDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeginDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeginDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BeginType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullNums", wireType)
			}
			m.FullNums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullNums |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTotal", wireType)
			}
			m.EndTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DateDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DateDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DateDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Week = append(m.Week, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Week) == 0 {
					m.Week = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Week = append(m.Week, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Week", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Month = append(m.Month, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Month) == 0 {
					m.Month = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Month = append(m.Month, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Month", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Day = append(m.Day, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Day) == 0 {
					m.Day = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Day = append(m.Day, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Day", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonthEndDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MonthEndDay = append(m.MonthEndDay, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchTimes", wireType)
			}
			m.MatchTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pay = append(m.Pay, &ThingsDetail{})
			if err := m.Pay[len(m.Pay)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThingsDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThingsDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThingsDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRewardConfigReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRewardConfigReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRewardConfigReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRewardConfigRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRewardConfigRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRewardConfigRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardConfigList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardConfigList = append(m.RewardConfigList, &RewardConfig{})
			if err := m.RewardConfigList[len(m.RewardConfigList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Rank = append(m.Rank, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Rank) == 0 {
					m.Rank = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Rank = append(m.Rank, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayRankList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DayRankList = append(m.DayRankList, &RewardThinsDetail{})
			if err := m.DayRankList[len(m.DayRankList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardThinsDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardThinsDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardThinsDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRate = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rate = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Rank = append(m.Rank, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Rank) == 0 {
					m.Rank = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Rank = append(m.Rank, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayRankList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DayRankList = append(m.DayRankList, &RankDetail{})
			if err := m.DayRankList[len(m.DayRankList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScoreUploadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScoreUploadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScoreUploadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserList = append(m.UserList, &UserDetails{})
			if err := m.UserList[len(m.UserList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetAmount", wireType)
			}
			m.BetAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BetAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualBet", wireType)
			}
			m.VirtualBet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualBet |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddScore", wireType)
			}
			m.AddScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImmediateRankReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImmediateRankReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImmediateRankReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPoint", wireType)
			}
			m.StartPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPoint |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPoint", wireType)
			}
			m.EndPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndPoint |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImmediateRankRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImmediateRankRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImmediateRankRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayRankList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DayRankList = append(m.DayRankList, &RankDetail{})
			if err := m.DayRankList[len(m.DayRankList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfMatchRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelfMatchRank == nil {
				m.SelfMatchRank = &RankDetail{}
			}
			if err := m.SelfMatchRank.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginTime", wireType)
			}
			m.BeginTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastRankReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastRankReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastRankReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRankNum", wireType)
			}
			m.LastRankNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRankNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPoint", wireType)
			}
			m.StartPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPoint |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPoint", wireType)
			}
			m.EndPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndPoint |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastRankRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastRankRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastRankRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfRankInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelfRankInfo == nil {
				m.SelfRankInfo = &RankDetail{}
			}
			if err := m.SelfRankInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayRankList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DayRankList = append(m.DayRankList, &RankDetail{})
			if err := m.DayRankList[len(m.DayRankList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankScore", wireType)
			}
			m.RankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankRewardList = append(m.RankRewardList, &ThingsDetail{})
			if err := m.RankRewardList[len(m.RankRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddScore", wireType)
			}
			m.AddScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatPoolReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatPoolReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatPoolReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatPoolRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatPoolRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatPoolRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusPoolNum", wireType)
			}
			m.BonusPoolNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BonusPoolNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserRewardRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserRewardRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserRewardRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserRewardList = append(m.UserRewardList, &UserRewardDetail{})
			if err := m.UserRewardList[len(m.UserRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRewardDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRewardDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRewardDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankScore", wireType)
			}
			m.RankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTime", wireType)
			}
			m.RewardTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThingsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThingsList = append(m.ThingsList, &ThingsDetail{})
			if err := m.ThingsList[len(m.ThingsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserRewardRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserRewardRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserRewardRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ThingsDetail{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchSignReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchSignReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchSignReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignThinsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignThinsList = append(m.SignThinsList, &ThingsDetail{})
			if err := m.SignThinsList[len(m.SignThinsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaveScore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaveScore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchSignRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchSignRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchSignRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CostList = append(m.CostList, &ThingsDetail{})
			if err := m.CostList[len(m.CostList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Join = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchSignCount", wireType)
			}
			m.MatchSignCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchSignCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMatchRecordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMatchRecordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMatchRecordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMatchRecordRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMatchRecordRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMatchRecordRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMatchRecordList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserMatchRecordList = append(m.UserMatchRecordList, &MatchRecordDetail{})
			if err := m.UserMatchRecordList[len(m.UserMatchRecordList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchRecordDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchRecordDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchRecordDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateProperty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DateProperty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankScore", wireType)
			}
			m.RankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTime", wireType)
			}
			m.RewardTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThingsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThingsList = append(m.ThingsList, &ThingsDetail{})
			if err := m.ThingsList[len(m.ThingsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetMatchStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetMatchStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetMatchStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetMatchStatusRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetMatchStatusRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetMatchStatusRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchStatus", wireType)
			}
			m.MatchStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchStatus |= MatchV1StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterUserNum", wireType)
			}
			m.EnterUserNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnterUserNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchStartPoint", wireType)
			}
			m.MatchStartPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchStartPoint |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchEndPoint", wireType)
			}
			m.MatchEndPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchEndPoint |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMatchInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMatchInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMatchInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMatchInfoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMatchInfoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMatchInfoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualBet", wireType)
			}
			m.VirtualBet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualBet |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankScore", wireType)
			}
			m.RankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserStatus", wireType)
			}
			m.UserStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserStatus |= MatchV1UserStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterUserNum", wireType)
			}
			m.EnterUserNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnterUserNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDifScore", wireType)
			}
			m.LastDifScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastDifScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserEnterReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserEnterReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserEnterReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserEnterRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserEnterRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserEnterRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserEnter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserEnter = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserEnterListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserEnterListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserEnterListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserEnterListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserEnterListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserEnterListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserEnterList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserEnterList = append(m.UserEnterList, &UserEnterDetail{})
			if err := m.UserEnterList[len(m.UserEnterList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchStatus", wireType)
			}
			m.MatchStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchStatus |= MatchV1StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserEnterDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserEnterDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserEnterDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetMatchAllRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetMatchAllRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetMatchAllRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchID", wireType)
			}
			m.MatchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetMatchAllRewardRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetMatchAllRewardRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetMatchAllRewardRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserReward = append(m.UserReward, &AwardDetail{})
			if err := m.UserReward[len(m.UserReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ThingsDetail{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchListTimeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchListTimeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchListTimeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchListTimeRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchListTimeRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchListTimeRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchList = append(m.MatchList, &MatchTimeDetail{})
			if err := m.MatchList[len(m.MatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchTimeDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchTimeDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchTimeDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaTimeID", wireType)
			}
			m.ArenaTimeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaTimeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginTime", wireType)
			}
			m.BeginTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateProperty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DateProperty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchStatus", wireType)
			}
			m.MatchStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchStatus |= MatchV1StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShowRewardList = append(m.ShowRewardList, &RewardThinsDetail{})
			if err := m.ShowRewardList[len(m.ShowRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
