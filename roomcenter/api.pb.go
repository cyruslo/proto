// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

// package 命名使用 {appid}.{version} 的方式, version 形如 v1, v2 ..

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ErrCode int32

const (
	ErrCode_SUCCESS        ErrCode = 0
	ErrCode_ParamsErr      ErrCode = 100000
	ErrCode_ArenaInfoEmpty ErrCode = 100001
)

var ErrCode_name = map[int32]string{
	0:      "SUCCESS",
	100000: "ParamsErr",
	100001: "ArenaInfoEmpty",
}

var ErrCode_value = map[string]int32{
	"SUCCESS":        0,
	"ParamsErr":      100000,
	"ArenaInfoEmpty": 100001,
}

func (x ErrCode) String() string {
	return proto.EnumName(ErrCode_name, int32(x))
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

//客户端请求分配房间
type AllocRoomReq struct {
	PlayerID             int64    `protobuf:"varint,1,opt,name=PlayerID,proto3" json:"PlayerID" form:"PlayerID"`
	GameID               int32    `protobuf:"varint,3,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	GroupID              int32    `protobuf:"varint,4,opt,name=GroupID,proto3" json:"GroupID" form:"GroupID" validate:"required"`
	Type                 int32    `protobuf:"varint,5,opt,name=Type,proto3" json:"Type" form:"Type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocRoomReq) Reset()         { *m = AllocRoomReq{} }
func (m *AllocRoomReq) String() string { return proto.CompactTextString(m) }
func (*AllocRoomReq) ProtoMessage()    {}
func (*AllocRoomReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *AllocRoomReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocRoomReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocRoomReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocRoomReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocRoomReq.Merge(m, src)
}
func (m *AllocRoomReq) XXX_Size() int {
	return m.Size()
}
func (m *AllocRoomReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocRoomReq.DiscardUnknown(m)
}

var xxx_messageInfo_AllocRoomReq proto.InternalMessageInfo

type AllocRoomRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	RoomID               string   `protobuf:"bytes,3,opt,name=RoomID,proto3" json:"RoomID"`
	Address              string   `protobuf:"bytes,4,opt,name=Address,proto3" json:"Address"`
	MaxTableNum          int32    `protobuf:"varint,5,opt,name=MaxTableNum,proto3" json:"MaxTableNum" form:"MaxTableNum" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocRoomRsp) Reset()         { *m = AllocRoomRsp{} }
func (m *AllocRoomRsp) String() string { return proto.CompactTextString(m) }
func (*AllocRoomRsp) ProtoMessage()    {}
func (*AllocRoomRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *AllocRoomRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocRoomRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocRoomRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocRoomRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocRoomRsp.Merge(m, src)
}
func (m *AllocRoomRsp) XXX_Size() int {
	return m.Size()
}
func (m *AllocRoomRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocRoomRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AllocRoomRsp proto.InternalMessageInfo

//游戏逻辑服上报更新房间人数和桌子数
type PushRoomStatusReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID" form:"GroupID" validate:"required"`
	RoomID               string   `protobuf:"bytes,3,opt,name=RoomID,proto3" json:"RoomID" form:"RoomID" validate:"required"`
	Count                int32    `protobuf:"varint,4,opt,name=Count,proto3" json:"Count" form:"Count"`
	Total                int32    `protobuf:"varint,5,opt,name=Total,proto3" json:"Total" form:"Total" validate:"required"`
	TableNum             int32    `protobuf:"varint,6,opt,name=TableNum,proto3" json:"TableNum" form:"TableNum"`
	TableID              int32    `protobuf:"varint,7,opt,name=TableID,proto3" json:"TableID" form:"TableID"`
	TableUserNum         int32    `protobuf:"varint,8,opt,name=TableUserNum,proto3" json:"TableUserNum" form:"TableUserNum"`
	TablePwd             bool     `protobuf:"varint,9,opt,name=TablePwd,proto3" json:"TablePwd" form:"TablePwd"`
	TableType            string   `protobuf:"bytes,10,opt,name=TableType,proto3" json:"TableType" form:"TableType"`
	RobotCount           int32    `protobuf:"varint,11,opt,name=RobotCount,proto3" json:"RobotCount" form:"RobotCount"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PushRoomStatusReq) Reset()         { *m = PushRoomStatusReq{} }
func (m *PushRoomStatusReq) String() string { return proto.CompactTextString(m) }
func (*PushRoomStatusReq) ProtoMessage()    {}
func (*PushRoomStatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *PushRoomStatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushRoomStatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushRoomStatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushRoomStatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushRoomStatusReq.Merge(m, src)
}
func (m *PushRoomStatusReq) XXX_Size() int {
	return m.Size()
}
func (m *PushRoomStatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PushRoomStatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_PushRoomStatusReq proto.InternalMessageInfo

type CommonRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonRsp) Reset()         { *m = CommonRsp{} }
func (m *CommonRsp) String() string { return proto.CompactTextString(m) }
func (*CommonRsp) ProtoMessage()    {}
func (*CommonRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *CommonRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonRsp.Merge(m, src)
}
func (m *CommonRsp) XXX_Size() int {
	return m.Size()
}
func (m *CommonRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CommonRsp proto.InternalMessageInfo

//游戏逻辑服上报房间状态
type OnlineStatusReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID" form:"GroupID" validate:"required"`
	RoomID               string   `protobuf:"bytes,3,opt,name=RoomID,proto3" json:"RoomID" form:"RoomID" validate:"required"`
	IsOnLine             bool     `protobuf:"varint,4,opt,name=IsOnLine,proto3" json:"IsOnLine" form:"IsOnLine"`
	Total                int32    `protobuf:"varint,5,opt,name=Total,proto3" json:"Total" form:"Total" validate:"required"`
	Address              string   `protobuf:"bytes,6,opt,name=Address,proto3" json:"Address" form:"Address" validate:"required"`
	Version              int32    `protobuf:"varint,7,opt,name=Version,proto3" json:"Version" form:"Version" validate:"required"`
	MaxTableNum          int32    `protobuf:"varint,8,opt,name=MaxTableNum,proto3" json:"MaxTableNum" form:"MaxTableNum" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnlineStatusReq) Reset()         { *m = OnlineStatusReq{} }
func (m *OnlineStatusReq) String() string { return proto.CompactTextString(m) }
func (*OnlineStatusReq) ProtoMessage()    {}
func (*OnlineStatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *OnlineStatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnlineStatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnlineStatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnlineStatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnlineStatusReq.Merge(m, src)
}
func (m *OnlineStatusReq) XXX_Size() int {
	return m.Size()
}
func (m *OnlineStatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_OnlineStatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_OnlineStatusReq proto.InternalMessageInfo

//心跳
type HeartBeatReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID" form:"GroupID" validate:"required"`
	RoomID               string   `protobuf:"bytes,3,opt,name=RoomID,proto3" json:"RoomID" form:"RoomID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeartBeatReq) Reset()         { *m = HeartBeatReq{} }
func (m *HeartBeatReq) String() string { return proto.CompactTextString(m) }
func (*HeartBeatReq) ProtoMessage()    {}
func (*HeartBeatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *HeartBeatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartBeatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartBeatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartBeatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartBeatReq.Merge(m, src)
}
func (m *HeartBeatReq) XXX_Size() int {
	return m.Size()
}
func (m *HeartBeatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartBeatReq.DiscardUnknown(m)
}

var xxx_messageInfo_HeartBeatReq proto.InternalMessageInfo

// 创建房间，上报号码
type UpdateCustomRoomNum struct {
	GroupID              int32    `protobuf:"varint,1,opt,name=GroupID,proto3" json:"GroupID" form:"GroupID" validate:"required"`
	RoomID               string   `protobuf:"bytes,2,opt,name=RoomID,proto3" json:"RoomID" form:"RoomID" validate:"required"`
	TableID              int32    `protobuf:"varint,3,opt,name=TableID,proto3" json:"TableID" form:"TableID"`
	RoomNum              int32    `protobuf:"varint,4,opt,name=RoomNum,proto3" json:"RoomNum" form:"RoomNum" validate:"required"`
	AddNew               bool     `protobuf:"varint,5,opt,name=AddNew,proto3" json:"AddNew" form:"AddNew"`
	PlayerID             int64    `protobuf:"varint,6,opt,name=PlayerID,proto3" json:"PlayerID" form:"PlayerID"`
	GameID               int32    `protobuf:"varint,7,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateCustomRoomNum) Reset()         { *m = UpdateCustomRoomNum{} }
func (m *UpdateCustomRoomNum) String() string { return proto.CompactTextString(m) }
func (*UpdateCustomRoomNum) ProtoMessage()    {}
func (*UpdateCustomRoomNum) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *UpdateCustomRoomNum) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCustomRoomNum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCustomRoomNum.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCustomRoomNum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCustomRoomNum.Merge(m, src)
}
func (m *UpdateCustomRoomNum) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCustomRoomNum) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCustomRoomNum.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCustomRoomNum proto.InternalMessageInfo

// 根据房号，获取游戏服务地址
type GetCustomRoomAddress struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID" form:"GroupID"`
	RoomNum              int32    `protobuf:"varint,3,opt,name=RoomNum,proto3" json:"RoomNum" form:"RoomNum" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetCustomRoomAddress) Reset()         { *m = GetCustomRoomAddress{} }
func (m *GetCustomRoomAddress) String() string { return proto.CompactTextString(m) }
func (*GetCustomRoomAddress) ProtoMessage()    {}
func (*GetCustomRoomAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *GetCustomRoomAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCustomRoomAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCustomRoomAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCustomRoomAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCustomRoomAddress.Merge(m, src)
}
func (m *GetCustomRoomAddress) XXX_Size() int {
	return m.Size()
}
func (m *GetCustomRoomAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCustomRoomAddress.DiscardUnknown(m)
}

var xxx_messageInfo_GetCustomRoomAddress proto.InternalMessageInfo

type GetCustomRoomAddressResp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	Address              string   `protobuf:"bytes,3,opt,name=Address,proto3" json:"Address"`
	TableID              int32    `protobuf:"varint,4,opt,name=TableID,proto3" json:"TableID"`
	GameID               int32    `protobuf:"varint,5,opt,name=GameID,proto3" json:"GameID"`
	ArenaID              int32    `protobuf:"varint,6,opt,name=ArenaID,proto3" json:"ArenaID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetCustomRoomAddressResp) Reset()         { *m = GetCustomRoomAddressResp{} }
func (m *GetCustomRoomAddressResp) String() string { return proto.CompactTextString(m) }
func (*GetCustomRoomAddressResp) ProtoMessage()    {}
func (*GetCustomRoomAddressResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *GetCustomRoomAddressResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCustomRoomAddressResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCustomRoomAddressResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCustomRoomAddressResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCustomRoomAddressResp.Merge(m, src)
}
func (m *GetCustomRoomAddressResp) XXX_Size() int {
	return m.Size()
}
func (m *GetCustomRoomAddressResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCustomRoomAddressResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetCustomRoomAddressResp proto.InternalMessageInfo

type MultiPlayerAllocRoomReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID" form:"GroupID" validate:"required"`
	UserList             []int64  `protobuf:"varint,3,rep,packed,name=UserList,proto3" json:"UserList" form:"UserList" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MultiPlayerAllocRoomReq) Reset()         { *m = MultiPlayerAllocRoomReq{} }
func (m *MultiPlayerAllocRoomReq) String() string { return proto.CompactTextString(m) }
func (*MultiPlayerAllocRoomReq) ProtoMessage()    {}
func (*MultiPlayerAllocRoomReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *MultiPlayerAllocRoomReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiPlayerAllocRoomReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiPlayerAllocRoomReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiPlayerAllocRoomReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiPlayerAllocRoomReq.Merge(m, src)
}
func (m *MultiPlayerAllocRoomReq) XXX_Size() int {
	return m.Size()
}
func (m *MultiPlayerAllocRoomReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiPlayerAllocRoomReq.DiscardUnknown(m)
}

var xxx_messageInfo_MultiPlayerAllocRoomReq proto.InternalMessageInfo

type QueryArenaReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryArenaReq) Reset()         { *m = QueryArenaReq{} }
func (m *QueryArenaReq) String() string { return proto.CompactTextString(m) }
func (*QueryArenaReq) ProtoMessage()    {}
func (*QueryArenaReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *QueryArenaReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryArenaReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryArenaReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryArenaReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryArenaReq.Merge(m, src)
}
func (m *QueryArenaReq) XXX_Size() int {
	return m.Size()
}
func (m *QueryArenaReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryArenaReq.DiscardUnknown(m)
}

var xxx_messageInfo_QueryArenaReq proto.InternalMessageInfo

type ArenaInfo struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID"`
	MinMoney             int64    `protobuf:"varint,3,opt,name=MinMoney,proto3" json:"MinMoney"`
	MaxMoney             int64    `protobuf:"varint,4,opt,name=MaxMoney,proto3" json:"MaxMoney"`
	Expand               string   `protobuf:"bytes,5,opt,name=Expand,proto3" json:"Expand"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArenaInfo) Reset()         { *m = ArenaInfo{} }
func (m *ArenaInfo) String() string { return proto.CompactTextString(m) }
func (*ArenaInfo) ProtoMessage()    {}
func (*ArenaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *ArenaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArenaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArenaInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArenaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArenaInfo.Merge(m, src)
}
func (m *ArenaInfo) XXX_Size() int {
	return m.Size()
}
func (m *ArenaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ArenaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ArenaInfo proto.InternalMessageInfo

type QueryArenaRsp struct {
	ArenaList            []*ArenaInfo `protobuf:"bytes,1,rep,name=ArenaList,proto3" json:"ArenaList"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *QueryArenaRsp) Reset()         { *m = QueryArenaRsp{} }
func (m *QueryArenaRsp) String() string { return proto.CompactTextString(m) }
func (*QueryArenaRsp) ProtoMessage()    {}
func (*QueryArenaRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *QueryArenaRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryArenaRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryArenaRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryArenaRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryArenaRsp.Merge(m, src)
}
func (m *QueryArenaRsp) XXX_Size() int {
	return m.Size()
}
func (m *QueryArenaRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryArenaRsp.DiscardUnknown(m)
}

var xxx_messageInfo_QueryArenaRsp proto.InternalMessageInfo

type QueryRoomListReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID" form:"GroupID" validate:"required"`
	RoomID               string   `protobuf:"bytes,3,opt,name=RoomID,proto3" json:"RoomID" form:"RoomID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryRoomListReq) Reset()         { *m = QueryRoomListReq{} }
func (m *QueryRoomListReq) String() string { return proto.CompactTextString(m) }
func (*QueryRoomListReq) ProtoMessage()    {}
func (*QueryRoomListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *QueryRoomListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRoomListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRoomListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRoomListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRoomListReq.Merge(m, src)
}
func (m *QueryRoomListReq) XXX_Size() int {
	return m.Size()
}
func (m *QueryRoomListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRoomListReq.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRoomListReq proto.InternalMessageInfo

type TableInfo struct {
	TableID              int32    `protobuf:"varint,1,opt,name=TableID,proto3" json:"TableID"`
	UserNum              int32    `protobuf:"varint,2,opt,name=UserNum,proto3" json:"UserNum"`
	TablePwd             bool     `protobuf:"varint,3,opt,name=TablePwd,proto3" json:"TablePwd"`
	TableType            string   `protobuf:"bytes,4,opt,name=TableType,proto3" json:"TableType"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableInfo) Reset()         { *m = TableInfo{} }
func (m *TableInfo) String() string { return proto.CompactTextString(m) }
func (*TableInfo) ProtoMessage()    {}
func (*TableInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *TableInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableInfo.Merge(m, src)
}
func (m *TableInfo) XXX_Size() int {
	return m.Size()
}
func (m *TableInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TableInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TableInfo proto.InternalMessageInfo

type RoomInfo struct {
	RoomID               string       `protobuf:"bytes,1,opt,name=RoomID,proto3" json:"RoomID"`
	UserNum              int32        `protobuf:"varint,2,opt,name=UserNum,proto3" json:"UserNum"`
	UserTotal            int32        `protobuf:"varint,3,opt,name=UserTotal,proto3" json:"UserTotal"`
	Address              string       `protobuf:"bytes,4,opt,name=Address,proto3" json:"Address"`
	TableList            []*TableInfo `protobuf:"bytes,5,rep,name=TableList,proto3" json:"TableList"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RoomInfo) Reset()         { *m = RoomInfo{} }
func (m *RoomInfo) String() string { return proto.CompactTextString(m) }
func (*RoomInfo) ProtoMessage()    {}
func (*RoomInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *RoomInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoomInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomInfo.Merge(m, src)
}
func (m *RoomInfo) XXX_Size() int {
	return m.Size()
}
func (m *RoomInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RoomInfo proto.InternalMessageInfo

type QueryRoomListRsp struct {
	Code                 int32       `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string      `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	RoomList             []*RoomInfo `protobuf:"bytes,5,rep,name=RoomList,proto3" json:"RoomList"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *QueryRoomListRsp) Reset()         { *m = QueryRoomListRsp{} }
func (m *QueryRoomListRsp) String() string { return proto.CompactTextString(m) }
func (*QueryRoomListRsp) ProtoMessage()    {}
func (*QueryRoomListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *QueryRoomListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRoomListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRoomListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRoomListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRoomListRsp.Merge(m, src)
}
func (m *QueryRoomListRsp) XXX_Size() int {
	return m.Size()
}
func (m *QueryRoomListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRoomListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRoomListRsp proto.InternalMessageInfo

type QueryArenaNewVersionReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryArenaNewVersionReq) Reset()         { *m = QueryArenaNewVersionReq{} }
func (m *QueryArenaNewVersionReq) String() string { return proto.CompactTextString(m) }
func (*QueryArenaNewVersionReq) ProtoMessage()    {}
func (*QueryArenaNewVersionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *QueryArenaNewVersionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryArenaNewVersionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryArenaNewVersionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryArenaNewVersionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryArenaNewVersionReq.Merge(m, src)
}
func (m *QueryArenaNewVersionReq) XXX_Size() int {
	return m.Size()
}
func (m *QueryArenaNewVersionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryArenaNewVersionReq.DiscardUnknown(m)
}

var xxx_messageInfo_QueryArenaNewVersionReq proto.InternalMessageInfo

type ArenaVerInfo struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID"`
	Version              int32    `protobuf:"varint,3,opt,name=Version,proto3" json:"Version"`
	Switch               int32    `protobuf:"varint,4,opt,name=Switch,proto3" json:"Switch"`
	RoomIDs              []int32  `protobuf:"varint,5,rep,packed,name=RoomIDs,proto3" json:"RoomIDs"`
	LastVersion          int32    `protobuf:"varint,6,opt,name=LastVersion,proto3" json:"LastVersion"`
	LastRoomIDs          []int32  `protobuf:"varint,7,rep,packed,name=LastRoomIDs,proto3" json:"LastRoomIDs"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArenaVerInfo) Reset()         { *m = ArenaVerInfo{} }
func (m *ArenaVerInfo) String() string { return proto.CompactTextString(m) }
func (*ArenaVerInfo) ProtoMessage()    {}
func (*ArenaVerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{18}
}
func (m *ArenaVerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArenaVerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArenaVerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArenaVerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArenaVerInfo.Merge(m, src)
}
func (m *ArenaVerInfo) XXX_Size() int {
	return m.Size()
}
func (m *ArenaVerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ArenaVerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ArenaVerInfo proto.InternalMessageInfo

type QueryArenaNewVersionRsp struct {
	Code                 int32           `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string          `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	ArenaList            []*ArenaVerInfo `protobuf:"bytes,3,rep,name=ArenaList,proto3" json:"ArenaList"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *QueryArenaNewVersionRsp) Reset()         { *m = QueryArenaNewVersionRsp{} }
func (m *QueryArenaNewVersionRsp) String() string { return proto.CompactTextString(m) }
func (*QueryArenaNewVersionRsp) ProtoMessage()    {}
func (*QueryArenaNewVersionRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{19}
}
func (m *QueryArenaNewVersionRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryArenaNewVersionRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryArenaNewVersionRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryArenaNewVersionRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryArenaNewVersionRsp.Merge(m, src)
}
func (m *QueryArenaNewVersionRsp) XXX_Size() int {
	return m.Size()
}
func (m *QueryArenaNewVersionRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryArenaNewVersionRsp.DiscardUnknown(m)
}

var xxx_messageInfo_QueryArenaNewVersionRsp proto.InternalMessageInfo

type UpdateArenaNewVersionReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID" form:"GroupID" validate:"required"`
	Version              int32    `protobuf:"varint,3,opt,name=Version,proto3" json:"Version" form:"Version" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateArenaNewVersionReq) Reset()         { *m = UpdateArenaNewVersionReq{} }
func (m *UpdateArenaNewVersionReq) String() string { return proto.CompactTextString(m) }
func (*UpdateArenaNewVersionReq) ProtoMessage()    {}
func (*UpdateArenaNewVersionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{20}
}
func (m *UpdateArenaNewVersionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateArenaNewVersionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateArenaNewVersionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateArenaNewVersionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateArenaNewVersionReq.Merge(m, src)
}
func (m *UpdateArenaNewVersionReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateArenaNewVersionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateArenaNewVersionReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateArenaNewVersionReq proto.InternalMessageInfo

type UpdateArenaNewVersionRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateArenaNewVersionRsp) Reset()         { *m = UpdateArenaNewVersionRsp{} }
func (m *UpdateArenaNewVersionRsp) String() string { return proto.CompactTextString(m) }
func (*UpdateArenaNewVersionRsp) ProtoMessage()    {}
func (*UpdateArenaNewVersionRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{21}
}
func (m *UpdateArenaNewVersionRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateArenaNewVersionRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateArenaNewVersionRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateArenaNewVersionRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateArenaNewVersionRsp.Merge(m, src)
}
func (m *UpdateArenaNewVersionRsp) XXX_Size() int {
	return m.Size()
}
func (m *UpdateArenaNewVersionRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateArenaNewVersionRsp.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateArenaNewVersionRsp proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("roomcenter.service.v1.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterType((*AllocRoomReq)(nil), "roomcenter.service.v1.AllocRoomReq")
	proto.RegisterType((*AllocRoomRsp)(nil), "roomcenter.service.v1.AllocRoomRsp")
	proto.RegisterType((*PushRoomStatusReq)(nil), "roomcenter.service.v1.PushRoomStatusReq")
	proto.RegisterType((*CommonRsp)(nil), "roomcenter.service.v1.CommonRsp")
	proto.RegisterType((*OnlineStatusReq)(nil), "roomcenter.service.v1.OnlineStatusReq")
	proto.RegisterType((*HeartBeatReq)(nil), "roomcenter.service.v1.HeartBeatReq")
	proto.RegisterType((*UpdateCustomRoomNum)(nil), "roomcenter.service.v1.UpdateCustomRoomNum")
	proto.RegisterType((*GetCustomRoomAddress)(nil), "roomcenter.service.v1.GetCustomRoomAddress")
	proto.RegisterType((*GetCustomRoomAddressResp)(nil), "roomcenter.service.v1.GetCustomRoomAddressResp")
	proto.RegisterType((*MultiPlayerAllocRoomReq)(nil), "roomcenter.service.v1.MultiPlayerAllocRoomReq")
	proto.RegisterType((*QueryArenaReq)(nil), "roomcenter.service.v1.QueryArenaReq")
	proto.RegisterType((*ArenaInfo)(nil), "roomcenter.service.v1.ArenaInfo")
	proto.RegisterType((*QueryArenaRsp)(nil), "roomcenter.service.v1.QueryArenaRsp")
	proto.RegisterType((*QueryRoomListReq)(nil), "roomcenter.service.v1.QueryRoomListReq")
	proto.RegisterType((*TableInfo)(nil), "roomcenter.service.v1.TableInfo")
	proto.RegisterType((*RoomInfo)(nil), "roomcenter.service.v1.RoomInfo")
	proto.RegisterType((*QueryRoomListRsp)(nil), "roomcenter.service.v1.QueryRoomListRsp")
	proto.RegisterType((*QueryArenaNewVersionReq)(nil), "roomcenter.service.v1.QueryArenaNewVersionReq")
	proto.RegisterType((*ArenaVerInfo)(nil), "roomcenter.service.v1.ArenaVerInfo")
	proto.RegisterType((*QueryArenaNewVersionRsp)(nil), "roomcenter.service.v1.QueryArenaNewVersionRsp")
	proto.RegisterType((*UpdateArenaNewVersionReq)(nil), "roomcenter.service.v1.UpdateArenaNewVersionReq")
	proto.RegisterType((*UpdateArenaNewVersionRsp)(nil), "roomcenter.service.v1.UpdateArenaNewVersionRsp")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 1811 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x59, 0xcb, 0x6f, 0xdb, 0x46,
	0x1a, 0xcf, 0x58, 0xb6, 0x1e, 0x23, 0xbf, 0xc2, 0xd8, 0xb1, 0x22, 0x3f, 0x28, 0x8f, 0xe3, 0x44,
	0x1b, 0x23, 0x16, 0x1c, 0x1f, 0x02, 0x24, 0x58, 0x2c, 0x22, 0xd9, 0x70, 0x0c, 0xc7, 0xb6, 0x96,
	0x4e, 0x82, 0xc5, 0x1e, 0x76, 0x41, 0x5b, 0x13, 0x87, 0x80, 0x44, 0x2a, 0x24, 0x15, 0xd9, 0xb7,
	0x20, 0xd8, 0x6b, 0x16, 0x0b, 0x2c, 0x0a, 0x14, 0xe8, 0x25, 0x0d, 0xfa, 0x07, 0xb4, 0xff, 0x45,
	0x4e, 0x45, 0x8b, 0x02, 0xbd, 0x95, 0x68, 0xd3, 0x1e, 0x0a, 0xa1, 0xed, 0x41, 0xa7, 0x5e, 0x0a,
	0x14, 0xf3, 0x20, 0x39, 0x94, 0x49, 0x55, 0x8e, 0x55, 0x20, 0x68, 0x2f, 0xd6, 0xcc, 0x6f, 0x66,
	0xbe, 0xf7, 0xf7, 0xcd, 0x37, 0x34, 0x4c, 0xa9, 0x75, 0x6d, 0xb9, 0x6e, 0x1a, 0xb6, 0x21, 0x4d,
	0x9a, 0x86, 0x51, 0x3b, 0xc0, 0xba, 0x8d, 0xcd, 0x65, 0x0b, 0x9b, 0x4f, 0xb5, 0x03, 0xbc, 0xfc,
	0x74, 0x25, 0x7b, 0xfd, 0x50, 0xb3, 0x1f, 0x37, 0xf6, 0x97, 0x0f, 0x8c, 0x5a, 0xe1, 0xd0, 0x38,
	0x34, 0x0a, 0x74, 0xf7, 0x7e, 0xe3, 0x11, 0x9d, 0xd1, 0x09, 0x1d, 0x31, 0x2a, 0xd9, 0x99, 0x43,
	0xc3, 0x38, 0xac, 0xe2, 0x82, 0x5a, 0xd7, 0x0a, 0xaa, 0xae, 0x1b, 0xb6, 0x6a, 0x6b, 0x86, 0x6e,
	0xb1, 0x55, 0xf4, 0xdf, 0x01, 0x38, 0x7c, 0xa7, 0x5a, 0x35, 0x0e, 0x14, 0xc3, 0xa8, 0x29, 0xf8,
	0x89, 0x74, 0x1b, 0x26, 0xcb, 0x55, 0xf5, 0x18, 0x9b, 0x9b, 0x6b, 0x19, 0x90, 0x03, 0xf9, 0x58,
	0x51, 0x6e, 0x39, 0xb2, 0x87, 0xb5, 0x1d, 0x79, 0xec, 0x91, 0x61, 0xd6, 0x6e, 0x21, 0x17, 0x41,
	0x8a, 0xb7, 0x28, 0x6d, 0xc0, 0xf8, 0x86, 0x5a, 0xc3, 0x9b, 0x6b, 0x99, 0x58, 0x0e, 0xe4, 0x87,
	0x8a, 0x85, 0x96, 0x23, 0x73, 0xa4, 0xed, 0xc8, 0xf3, 0xec, 0x20, 0x9b, 0xa3, 0xdc, 0x53, 0xb5,
	0xaa, 0x55, 0x54, 0x1b, 0xdf, 0x42, 0x26, 0x7e, 0xd2, 0xd0, 0x4c, 0x5c, 0x41, 0x0a, 0xdf, 0x2c,
	0x6d, 0xc1, 0xc4, 0x86, 0x69, 0x34, 0xea, 0x9b, 0x6b, 0x99, 0x41, 0x4a, 0x69, 0xa5, 0xe5, 0xc8,
	0x2e, 0xd4, 0x76, 0x64, 0xc4, 0x49, 0x31, 0x20, 0x9c, 0x96, 0xbb, 0x5d, 0x5a, 0x82, 0x83, 0xf7,
	0x8f, 0xeb, 0x38, 0x33, 0x44, 0x29, 0x4d, 0xb5, 0x1c, 0x99, 0xce, 0xdb, 0x8e, 0x9c, 0x66, 0x64,
	0xc8, 0x0c, 0x29, 0x14, 0x44, 0xdf, 0x03, 0xd1, 0x20, 0x56, 0x5d, 0x9a, 0x81, 0x83, 0x25, 0xa3,
	0x82, 0xa9, 0x31, 0x86, 0x8a, 0x49, 0x72, 0x9a, 0xcc, 0x15, 0xfa, 0x57, 0x5a, 0x84, 0x89, 0x6d,
	0x6c, 0x59, 0xea, 0x21, 0xce, 0x0c, 0xe4, 0x40, 0x3e, 0x55, 0x4c, 0x13, 0x41, 0x39, 0xa4, 0xb8,
	0x03, 0x09, 0xc1, 0x38, 0xa1, 0xc7, 0x0d, 0x93, 0x2a, 0x42, 0x62, 0x18, 0x86, 0x28, 0xfc, 0x97,
	0x90, 0xba, 0x53, 0xa9, 0x98, 0xd8, 0xb2, 0xa8, 0xce, 0x9c, 0x14, 0x87, 0x14, 0x77, 0x20, 0xdd,
	0x85, 0xe9, 0x6d, 0xf5, 0xe8, 0xbe, 0xba, 0x5f, 0xc5, 0x3b, 0x8d, 0x1a, 0x57, 0xea, 0x4a, 0xcb,
	0x91, 0x45, 0xb8, 0xed, 0xc8, 0x17, 0x98, 0x6e, 0x02, 0x88, 0x72, 0x8a, 0xb8, 0x07, 0xfd, 0x34,
	0x04, 0xcf, 0x97, 0x1b, 0xd6, 0x63, 0xc2, 0x7f, 0xcf, 0x56, 0xed, 0x86, 0x45, 0x02, 0xc0, 0xf7,
	0x21, 0xe8, 0x9b, 0x0f, 0x07, 0xce, 0xec, 0xc3, 0x8d, 0x0e, 0x03, 0x16, 0x7c, 0x03, 0xfa, 0x52,
	0xb1, 0x79, 0x84, 0x54, 0xdc, 0xca, 0x05, 0x38, 0x54, 0x32, 0x1a, 0xba, 0xcd, 0xe3, 0xea, 0x52,
	0xcb, 0x91, 0x19, 0xd0, 0x76, 0xe4, 0x61, 0x46, 0x86, 0x4e, 0x91, 0xc2, 0x60, 0xa9, 0x04, 0x87,
	0xee, 0x1b, 0xb6, 0x5a, 0xe5, 0x96, 0xbe, 0x4e, 0x0e, 0x50, 0xa0, 0xed, 0xc8, 0x39, 0x1e, 0x3f,
	0x64, 0x1a, 0xce, 0x96, 0x6d, 0x25, 0x59, 0xe5, 0x79, 0x2c, 0x4e, 0xe9, 0xd0, 0xac, 0x12, 0xdc,
	0xc5, 0xb3, 0xca, 0x73, 0x8e, 0xe2, 0x2d, 0x4a, 0x37, 0x61, 0x82, 0x8e, 0x37, 0xd7, 0x32, 0x09,
	0x7a, 0x76, 0x96, 0x18, 0x92, 0x43, 0x6d, 0x47, 0x1e, 0x15, 0x8e, 0x92, 0x7c, 0x74, 0x97, 0xa4,
	0x2d, 0x38, 0x4c, 0x87, 0x0f, 0x2c, 0x6c, 0x12, 0xce, 0x49, 0x7a, 0xfa, 0x6a, 0xcb, 0x91, 0x03,
	0xb8, 0x1f, 0x2c, 0x22, 0x8a, 0x94, 0xc0, 0x26, 0x4f, 0x85, 0x72, 0xb3, 0x92, 0x49, 0xe5, 0x40,
	0x3e, 0x29, 0xa8, 0x50, 0x6e, 0x56, 0x3a, 0x54, 0x28, 0x37, 0x2b, 0xae, 0x0a, 0xe5, 0x66, 0x45,
	0xfa, 0x1b, 0x4c, 0xd1, 0x31, 0xcd, 0x43, 0x48, 0x3d, 0x38, 0xdf, 0x72, 0x64, 0x1f, 0x6c, 0x3b,
	0xf2, 0xb8, 0x70, 0x9c, 0x65, 0xa4, 0xbf, 0x2c, 0x95, 0x20, 0x54, 0x8c, 0x7d, 0xc3, 0x66, 0xbe,
	0x4b, 0x53, 0x45, 0x16, 0x5a, 0x8e, 0x2c, 0xa0, 0x6d, 0x47, 0x3e, 0xef, 0xc6, 0x81, 0x8b, 0x21,
	0x45, 0xd8, 0x80, 0xca, 0x30, 0x55, 0x32, 0x6a, 0x35, 0x43, 0xef, 0x57, 0x5e, 0xa3, 0x2f, 0x07,
	0xe1, 0xd8, 0xae, 0x5e, 0xd5, 0x74, 0xfc, 0xa7, 0x49, 0xa0, 0xdb, 0x30, 0xb9, 0x69, 0xed, 0xea,
	0xf7, 0x34, 0x1d, 0xd3, 0x1c, 0xe2, 0x71, 0xe0, 0x62, 0x7e, 0x1c, 0xb8, 0x08, 0x52, 0xbc, 0xc5,
	0xfe, 0x24, 0xd3, 0x96, 0x5f, 0x28, 0xe3, 0x54, 0x97, 0x15, 0xa1, 0x50, 0xfa, 0x76, 0xe1, 0x40,
	0x84, 0x5d, 0xdc, 0x72, 0xba, 0x05, 0x13, 0x0f, 0xb1, 0x69, 0x69, 0x86, 0xce, 0x93, 0x8b, 0x12,
	0xe3, 0x90, 0x4f, 0x8c, 0x03, 0x11, 0xc4, 0xf8, 0x6a, 0x67, 0x6d, 0x4e, 0xbe, 0x7d, 0x6d, 0xfe,
	0x11, 0xc0, 0xe1, 0xbb, 0x58, 0x35, 0xed, 0x22, 0x56, 0xed, 0x3f, 0x7e, 0x54, 0xa1, 0x1f, 0x62,
	0xf0, 0xc2, 0x83, 0x3a, 0x59, 0x2d, 0x35, 0x2c, 0xdb, 0xa8, 0x11, 0x98, 0x54, 0x1d, 0x41, 0x5a,
	0xd0, 0x47, 0x69, 0x07, 0xce, 0x96, 0x03, 0x42, 0x45, 0x8e, 0x9d, 0xb2, 0x22, 0x27, 0xb8, 0x66,
	0x62, 0x5f, 0xc3, 0x21, 0x5f, 0x1d, 0x0e, 0x44, 0xa8, 0xe3, 0xda, 0x66, 0x15, 0xc6, 0xef, 0x54,
	0x2a, 0x3b, 0xb8, 0x49, 0xb3, 0x29, 0x59, 0x9c, 0x26, 0xea, 0x30, 0xa4, 0xed, 0xc8, 0x23, 0x5e,
	0x16, 0xec, 0xe0, 0x26, 0x52, 0xf8, 0x42, 0xa0, 0xbf, 0x8b, 0xbf, 0x7d, 0x7f, 0x97, 0x38, 0x53,
	0x10, 0xa2, 0xcf, 0x01, 0x9c, 0xd8, 0xc0, 0xb6, 0xef, 0x6b, 0x37, 0x1d, 0x57, 0x3b, 0xc2, 0x7c,
	0x3a, 0xc0, 0x61, 0x24, 0xc0, 0xc1, 0x0b, 0xe9, 0x9b, 0x9d, 0x21, 0x3d, 0x1b, 0x0c, 0x92, 0xd1,
	0x60, 0x90, 0xf8, 0x01, 0x21, 0xb8, 0x23, 0x76, 0x56, 0x77, 0xa0, 0x9f, 0x01, 0xcc, 0x84, 0xe9,
	0xa4, 0xe0, 0x7e, 0x75, 0x91, 0x42, 0x87, 0x18, 0xeb, 0xd2, 0x21, 0x2e, 0xfa, 0xd1, 0xc9, 0x82,
	0x2c, 0x2d, 0x44, 0xa7, 0x1f, 0x8b, 0xc8, 0x33, 0x35, 0x2b, 0xc6, 0xd0, 0x37, 0xb5, 0x67, 0x59,
	0xc2, 0xd1, 0xc4, 0xba, 0xca, 0x83, 0x85, 0x93, 0xe2, 0x90, 0xe2, 0x0e, 0xd0, 0xb3, 0x01, 0x38,
	0xb5, 0xdd, 0xa8, 0xda, 0x1a, 0x8b, 0x94, 0xc0, 0x83, 0xe2, 0xdd, 0x2c, 0x5c, 0xbb, 0x30, 0x49,
	0x1a, 0x9b, 0x7b, 0x9a, 0x65, 0x67, 0x62, 0xb9, 0x58, 0x3e, 0x56, 0x5c, 0x25, 0x69, 0xe0, 0x62,
	0x6d, 0x47, 0x5e, 0x60, 0xe4, 0x5c, 0x24, 0x9c, 0x9e, 0x77, 0x00, 0xfd, 0x03, 0x8e, 0xfc, 0xbd,
	0x81, 0xcd, 0x63, 0x6a, 0x92, 0x7e, 0xea, 0x8d, 0x3e, 0x05, 0x30, 0xc5, 0x0c, 0xad, 0x3f, 0x32,
	0x04, 0xaf, 0x81, 0x6e, 0x5e, 0x0b, 0x5a, 0x2a, 0x2d, 0x58, 0xca, 0xb7, 0x41, 0x1e, 0x26, 0xb7,
	0x35, 0x7d, 0xdb, 0xd0, 0xf1, 0x31, 0x8d, 0xa7, 0x58, 0x71, 0x98, 0xd8, 0xc0, 0xc5, 0x14, 0x6f,
	0x44, 0x77, 0xaa, 0x47, 0x6c, 0xe7, 0xa0, 0xb0, 0x93, 0x63, 0x8a, 0x37, 0x22, 0xe2, 0xad, 0x1f,
	0xd5, 0x55, 0xbd, 0x42, 0x83, 0x8a, 0x3f, 0x74, 0x18, 0xa2, 0xf0, 0x5f, 0xf4, 0xaf, 0x80, 0xa9,
	0xac, 0xba, 0xb4, 0xcd, 0x15, 0xa4, 0xde, 0x00, 0xb9, 0x58, 0x3e, 0x7d, 0x23, 0xb7, 0x1c, 0xfa,
	0xf8, 0x5d, 0xf6, 0x0c, 0x51, 0x1c, 0x21, 0xfd, 0xa3, 0x77, 0x4c, 0xf1, 0x87, 0xe8, 0x2b, 0x00,
	0xc7, 0x29, 0x03, 0x12, 0x82, 0x74, 0xf1, 0x9d, 0x0d, 0xc3, 0xd5, 0x8e, 0xfb, 0x73, 0x3a, 0x70,
	0x23, 0x8d, 0x04, 0x6e, 0x24, 0xef, 0xae, 0xfc, 0x18, 0xf0, 0x6e, 0x9a, 0x06, 0x84, 0x90, 0xed,
	0xa0, 0x4b, 0xb6, 0x2f, 0xc2, 0x84, 0xfb, 0x0c, 0x10, 0x62, 0x82, 0x43, 0x8a, 0x3b, 0x20, 0x9e,
	0xf6, 0xba, 0xfc, 0x18, 0xbd, 0x55, 0x86, 0xc5, 0x2e, 0x5f, 0x68, 0xe9, 0x97, 0xc4, 0x96, 0x9e,
	0x3d, 0x58, 0x47, 0x02, 0x2d, 0xbd, 0xd0, 0xbe, 0x93, 0xda, 0x98, 0xa4, 0xd2, 0xf3, 0x10, 0xe6,
	0x4a, 0x83, 0x6e, 0x8f, 0xe1, 0x5e, 0xc4, 0x5d, 0x82, 0x29, 0x32, 0x64, 0x3d, 0x25, 0x2b, 0xe1,
	0x54, 0x08, 0x0f, 0x54, 0xfc, 0x61, 0xaf, 0x0f, 0xec, 0x6d, 0xae, 0x18, 0x8d, 0xc6, 0xa1, 0xae,
	0xd1, 0xe8, 0x79, 0x41, 0x50, 0x9d, 0x45, 0xa3, 0x37, 0x44, 0xaf, 0x4e, 0x44, 0x63, 0xbf, 0xae,
	0x83, 0x4d, 0x66, 0x53, 0x41, 0x4e, 0x39, 0x42, 0x4e, 0xd7, 0xf4, 0xcc, 0x99, 0x9e, 0x20, 0xde,
	0x08, 0xed, 0xc3, 0x29, 0x3f, 0x25, 0x77, 0x70, 0x93, 0x37, 0xb4, 0x7d, 0xad, 0x63, 0x9f, 0x0c,
	0xc0, 0x61, 0x4a, 0xff, 0x21, 0x36, 0xfb, 0x5d, 0xca, 0x16, 0xfd, 0x2e, 0x3e, 0xe6, 0x6f, 0x73,
	0xb5, 0xf0, 0xfa, 0x73, 0x04, 0xe3, 0x7b, 0x4d, 0xcd, 0x3e, 0x78, 0xcc, 0x2f, 0x46, 0xca, 0x91,
	0x21, 0x0a, 0xff, 0x25, 0xa4, 0x58, 0x0c, 0x5a, 0xd4, 0xa8, 0x9c, 0x14, 0x87, 0x14, 0x77, 0x20,
	0xad, 0xc0, 0xf4, 0x3d, 0xd5, 0xb2, 0x5d, 0xae, 0xec, 0x76, 0x1c, 0x23, 0xad, 0xbe, 0x00, 0x2b,
	0xe2, 0xc4, 0x3d, 0xe2, 0x52, 0x4f, 0x50, 0xea, 0xde, 0x11, 0x97, 0x83, 0x38, 0x21, 0xa9, 0x1e,
	0xee, 0x98, 0x7e, 0xc5, 0x50, 0x59, 0x2c, 0xbd, 0x31, 0x1a, 0x44, 0x0b, 0xdd, 0x4a, 0x2f, 0xf7,
	0x5d, 0x97, 0xea, 0xfb, 0x0b, 0x80, 0x19, 0xd6, 0xc9, 0xff, 0x8e, 0xc1, 0xd4, 0xdf, 0x2a, 0xbc,
	0xd5, 0x19, 0x3d, 0x67, 0x78, 0x03, 0xa2, 0x7f, 0x47, 0xa9, 0xdf, 0x27, 0x97, 0x5d, 0xfb, 0x2b,
	0x4c, 0xac, 0x9b, 0x26, 0x3d, 0x91, 0x86, 0x89, 0xbd, 0x07, 0xa5, 0xd2, 0xfa, 0xde, 0xde, 0xf8,
	0x39, 0x69, 0x0c, 0xa6, 0xca, 0xaa, 0xa9, 0xd6, 0xac, 0x75, 0xd3, 0x1c, 0x7f, 0xf9, 0x22, 0x2e,
	0x4d, 0xc0, 0x51, 0xef, 0xba, 0x5c, 0xaf, 0xd5, 0xed, 0xe3, 0xf1, 0x0f, 0x5f, 0xc4, 0x6f, 0x7c,
	0x30, 0x02, 0xa1, 0xef, 0x60, 0xc9, 0x86, 0x29, 0xaf, 0x5d, 0x93, 0x22, 0x5d, 0x2f, 0x34, 0x74,
	0xd9, 0xdf, 0xde, 0x64, 0xd5, 0xd1, 0xec, 0xf3, 0x2f, 0xbe, 0xfb, 0xff, 0xc0, 0x14, 0x9a, 0x2c,
	0xf8, 0x9b, 0x0b, 0x3e, 0xa3, 0x67, 0x00, 0x8e, 0x06, 0x3f, 0x3d, 0x4a, 0xf9, 0x08, 0xb2, 0x27,
	0xbe, 0x50, 0x66, 0xa3, 0xaa, 0xb1, 0xf7, 0x6d, 0x07, 0x21, 0xca, 0x7d, 0x06, 0x65, 0x45, 0xee,
	0x1d, 0xfc, 0x9e, 0x03, 0x38, 0x4e, 0x20, 0xf1, 0xf3, 0x8d, 0x74, 0x25, 0x82, 0x74, 0xc7, 0x37,
	0x9e, 0x1e, 0x44, 0xb8, 0x4c, 0x45, 0x98, 0x43, 0x33, 0x9d, 0x22, 0x04, 0xf8, 0x3d, 0x81, 0x29,
	0xef, 0x95, 0x1f, 0x69, 0x7d, 0xf1, 0x3b, 0x40, 0x0f, 0x9c, 0x43, 0x4d, 0xef, 0x73, 0xf9, 0x1f,
	0x80, 0x93, 0xbb, 0x7a, 0xd8, 0x5b, 0xfb, 0x5a, 0x04, 0xe9, 0x90, 0xbd, 0x3d, 0x88, 0xf1, 0x17,
	0x2a, 0xc6, 0x02, 0x9a, 0x17, 0xc5, 0x08, 0x67, 0xfc, 0x0a, 0xc0, 0x8b, 0xbb, 0x7a, 0xe8, 0x7b,
	0x70, 0x29, 0x82, 0x4f, 0xd8, 0xe6, 0x6c, 0xe1, 0x14, 0x9b, 0xc9, 0xab, 0x0c, 0x5d, 0xa3, 0x32,
	0x5e, 0x46, 0x28, 0x28, 0x63, 0xa8, 0x24, 0xef, 0x01, 0x38, 0x11, 0xf6, 0xc6, 0x91, 0x96, 0x23,
	0xb8, 0x46, 0x3c, 0x88, 0x7a, 0xcb, 0x9f, 0x3c, 0x95, 0x0c, 0xa1, 0x9c, 0x28, 0x59, 0x28, 0xfb,
	0x23, 0x08, 0xfd, 0x1b, 0x42, 0xba, 0x1c, 0x41, 0x3c, 0xf0, 0x36, 0xc9, 0xf6, 0xb0, 0xcb, 0xaa,
	0xa3, 0x39, 0x2a, 0x43, 0x06, 0x5d, 0x14, 0x65, 0x10, 0x78, 0x3d, 0x03, 0x70, 0x8c, 0xca, 0xe1,
	0x1b, 0xab, 0x8f, 0x15, 0x64, 0x81, 0x72, 0x9f, 0x45, 0xd3, 0x27, 0x2a, 0x88, 0xc0, 0xee, 0x3f,
	0x80, 0xbf, 0x25, 0xdc, 0x4e, 0x46, 0xba, 0xda, 0x4d, 0x35, 0xe1, 0x41, 0x90, 0xed, 0x6d, 0xa3,
	0x55, 0x47, 0xf3, 0x54, 0x90, 0x69, 0x74, 0xe9, 0x84, 0x19, 0x3c, 0xa6, 0x2f, 0x01, 0x9c, 0x08,
	0xbb, 0xa6, 0x23, 0x63, 0x23, 0xa2, 0xd9, 0xca, 0x9e, 0x6a, 0x7f, 0x54, 0x98, 0x84, 0x4a, 0xf2,
	0x11, 0x80, 0x93, 0xa1, 0xf7, 0x92, 0x54, 0xe8, 0x9a, 0xf6, 0x21, 0x42, 0x9e, 0xee, 0x40, 0x54,
	0x29, 0x08, 0xdd, 0x5d, 0xbc, 0xf4, 0xfa, 0x9b, 0xb9, 0x73, 0xaf, 0xdf, 0xcc, 0x81, 0xcf, 0xde,
	0xcc, 0x81, 0xaf, 0xdf, 0xcc, 0x81, 0xf7, 0xbf, 0x9d, 0x3b, 0xf7, 0xcf, 0x98, 0x5a, 0xd7, 0xf6,
	0xe3, 0xf4, 0x3f, 0x96, 0xab, 0xbf, 0x06, 0x00, 0x00, 0xff, 0xff, 0xcf, 0xdd, 0x9a, 0xfc, 0x22,
	0x1d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RoomcenterClient is the client API for Roomcenter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RoomcenterClient interface {
	//客户端获取进入的游戏房间服务器地址
	AllocRoom(ctx context.Context, in *AllocRoomReq, opts ...grpc.CallOption) (*AllocRoomRsp, error)
	//游戏逻辑服上报更新房间人数
	PushRoomStatus(ctx context.Context, in *PushRoomStatusReq, opts ...grpc.CallOption) (*CommonRsp, error)
	//游戏逻辑服上报房间上下线状态（游戏服，启动和关闭时调用）
	PushOnlineStatus(ctx context.Context, in *OnlineStatusReq, opts ...grpc.CallOption) (*CommonRsp, error)
	//游戏逻辑服上报心跳
	HeartBeat(ctx context.Context, in *HeartBeatReq, opts ...grpc.CallOption) (*CommonRsp, error)
	//上报号码
	OnUpdateCustomRoomNum(ctx context.Context, in *UpdateCustomRoomNum, opts ...grpc.CallOption) (*CommonRsp, error)
	//根据号码，获取游戏服务器地址
	OnGetCustomRoomAddress(ctx context.Context, in *GetCustomRoomAddress, opts ...grpc.CallOption) (*GetCustomRoomAddressResp, error)
	//多人分配一个房间
	MultiPlayerAllocRoom(ctx context.Context, in *MultiPlayerAllocRoomReq, opts ...grpc.CallOption) (*AllocRoomRsp, error)
	//查询场列表
	QueryArena(ctx context.Context, in *QueryArenaReq, opts ...grpc.CallOption) (*QueryArenaRsp, error)
	//根据桌子数分配游戏服
	AllocCustomRoom(ctx context.Context, in *AllocRoomReq, opts ...grpc.CallOption) (*AllocRoomRsp, error)
	//查询房间信息
	QueryRoomList(ctx context.Context, in *QueryRoomListReq, opts ...grpc.CallOption) (*QueryRoomListRsp, error)
	//查询场待更新版本
	QueryArenaNewVersion(ctx context.Context, in *QueryArenaNewVersionReq, opts ...grpc.CallOption) (*QueryArenaNewVersionRsp, error)
	//更新场对外
	UpdateArenaNewVersion(ctx context.Context, in *UpdateArenaNewVersionReq, opts ...grpc.CallOption) (*UpdateArenaNewVersionRsp, error)
}

type roomcenterClient struct {
	cc *grpc.ClientConn
}

func NewRoomcenterClient(cc *grpc.ClientConn) RoomcenterClient {
	return &roomcenterClient{cc}
}

func (c *roomcenterClient) AllocRoom(ctx context.Context, in *AllocRoomReq, opts ...grpc.CallOption) (*AllocRoomRsp, error) {
	out := new(AllocRoomRsp)
	err := c.cc.Invoke(ctx, "/roomcenter.service.v1.roomcenter/AllocRoom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomcenterClient) PushRoomStatus(ctx context.Context, in *PushRoomStatusReq, opts ...grpc.CallOption) (*CommonRsp, error) {
	out := new(CommonRsp)
	err := c.cc.Invoke(ctx, "/roomcenter.service.v1.roomcenter/PushRoomStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomcenterClient) PushOnlineStatus(ctx context.Context, in *OnlineStatusReq, opts ...grpc.CallOption) (*CommonRsp, error) {
	out := new(CommonRsp)
	err := c.cc.Invoke(ctx, "/roomcenter.service.v1.roomcenter/PushOnlineStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomcenterClient) HeartBeat(ctx context.Context, in *HeartBeatReq, opts ...grpc.CallOption) (*CommonRsp, error) {
	out := new(CommonRsp)
	err := c.cc.Invoke(ctx, "/roomcenter.service.v1.roomcenter/HeartBeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomcenterClient) OnUpdateCustomRoomNum(ctx context.Context, in *UpdateCustomRoomNum, opts ...grpc.CallOption) (*CommonRsp, error) {
	out := new(CommonRsp)
	err := c.cc.Invoke(ctx, "/roomcenter.service.v1.roomcenter/OnUpdateCustomRoomNum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomcenterClient) OnGetCustomRoomAddress(ctx context.Context, in *GetCustomRoomAddress, opts ...grpc.CallOption) (*GetCustomRoomAddressResp, error) {
	out := new(GetCustomRoomAddressResp)
	err := c.cc.Invoke(ctx, "/roomcenter.service.v1.roomcenter/OnGetCustomRoomAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomcenterClient) MultiPlayerAllocRoom(ctx context.Context, in *MultiPlayerAllocRoomReq, opts ...grpc.CallOption) (*AllocRoomRsp, error) {
	out := new(AllocRoomRsp)
	err := c.cc.Invoke(ctx, "/roomcenter.service.v1.roomcenter/MultiPlayerAllocRoom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomcenterClient) QueryArena(ctx context.Context, in *QueryArenaReq, opts ...grpc.CallOption) (*QueryArenaRsp, error) {
	out := new(QueryArenaRsp)
	err := c.cc.Invoke(ctx, "/roomcenter.service.v1.roomcenter/QueryArena", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomcenterClient) AllocCustomRoom(ctx context.Context, in *AllocRoomReq, opts ...grpc.CallOption) (*AllocRoomRsp, error) {
	out := new(AllocRoomRsp)
	err := c.cc.Invoke(ctx, "/roomcenter.service.v1.roomcenter/AllocCustomRoom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomcenterClient) QueryRoomList(ctx context.Context, in *QueryRoomListReq, opts ...grpc.CallOption) (*QueryRoomListRsp, error) {
	out := new(QueryRoomListRsp)
	err := c.cc.Invoke(ctx, "/roomcenter.service.v1.roomcenter/QueryRoomList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomcenterClient) QueryArenaNewVersion(ctx context.Context, in *QueryArenaNewVersionReq, opts ...grpc.CallOption) (*QueryArenaNewVersionRsp, error) {
	out := new(QueryArenaNewVersionRsp)
	err := c.cc.Invoke(ctx, "/roomcenter.service.v1.roomcenter/QueryArenaNewVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomcenterClient) UpdateArenaNewVersion(ctx context.Context, in *UpdateArenaNewVersionReq, opts ...grpc.CallOption) (*UpdateArenaNewVersionRsp, error) {
	out := new(UpdateArenaNewVersionRsp)
	err := c.cc.Invoke(ctx, "/roomcenter.service.v1.roomcenter/UpdateArenaNewVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoomcenterServer is the server API for Roomcenter service.
type RoomcenterServer interface {
	//客户端获取进入的游戏房间服务器地址
	AllocRoom(context.Context, *AllocRoomReq) (*AllocRoomRsp, error)
	//游戏逻辑服上报更新房间人数
	PushRoomStatus(context.Context, *PushRoomStatusReq) (*CommonRsp, error)
	//游戏逻辑服上报房间上下线状态（游戏服，启动和关闭时调用）
	PushOnlineStatus(context.Context, *OnlineStatusReq) (*CommonRsp, error)
	//游戏逻辑服上报心跳
	HeartBeat(context.Context, *HeartBeatReq) (*CommonRsp, error)
	//上报号码
	OnUpdateCustomRoomNum(context.Context, *UpdateCustomRoomNum) (*CommonRsp, error)
	//根据号码，获取游戏服务器地址
	OnGetCustomRoomAddress(context.Context, *GetCustomRoomAddress) (*GetCustomRoomAddressResp, error)
	//多人分配一个房间
	MultiPlayerAllocRoom(context.Context, *MultiPlayerAllocRoomReq) (*AllocRoomRsp, error)
	//查询场列表
	QueryArena(context.Context, *QueryArenaReq) (*QueryArenaRsp, error)
	//根据桌子数分配游戏服
	AllocCustomRoom(context.Context, *AllocRoomReq) (*AllocRoomRsp, error)
	//查询房间信息
	QueryRoomList(context.Context, *QueryRoomListReq) (*QueryRoomListRsp, error)
	//查询场待更新版本
	QueryArenaNewVersion(context.Context, *QueryArenaNewVersionReq) (*QueryArenaNewVersionRsp, error)
	//更新场对外
	UpdateArenaNewVersion(context.Context, *UpdateArenaNewVersionReq) (*UpdateArenaNewVersionRsp, error)
}

// UnimplementedRoomcenterServer can be embedded to have forward compatible implementations.
type UnimplementedRoomcenterServer struct {
}

func (*UnimplementedRoomcenterServer) AllocRoom(ctx context.Context, req *AllocRoomReq) (*AllocRoomRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocRoom not implemented")
}
func (*UnimplementedRoomcenterServer) PushRoomStatus(ctx context.Context, req *PushRoomStatusReq) (*CommonRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushRoomStatus not implemented")
}
func (*UnimplementedRoomcenterServer) PushOnlineStatus(ctx context.Context, req *OnlineStatusReq) (*CommonRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushOnlineStatus not implemented")
}
func (*UnimplementedRoomcenterServer) HeartBeat(ctx context.Context, req *HeartBeatReq) (*CommonRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HeartBeat not implemented")
}
func (*UnimplementedRoomcenterServer) OnUpdateCustomRoomNum(ctx context.Context, req *UpdateCustomRoomNum) (*CommonRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnUpdateCustomRoomNum not implemented")
}
func (*UnimplementedRoomcenterServer) OnGetCustomRoomAddress(ctx context.Context, req *GetCustomRoomAddress) (*GetCustomRoomAddressResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnGetCustomRoomAddress not implemented")
}
func (*UnimplementedRoomcenterServer) MultiPlayerAllocRoom(ctx context.Context, req *MultiPlayerAllocRoomReq) (*AllocRoomRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultiPlayerAllocRoom not implemented")
}
func (*UnimplementedRoomcenterServer) QueryArena(ctx context.Context, req *QueryArenaReq) (*QueryArenaRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryArena not implemented")
}
func (*UnimplementedRoomcenterServer) AllocCustomRoom(ctx context.Context, req *AllocRoomReq) (*AllocRoomRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocCustomRoom not implemented")
}
func (*UnimplementedRoomcenterServer) QueryRoomList(ctx context.Context, req *QueryRoomListReq) (*QueryRoomListRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRoomList not implemented")
}
func (*UnimplementedRoomcenterServer) QueryArenaNewVersion(ctx context.Context, req *QueryArenaNewVersionReq) (*QueryArenaNewVersionRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryArenaNewVersion not implemented")
}
func (*UnimplementedRoomcenterServer) UpdateArenaNewVersion(ctx context.Context, req *UpdateArenaNewVersionReq) (*UpdateArenaNewVersionRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateArenaNewVersion not implemented")
}

func RegisterRoomcenterServer(s *grpc.Server, srv RoomcenterServer) {
	s.RegisterService(&_Roomcenter_serviceDesc, srv)
}

func _Roomcenter_AllocRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocRoomReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomcenterServer).AllocRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/roomcenter.service.v1.roomcenter/AllocRoom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomcenterServer).AllocRoom(ctx, req.(*AllocRoomReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Roomcenter_PushRoomStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushRoomStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomcenterServer).PushRoomStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/roomcenter.service.v1.roomcenter/PushRoomStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomcenterServer).PushRoomStatus(ctx, req.(*PushRoomStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Roomcenter_PushOnlineStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnlineStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomcenterServer).PushOnlineStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/roomcenter.service.v1.roomcenter/PushOnlineStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomcenterServer).PushOnlineStatus(ctx, req.(*OnlineStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Roomcenter_HeartBeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartBeatReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomcenterServer).HeartBeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/roomcenter.service.v1.roomcenter/HeartBeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomcenterServer).HeartBeat(ctx, req.(*HeartBeatReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Roomcenter_OnUpdateCustomRoomNum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCustomRoomNum)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomcenterServer).OnUpdateCustomRoomNum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/roomcenter.service.v1.roomcenter/OnUpdateCustomRoomNum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomcenterServer).OnUpdateCustomRoomNum(ctx, req.(*UpdateCustomRoomNum))
	}
	return interceptor(ctx, in, info, handler)
}

func _Roomcenter_OnGetCustomRoomAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCustomRoomAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomcenterServer).OnGetCustomRoomAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/roomcenter.service.v1.roomcenter/OnGetCustomRoomAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomcenterServer).OnGetCustomRoomAddress(ctx, req.(*GetCustomRoomAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Roomcenter_MultiPlayerAllocRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultiPlayerAllocRoomReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomcenterServer).MultiPlayerAllocRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/roomcenter.service.v1.roomcenter/MultiPlayerAllocRoom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomcenterServer).MultiPlayerAllocRoom(ctx, req.(*MultiPlayerAllocRoomReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Roomcenter_QueryArena_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryArenaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomcenterServer).QueryArena(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/roomcenter.service.v1.roomcenter/QueryArena",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomcenterServer).QueryArena(ctx, req.(*QueryArenaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Roomcenter_AllocCustomRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocRoomReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomcenterServer).AllocCustomRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/roomcenter.service.v1.roomcenter/AllocCustomRoom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomcenterServer).AllocCustomRoom(ctx, req.(*AllocRoomReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Roomcenter_QueryRoomList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRoomListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomcenterServer).QueryRoomList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/roomcenter.service.v1.roomcenter/QueryRoomList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomcenterServer).QueryRoomList(ctx, req.(*QueryRoomListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Roomcenter_QueryArenaNewVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryArenaNewVersionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomcenterServer).QueryArenaNewVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/roomcenter.service.v1.roomcenter/QueryArenaNewVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomcenterServer).QueryArenaNewVersion(ctx, req.(*QueryArenaNewVersionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Roomcenter_UpdateArenaNewVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateArenaNewVersionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomcenterServer).UpdateArenaNewVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/roomcenter.service.v1.roomcenter/UpdateArenaNewVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomcenterServer).UpdateArenaNewVersion(ctx, req.(*UpdateArenaNewVersionReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Roomcenter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "roomcenter.service.v1.roomcenter",
	HandlerType: (*RoomcenterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AllocRoom",
			Handler:    _Roomcenter_AllocRoom_Handler,
		},
		{
			MethodName: "PushRoomStatus",
			Handler:    _Roomcenter_PushRoomStatus_Handler,
		},
		{
			MethodName: "PushOnlineStatus",
			Handler:    _Roomcenter_PushOnlineStatus_Handler,
		},
		{
			MethodName: "HeartBeat",
			Handler:    _Roomcenter_HeartBeat_Handler,
		},
		{
			MethodName: "OnUpdateCustomRoomNum",
			Handler:    _Roomcenter_OnUpdateCustomRoomNum_Handler,
		},
		{
			MethodName: "OnGetCustomRoomAddress",
			Handler:    _Roomcenter_OnGetCustomRoomAddress_Handler,
		},
		{
			MethodName: "MultiPlayerAllocRoom",
			Handler:    _Roomcenter_MultiPlayerAllocRoom_Handler,
		},
		{
			MethodName: "QueryArena",
			Handler:    _Roomcenter_QueryArena_Handler,
		},
		{
			MethodName: "AllocCustomRoom",
			Handler:    _Roomcenter_AllocCustomRoom_Handler,
		},
		{
			MethodName: "QueryRoomList",
			Handler:    _Roomcenter_QueryRoomList_Handler,
		},
		{
			MethodName: "QueryArenaNewVersion",
			Handler:    _Roomcenter_QueryArenaNewVersion_Handler,
		},
		{
			MethodName: "UpdateArenaNewVersion",
			Handler:    _Roomcenter_UpdateArenaNewVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *AllocRoomReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocRoomReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocRoomReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if m.GroupID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x20
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x18
	}
	if m.PlayerID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AllocRoomRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocRoomRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocRoomRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxTableNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MaxTableNum))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RoomID) > 0 {
		i -= len(m.RoomID)
		copy(dAtA[i:], m.RoomID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RoomID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PushRoomStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushRoomStatusReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushRoomStatusReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RobotCount != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RobotCount))
		i--
		dAtA[i] = 0x58
	}
	if len(m.TableType) > 0 {
		i -= len(m.TableType)
		copy(dAtA[i:], m.TableType)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TableType)))
		i--
		dAtA[i] = 0x52
	}
	if m.TablePwd {
		i--
		if m.TablePwd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.TableUserNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TableUserNum))
		i--
		dAtA[i] = 0x40
	}
	if m.TableID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x38
	}
	if m.TableNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TableNum))
		i--
		dAtA[i] = 0x30
	}
	if m.Total != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x28
	}
	if m.Count != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RoomID) > 0 {
		i -= len(m.RoomID)
		copy(dAtA[i:], m.RoomID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RoomID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommonRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OnlineStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnlineStatusReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnlineStatusReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxTableNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MaxTableNum))
		i--
		dAtA[i] = 0x40
	}
	if m.Version != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x32
	}
	if m.Total != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x28
	}
	if m.IsOnLine {
		i--
		if m.IsOnLine {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.RoomID) > 0 {
		i -= len(m.RoomID)
		copy(dAtA[i:], m.RoomID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RoomID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HeartBeatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartBeatReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartBeatReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomID) > 0 {
		i -= len(m.RoomID)
		copy(dAtA[i:], m.RoomID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RoomID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCustomRoomNum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCustomRoomNum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCustomRoomNum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x38
	}
	if m.PlayerID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x30
	}
	if m.AddNew {
		i--
		if m.AddNew {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.RoomNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RoomNum))
		i--
		dAtA[i] = 0x20
	}
	if m.TableID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RoomID) > 0 {
		i -= len(m.RoomID)
		copy(dAtA[i:], m.RoomID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RoomID)))
		i--
		dAtA[i] = 0x12
	}
	if m.GroupID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCustomRoomAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCustomRoomAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCustomRoomAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RoomNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RoomNum))
		i--
		dAtA[i] = 0x18
	}
	if m.GroupID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCustomRoomAddressResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCustomRoomAddressResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCustomRoomAddressResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaID))
		i--
		dAtA[i] = 0x30
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x28
	}
	if m.TableID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiPlayerAllocRoomReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiPlayerAllocRoomReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiPlayerAllocRoomReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserList) > 0 {
		dAtA2 := make([]byte, len(m.UserList)*10)
		var j1 int
		for _, num1 := range m.UserList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintApi(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryArenaReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryArenaReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryArenaReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArenaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArenaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArenaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Expand) > 0 {
		i -= len(m.Expand)
		copy(dAtA[i:], m.Expand)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Expand)))
		i--
		dAtA[i] = 0x2a
	}
	if m.MaxMoney != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MaxMoney))
		i--
		dAtA[i] = 0x20
	}
	if m.MinMoney != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MinMoney))
		i--
		dAtA[i] = 0x18
	}
	if m.GroupID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryArenaRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryArenaRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryArenaRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ArenaList) > 0 {
		for iNdEx := len(m.ArenaList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ArenaList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryRoomListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRoomListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRoomListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomID) > 0 {
		i -= len(m.RoomID)
		copy(dAtA[i:], m.RoomID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RoomID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TableType) > 0 {
		i -= len(m.TableType)
		copy(dAtA[i:], m.TableType)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TableType)))
		i--
		dAtA[i] = 0x22
	}
	if m.TablePwd {
		i--
		if m.TablePwd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.UserNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserNum))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoomInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoomInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TableList) > 0 {
		for iNdEx := len(m.TableList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x22
	}
	if m.UserTotal != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserTotal))
		i--
		dAtA[i] = 0x18
	}
	if m.UserNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserNum))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RoomID) > 0 {
		i -= len(m.RoomID)
		copy(dAtA[i:], m.RoomID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RoomID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryRoomListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRoomListRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRoomListRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomList) > 0 {
		for iNdEx := len(m.RoomList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoomList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryArenaNewVersionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryArenaNewVersionReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryArenaNewVersionReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArenaVerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArenaVerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArenaVerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastRoomIDs) > 0 {
		dAtA4 := make([]byte, len(m.LastRoomIDs)*10)
		var j3 int
		for _, num1 := range m.LastRoomIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintApi(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x3a
	}
	if m.LastVersion != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LastVersion))
		i--
		dAtA[i] = 0x30
	}
	if len(m.RoomIDs) > 0 {
		dAtA6 := make([]byte, len(m.RoomIDs)*10)
		var j5 int
		for _, num1 := range m.RoomIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintApi(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x2a
	}
	if m.Switch != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Switch))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.GroupID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryArenaNewVersionRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryArenaNewVersionRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryArenaNewVersionRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ArenaList) > 0 {
		for iNdEx := len(m.ArenaList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ArenaList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateArenaNewVersionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateArenaNewVersionReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateArenaNewVersionReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.GroupID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateArenaNewVersionRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateArenaNewVersionRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateArenaNewVersionRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AllocRoomReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovApi(uint64(m.PlayerID))
	}
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.GroupID != 0 {
		n += 1 + sovApi(uint64(m.GroupID))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocRoomRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MaxTableNum != 0 {
		n += 1 + sovApi(uint64(m.MaxTableNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PushRoomStatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.GroupID != 0 {
		n += 1 + sovApi(uint64(m.GroupID))
	}
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovApi(uint64(m.Count))
	}
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if m.TableNum != 0 {
		n += 1 + sovApi(uint64(m.TableNum))
	}
	if m.TableID != 0 {
		n += 1 + sovApi(uint64(m.TableID))
	}
	if m.TableUserNum != 0 {
		n += 1 + sovApi(uint64(m.TableUserNum))
	}
	if m.TablePwd {
		n += 2
	}
	l = len(m.TableType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.RobotCount != 0 {
		n += 1 + sovApi(uint64(m.RobotCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnlineStatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.GroupID != 0 {
		n += 1 + sovApi(uint64(m.GroupID))
	}
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IsOnLine {
		n += 2
	}
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovApi(uint64(m.Version))
	}
	if m.MaxTableNum != 0 {
		n += 1 + sovApi(uint64(m.MaxTableNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeartBeatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.GroupID != 0 {
		n += 1 + sovApi(uint64(m.GroupID))
	}
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateCustomRoomNum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovApi(uint64(m.GroupID))
	}
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TableID != 0 {
		n += 1 + sovApi(uint64(m.TableID))
	}
	if m.RoomNum != 0 {
		n += 1 + sovApi(uint64(m.RoomNum))
	}
	if m.AddNew {
		n += 2
	}
	if m.PlayerID != 0 {
		n += 1 + sovApi(uint64(m.PlayerID))
	}
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetCustomRoomAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.GroupID != 0 {
		n += 1 + sovApi(uint64(m.GroupID))
	}
	if m.RoomNum != 0 {
		n += 1 + sovApi(uint64(m.RoomNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetCustomRoomAddressResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TableID != 0 {
		n += 1 + sovApi(uint64(m.TableID))
	}
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.ArenaID != 0 {
		n += 1 + sovApi(uint64(m.ArenaID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MultiPlayerAllocRoomReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.GroupID != 0 {
		n += 1 + sovApi(uint64(m.GroupID))
	}
	if len(m.UserList) > 0 {
		l = 0
		for _, e := range m.UserList {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryArenaReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArenaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.GroupID != 0 {
		n += 1 + sovApi(uint64(m.GroupID))
	}
	if m.MinMoney != 0 {
		n += 1 + sovApi(uint64(m.MinMoney))
	}
	if m.MaxMoney != 0 {
		n += 1 + sovApi(uint64(m.MaxMoney))
	}
	l = len(m.Expand)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryArenaRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ArenaList) > 0 {
		for _, e := range m.ArenaList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryRoomListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.GroupID != 0 {
		n += 1 + sovApi(uint64(m.GroupID))
	}
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovApi(uint64(m.TableID))
	}
	if m.UserNum != 0 {
		n += 1 + sovApi(uint64(m.UserNum))
	}
	if m.TablePwd {
		n += 2
	}
	l = len(m.TableType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.UserNum != 0 {
		n += 1 + sovApi(uint64(m.UserNum))
	}
	if m.UserTotal != 0 {
		n += 1 + sovApi(uint64(m.UserTotal))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.TableList) > 0 {
		for _, e := range m.TableList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryRoomListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.RoomList) > 0 {
		for _, e := range m.RoomList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryArenaNewVersionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArenaVerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.GroupID != 0 {
		n += 1 + sovApi(uint64(m.GroupID))
	}
	if m.Version != 0 {
		n += 1 + sovApi(uint64(m.Version))
	}
	if m.Switch != 0 {
		n += 1 + sovApi(uint64(m.Switch))
	}
	if len(m.RoomIDs) > 0 {
		l = 0
		for _, e := range m.RoomIDs {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.LastVersion != 0 {
		n += 1 + sovApi(uint64(m.LastVersion))
	}
	if len(m.LastRoomIDs) > 0 {
		l = 0
		for _, e := range m.LastRoomIDs {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryArenaNewVersionRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.ArenaList) > 0 {
		for _, e := range m.ArenaList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateArenaNewVersionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.GroupID != 0 {
		n += 1 + sovApi(uint64(m.GroupID))
	}
	if m.Version != 0 {
		n += 1 + sovApi(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateArenaNewVersionRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AllocRoomReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocRoomReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocRoomReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocRoomRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocRoomRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocRoomRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTableNum", wireType)
			}
			m.MaxTableNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTableNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushRoomStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushRoomStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushRoomStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableNum", wireType)
			}
			m.TableNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableUserNum", wireType)
			}
			m.TableUserNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableUserNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TablePwd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TablePwd = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobotCount", wireType)
			}
			m.RobotCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobotCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnlineStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnlineStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnlineStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnLine", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOnLine = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTableNum", wireType)
			}
			m.MaxTableNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTableNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartBeatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartBeatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartBeatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCustomRoomNum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCustomRoomNum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCustomRoomNum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomNum", wireType)
			}
			m.RoomNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddNew", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddNew = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCustomRoomAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCustomRoomAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCustomRoomAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomNum", wireType)
			}
			m.RoomNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCustomRoomAddressResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCustomRoomAddressResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCustomRoomAddressResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaID", wireType)
			}
			m.ArenaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiPlayerAllocRoomReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiPlayerAllocRoomReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiPlayerAllocRoomReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserList = append(m.UserList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserList) == 0 {
					m.UserList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserList = append(m.UserList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryArenaReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryArenaReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryArenaReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArenaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArenaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArenaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinMoney", wireType)
			}
			m.MinMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinMoney |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMoney", wireType)
			}
			m.MaxMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMoney |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryArenaRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryArenaRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryArenaRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArenaList = append(m.ArenaList, &ArenaInfo{})
			if err := m.ArenaList[len(m.ArenaList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRoomListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRoomListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRoomListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserNum", wireType)
			}
			m.UserNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TablePwd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TablePwd = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserNum", wireType)
			}
			m.UserNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTotal", wireType)
			}
			m.UserTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableList = append(m.TableList, &TableInfo{})
			if err := m.TableList[len(m.TableList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRoomListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRoomListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRoomListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomList = append(m.RoomList, &RoomInfo{})
			if err := m.RoomList[len(m.RoomList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryArenaNewVersionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryArenaNewVersionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryArenaNewVersionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArenaVerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArenaVerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArenaVerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Switch", wireType)
			}
			m.Switch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Switch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RoomIDs = append(m.RoomIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RoomIDs) == 0 {
					m.RoomIDs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RoomIDs = append(m.RoomIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomIDs", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastVersion", wireType)
			}
			m.LastVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LastRoomIDs = append(m.LastRoomIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LastRoomIDs) == 0 {
					m.LastRoomIDs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LastRoomIDs = append(m.LastRoomIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRoomIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryArenaNewVersionRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryArenaNewVersionRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryArenaNewVersionRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArenaList = append(m.ArenaList, &ArenaVerInfo{})
			if err := m.ArenaList[len(m.ArenaList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateArenaNewVersionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateArenaNewVersionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateArenaNewVersionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateArenaNewVersionRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateArenaNewVersionRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateArenaNewVersionRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
