// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/api.proto

// package 命名使用 {appid}.{version} 的方式, version 形如 v1, v2 ..

package api

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ErrCode int32

const (
	ErrCode_Error_Code_Nil                           ErrCode = 0
	ErrCode_Error_Code_Illegal_Params                ErrCode = 1
	ErrCode_Error_Code_Missing_Type                  ErrCode = 4
	ErrCode_Error_Code_Group_Config_Error            ErrCode = 5
	ErrCode_Error_Code_Item_Config_Error             ErrCode = 6
	ErrCode_Error_Code_Mission_Config_Error          ErrCode = 7
	ErrCode_Error_Code_Limit_Not_Satisfied           ErrCode = 50
	ErrCode_Error_Code_Mission_Not_Finished_Or_Ended ErrCode = 51
	ErrCode_Error_Code_Mission_Reward_Grant_Fail     ErrCode = 52
	ErrCode_Error_Code_Already_Received              ErrCode = 53
)

var ErrCode_name = map[int32]string{
	0:  "Error_Code_Nil",
	1:  "Error_Code_Illegal_Params",
	4:  "Error_Code_Missing_Type",
	5:  "Error_Code_Group_Config_Error",
	6:  "Error_Code_Item_Config_Error",
	7:  "Error_Code_Mission_Config_Error",
	50: "Error_Code_Limit_Not_Satisfied",
	51: "Error_Code_Mission_Not_Finished_Or_Ended",
	52: "Error_Code_Mission_Reward_Grant_Fail",
	53: "Error_Code_Already_Received",
}

var ErrCode_value = map[string]int32{
	"Error_Code_Nil":                           0,
	"Error_Code_Illegal_Params":                1,
	"Error_Code_Missing_Type":                  4,
	"Error_Code_Group_Config_Error":            5,
	"Error_Code_Item_Config_Error":             6,
	"Error_Code_Mission_Config_Error":          7,
	"Error_Code_Limit_Not_Satisfied":           50,
	"Error_Code_Mission_Not_Finished_Or_Ended": 51,
	"Error_Code_Mission_Reward_Grant_Fail":     52,
	"Error_Code_Already_Received":              53,
}

func (x ErrCode) String() string {
	return proto.EnumName(ErrCode_name, int32(x))
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{0}
}

// 领奖限制类型 (未满足不能领取奖励)
type LimitType int32

const (
	LimitType_Limit_Type_Nil         LimitType = 0
	LimitType_Limit_Type_Vip         LimitType = 1
	LimitType_Limit_Type_Activity    LimitType = 2
	LimitType_Limit_Type_Game_Count  LimitType = 3
	LimitType_Limit_Type_Match_Count LimitType = 4
	LimitType_Limit_Type_Novice_Gift LimitType = 5
)

var LimitType_name = map[int32]string{
	0: "Limit_Type_Nil",
	1: "Limit_Type_Vip",
	2: "Limit_Type_Activity",
	3: "Limit_Type_Game_Count",
	4: "Limit_Type_Match_Count",
	5: "Limit_Type_Novice_Gift",
}

var LimitType_value = map[string]int32{
	"Limit_Type_Nil":         0,
	"Limit_Type_Vip":         1,
	"Limit_Type_Activity":    2,
	"Limit_Type_Game_Count":  3,
	"Limit_Type_Match_Count": 4,
	"Limit_Type_Novice_Gift": 5,
}

func (x LimitType) String() string {
	return proto.EnumName(LimitType_name, int32(x))
}

func (LimitType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{1}
}

// 活跃读限制类型 (未满足领取非活跃奖励)
type ActivityType int32

const (
	ActivityType_Activity_Type_Nil         ActivityType = 0
	ActivityType_Activity_Type_Game_Count  ActivityType = 1
	ActivityType_Activity_Type_Match_Count ActivityType = 2
)

var ActivityType_name = map[int32]string{
	0: "Activity_Type_Nil",
	1: "Activity_Type_Game_Count",
	2: "Activity_Type_Match_Count",
}

var ActivityType_value = map[string]int32{
	"Activity_Type_Nil":         0,
	"Activity_Type_Game_Count":  1,
	"Activity_Type_Match_Count": 2,
}

func (x ActivityType) String() string {
	return proto.EnumName(ActivityType_name, int32(x))
}

func (ActivityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{2}
}

type UserMissionState int32

const (
	UserMissionState_User_Mission_State_nil        UserMissionState = 0
	UserMissionState_User_Mission_State_Going      UserMissionState = 1
	UserMissionState_User_Mission_State_Finished   UserMissionState = 2
	UserMissionState_User_Mission_State_UnFinished UserMissionState = 3
	UserMissionState_User_Mission_State_Received   UserMissionState = 4
)

var UserMissionState_name = map[int32]string{
	0: "User_Mission_State_nil",
	1: "User_Mission_State_Going",
	2: "User_Mission_State_Finished",
	3: "User_Mission_State_UnFinished",
	4: "User_Mission_State_Received",
}

var UserMissionState_value = map[string]int32{
	"User_Mission_State_nil":        0,
	"User_Mission_State_Going":      1,
	"User_Mission_State_Finished":   2,
	"User_Mission_State_UnFinished": 3,
	"User_Mission_State_Received":   4,
}

func (x UserMissionState) String() string {
	return proto.EnumName(UserMissionState_name, int32(x))
}

func (UserMissionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{3}
}

type Mission_Type int32

const (
	Mission_Mission_Type_Nil         Mission_Type = 0
	Mission_Mission_Type_Cycle       Mission_Type = 1
	Mission_Mission_Type_Normal      Mission_Type = 2
	Mission_Mission_Type_Novice      Mission_Type = 3
	Mission_Mission_Type_Achievement Mission_Type = 4
	Mission_Mission_Type_Activity    Mission_Type = 5
)

var Mission_Type_name = map[int32]string{
	0: "Mission_Type_Nil",
	1: "Mission_Type_Cycle",
	2: "Mission_Type_Normal",
	3: "Mission_Type_Novice",
	4: "Mission_Type_Achievement",
	5: "Mission_Type_Activity",
}

var Mission_Type_value = map[string]int32{
	"Mission_Type_Nil":         0,
	"Mission_Type_Cycle":       1,
	"Mission_Type_Normal":      2,
	"Mission_Type_Novice":      3,
	"Mission_Type_Achievement": 4,
	"Mission_Type_Activity":    5,
}

func (x Mission_Type) String() string {
	return proto.EnumName(Mission_Type_name, int32(x))
}

func (Mission_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{23, 0}
}

type Mission_State int32

const (
	Mission_Mission_State_Nil   Mission_State = 0
	Mission_Mission_State_Pre   Mission_State = 1
	Mission_Mission_State_Start Mission_State = 2
	Mission_Mission_State_end   Mission_State = 3
	Mission_Mission_State_Dead  Mission_State = 4
)

var Mission_State_name = map[int32]string{
	0: "Mission_State_Nil",
	1: "Mission_State_Pre",
	2: "Mission_State_Start",
	3: "Mission_State_end",
	4: "Mission_State_Dead",
}

var Mission_State_value = map[string]int32{
	"Mission_State_Nil":   0,
	"Mission_State_Pre":   1,
	"Mission_State_Start": 2,
	"Mission_State_end":   3,
	"Mission_State_Dead":  4,
}

func (x Mission_State) String() string {
	return proto.EnumName(Mission_State_name, int32(x))
}

func (Mission_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{23, 1}
}

type Mission_CycleType int32

const (
	Mission_Mission_Cycle_Type_Nil   Mission_CycleType = 0
	Mission_Mission_Cycle_Type_Day   Mission_CycleType = 1
	Mission_Mission_Cycle_Type_Week  Mission_CycleType = 2
	Mission_Mission_Cycle_Type_Month Mission_CycleType = 3
	Mission_Mission_Cycle_Type_Year  Mission_CycleType = 4
)

var Mission_CycleType_name = map[int32]string{
	0: "Mission_Cycle_Type_Nil",
	1: "Mission_Cycle_Type_Day",
	2: "Mission_Cycle_Type_Week",
	3: "Mission_Cycle_Type_Month",
	4: "Mission_Cycle_Type_Year",
}

var Mission_CycleType_value = map[string]int32{
	"Mission_Cycle_Type_Nil":   0,
	"Mission_Cycle_Type_Day":   1,
	"Mission_Cycle_Type_Week":  2,
	"Mission_Cycle_Type_Month": 3,
	"Mission_Cycle_Type_Year":  4,
}

func (x Mission_CycleType) String() string {
	return proto.EnumName(Mission_CycleType_name, int32(x))
}

func (Mission_CycleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{23, 2}
}

type Requirement_Type int32

const (
	Requirement_Requirement_Type_Nil        Requirement_Type = 0
	Requirement_Requirement_Type_Cumulative Requirement_Type = 1
	Requirement_Requirement_Type_Continue   Requirement_Type = 2
)

var Requirement_Type_name = map[int32]string{
	0: "Requirement_Type_Nil",
	1: "Requirement_Type_Cumulative",
	2: "Requirement_Type_Continue",
}

var Requirement_Type_value = map[string]int32{
	"Requirement_Type_Nil":        0,
	"Requirement_Type_Cumulative": 1,
	"Requirement_Type_Continue":   2,
}

func (x Requirement_Type) String() string {
	return proto.EnumName(Requirement_Type_name, int32(x))
}

func (Requirement_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{25, 0}
}

type Reward_Type int32

const (
	Reward_Reward_Type_Nil    Reward_Type = 0
	Reward_Reward_Type_Fixed  Reward_Type = 1
	Reward_Reward_Type_Random Reward_Type = 2
)

var Reward_Type_name = map[int32]string{
	0: "Reward_Type_Nil",
	1: "Reward_Type_Fixed",
	2: "Reward_Type_Random",
}

var Reward_Type_value = map[string]int32{
	"Reward_Type_Nil":    0,
	"Reward_Type_Fixed":  1,
	"Reward_Type_Random": 2,
}

func (x Reward_Type) String() string {
	return proto.EnumName(Reward_Type_name, int32(x))
}

func (Reward_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{28, 0}
}

type Item_Type int32

const (
	Item_Item_Type_Nil         Item_Type = 0
	Item_Item_Type_Coin        Item_Type = 1
	Item_Item_Type_Extend_Coin Item_Type = 2
	Item_Item_Type_Ticket      Item_Type = 3
)

var Item_Type_name = map[int32]string{
	0: "Item_Type_Nil",
	1: "Item_Type_Coin",
	2: "Item_Type_Extend_Coin",
	3: "Item_Type_Ticket",
}

var Item_Type_value = map[string]int32{
	"Item_Type_Nil":         0,
	"Item_Type_Coin":        1,
	"Item_Type_Extend_Coin": 2,
	"Item_Type_Ticket":      3,
}

func (x Item_Type) String() string {
	return proto.EnumName(Item_Type_name, int32(x))
}

func (Item_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{29, 0}
}

type UserDetails struct {
	UserId               int64    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	IsWin                bool     `protobuf:"varint,2,opt,name=is_win,json=isWin,proto3" json:"is_win,omitempty"`
	Role                 int32    `protobuf:"varint,3,opt,name=role,proto3" json:"role,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserDetails) Reset()         { *m = UserDetails{} }
func (m *UserDetails) String() string { return proto.CompactTextString(m) }
func (*UserDetails) ProtoMessage()    {}
func (*UserDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{0}
}
func (m *UserDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserDetails.Merge(m, src)
}
func (m *UserDetails) XXX_Size() int {
	return m.Size()
}
func (m *UserDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_UserDetails.DiscardUnknown(m)
}

var xxx_messageInfo_UserDetails proto.InternalMessageInfo

type GameEndReq struct {
	GameId               int32          `protobuf:"varint,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	ArenaId              int32          `protobuf:"varint,2,opt,name=arena_id,json=arenaId,proto3" json:"arena_id,omitempty"`
	TableId              int32          `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	UserList             []*UserDetails `protobuf:"bytes,4,rep,name=user_list,json=userList,proto3" json:"user_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GameEndReq) Reset()         { *m = GameEndReq{} }
func (m *GameEndReq) String() string { return proto.CompactTextString(m) }
func (*GameEndReq) ProtoMessage()    {}
func (*GameEndReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{1}
}
func (m *GameEndReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameEndReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameEndReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameEndReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameEndReq.Merge(m, src)
}
func (m *GameEndReq) XXX_Size() int {
	return m.Size()
}
func (m *GameEndReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GameEndReq.DiscardUnknown(m)
}

var xxx_messageInfo_GameEndReq proto.InternalMessageInfo

type ActionDetails struct {
	Type                 int32    `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Num                  int32    `protobuf:"varint,2,opt,name=num,proto3" json:"num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActionDetails) Reset()         { *m = ActionDetails{} }
func (m *ActionDetails) String() string { return proto.CompactTextString(m) }
func (*ActionDetails) ProtoMessage()    {}
func (*ActionDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{2}
}
func (m *ActionDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDetails.Merge(m, src)
}
func (m *ActionDetails) XXX_Size() int {
	return m.Size()
}
func (m *ActionDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDetails proto.InternalMessageInfo

type SpecialActionReq struct {
	UserId               int64            `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GameId               int32            `protobuf:"varint,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	ArenaId              int32            `protobuf:"varint,3,opt,name=arena_id,json=arenaId,proto3" json:"arena_id,omitempty"`
	ActionList           []*ActionDetails `protobuf:"bytes,4,rep,name=action_list,json=actionList,proto3" json:"action_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SpecialActionReq) Reset()         { *m = SpecialActionReq{} }
func (m *SpecialActionReq) String() string { return proto.CompactTextString(m) }
func (*SpecialActionReq) ProtoMessage()    {}
func (*SpecialActionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{3}
}
func (m *SpecialActionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecialActionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecialActionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecialActionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecialActionReq.Merge(m, src)
}
func (m *SpecialActionReq) XXX_Size() int {
	return m.Size()
}
func (m *SpecialActionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecialActionReq.DiscardUnknown(m)
}

var xxx_messageInfo_SpecialActionReq proto.InternalMessageInfo

type BuyPropsReq struct {
	UserId               int64    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GameId               int32    `protobuf:"varint,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	PropsId              int32    `protobuf:"varint,3,opt,name=props_id,json=propsId,proto3" json:"props_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuyPropsReq) Reset()         { *m = BuyPropsReq{} }
func (m *BuyPropsReq) String() string { return proto.CompactTextString(m) }
func (*BuyPropsReq) ProtoMessage()    {}
func (*BuyPropsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{4}
}
func (m *BuyPropsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuyPropsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuyPropsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuyPropsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuyPropsReq.Merge(m, src)
}
func (m *BuyPropsReq) XXX_Size() int {
	return m.Size()
}
func (m *BuyPropsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BuyPropsReq.DiscardUnknown(m)
}

var xxx_messageInfo_BuyPropsReq proto.InternalMessageInfo

type PayMoneyReq struct {
	UserId               int64    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GameId               int32    `protobuf:"varint,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Money                int32    `protobuf:"varint,3,opt,name=money,proto3" json:"money,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PayMoneyReq) Reset()         { *m = PayMoneyReq{} }
func (m *PayMoneyReq) String() string { return proto.CompactTextString(m) }
func (*PayMoneyReq) ProtoMessage()    {}
func (*PayMoneyReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{5}
}
func (m *PayMoneyReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayMoneyReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayMoneyReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayMoneyReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayMoneyReq.Merge(m, src)
}
func (m *PayMoneyReq) XXX_Size() int {
	return m.Size()
}
func (m *PayMoneyReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PayMoneyReq.DiscardUnknown(m)
}

var xxx_messageInfo_PayMoneyReq proto.InternalMessageInfo

type QueryTaskReq struct {
	UserId               int64    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GameId               int32    `protobuf:"varint,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	TaskProperty         string   `protobuf:"bytes,3,opt,name=task_property,json=taskProperty,proto3" json:"task_property,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryTaskReq) Reset()         { *m = QueryTaskReq{} }
func (m *QueryTaskReq) String() string { return proto.CompactTextString(m) }
func (*QueryTaskReq) ProtoMessage()    {}
func (*QueryTaskReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{6}
}
func (m *QueryTaskReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTaskReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTaskReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTaskReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTaskReq.Merge(m, src)
}
func (m *QueryTaskReq) XXX_Size() int {
	return m.Size()
}
func (m *QueryTaskReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTaskReq.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTaskReq proto.InternalMessageInfo

type PropsDetails struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Num                  int32    `protobuf:"varint,2,opt,name=num,proto3" json:"num,omitempty"`
	Weight               int32    `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"`
	Type                 int64    `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	Name                 string   `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PropsDetails) Reset()         { *m = PropsDetails{} }
func (m *PropsDetails) String() string { return proto.CompactTextString(m) }
func (*PropsDetails) ProtoMessage()    {}
func (*PropsDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{7}
}
func (m *PropsDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropsDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropsDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropsDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropsDetails.Merge(m, src)
}
func (m *PropsDetails) XXX_Size() int {
	return m.Size()
}
func (m *PropsDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_PropsDetails.DiscardUnknown(m)
}

var xxx_messageInfo_PropsDetails proto.InternalMessageInfo

type ActivityDetails struct {
	Num                  int32           `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
	State                int32           `protobuf:"varint,2,opt,name=state,proto3" json:"state,omitempty"`
	PropsList            []*PropsDetails `protobuf:"bytes,3,rep,name=props_list,json=propsList,proto3" json:"props_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ActivityDetails) Reset()         { *m = ActivityDetails{} }
func (m *ActivityDetails) String() string { return proto.CompactTextString(m) }
func (*ActivityDetails) ProtoMessage()    {}
func (*ActivityDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{8}
}
func (m *ActivityDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivityDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivityDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivityDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivityDetails.Merge(m, src)
}
func (m *ActivityDetails) XXX_Size() int {
	return m.Size()
}
func (m *ActivityDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivityDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ActivityDetails proto.InternalMessageInfo

type TaskDetails struct {
	Id                   string          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Property             string          `protobuf:"bytes,2,opt,name=property,proto3" json:"property,omitempty"`
	Type                 string          `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Trigger              string          `protobuf:"bytes,4,opt,name=trigger,proto3" json:"trigger,omitempty"`
	Current              int32           `protobuf:"varint,5,opt,name=current,proto3" json:"current,omitempty"`
	Finish               int32           `protobuf:"varint,6,opt,name=finish,proto3" json:"finish,omitempty"`
	State                int32           `protobuf:"varint,7,opt,name=state,proto3" json:"state,omitempty"`
	Order                int32           `protobuf:"varint,8,opt,name=order,proto3" json:"order,omitempty"`
	PropsList            []*PropsDetails `protobuf:"bytes,9,rep,name=props_list,json=propsList,proto3" json:"props_list,omitempty"`
	ArenaId              int32           `protobuf:"varint,10,opt,name=arena_id,json=arenaId,proto3" json:"arena_id,omitempty"`
	Everyday             int32           `protobuf:"varint,11,opt,name=everyday,proto3" json:"everyday,omitempty"`
	TaskDate             *Date           `protobuf:"bytes,12,opt,name=TaskDate,proto3" json:"TaskDate,omitempty"`
	OnlineDetail         *OnlineDetail   `protobuf:"bytes,13,opt,name=OnlineDetail,proto3" json:"OnlineDetail,omitempty"`
	Desc                 string          `protobuf:"bytes,14,opt,name=Desc,proto3" json:"Desc,omitempty"`
	Image                string          `protobuf:"bytes,15,opt,name=Image,proto3" json:"Image,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TaskDetails) Reset()         { *m = TaskDetails{} }
func (m *TaskDetails) String() string { return proto.CompactTextString(m) }
func (*TaskDetails) ProtoMessage()    {}
func (*TaskDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{9}
}
func (m *TaskDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskDetails.Merge(m, src)
}
func (m *TaskDetails) XXX_Size() int {
	return m.Size()
}
func (m *TaskDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskDetails.DiscardUnknown(m)
}

var xxx_messageInfo_TaskDetails proto.InternalMessageInfo

type Date struct {
	StartTime            string   `protobuf:"bytes,1,opt,name=StartTime,proto3" json:"StartTime,omitempty"`
	EndTime              string   `protobuf:"bytes,2,opt,name=EndTime,proto3" json:"EndTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Date) Reset()         { *m = Date{} }
func (m *Date) String() string { return proto.CompactTextString(m) }
func (*Date) ProtoMessage()    {}
func (*Date) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{10}
}
func (m *Date) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Date) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Date.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Date) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Date.Merge(m, src)
}
func (m *Date) XXX_Size() int {
	return m.Size()
}
func (m *Date) XXX_DiscardUnknown() {
	xxx_messageInfo_Date.DiscardUnknown(m)
}

var xxx_messageInfo_Date proto.InternalMessageInfo

type QueryTaskResp struct {
	Code                 int32              `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string             `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Deadline             int64              `protobuf:"varint,3,opt,name=deadline,proto3" json:"deadline,omitempty"`
	CurrentActivity      int32              `protobuf:"varint,4,opt,name=current_activity,json=currentActivity,proto3" json:"current_activity,omitempty"`
	TaskList             []*TaskDetails     `protobuf:"bytes,5,rep,name=task_list,json=taskList,proto3" json:"task_list,omitempty"`
	ActivityList         []*ActivityDetails `protobuf:"bytes,6,rep,name=activity_list,json=activityList,proto3" json:"activity_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *QueryTaskResp) Reset()         { *m = QueryTaskResp{} }
func (m *QueryTaskResp) String() string { return proto.CompactTextString(m) }
func (*QueryTaskResp) ProtoMessage()    {}
func (*QueryTaskResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{11}
}
func (m *QueryTaskResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTaskResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTaskResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTaskResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTaskResp.Merge(m, src)
}
func (m *QueryTaskResp) XXX_Size() int {
	return m.Size()
}
func (m *QueryTaskResp) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTaskResp.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTaskResp proto.InternalMessageInfo

type GetTaskRewardReq struct {
	UserId               int64    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GameId               int32    `protobuf:"varint,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	TaskId               string   `protobuf:"bytes,3,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTaskRewardReq) Reset()         { *m = GetTaskRewardReq{} }
func (m *GetTaskRewardReq) String() string { return proto.CompactTextString(m) }
func (*GetTaskRewardReq) ProtoMessage()    {}
func (*GetTaskRewardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{12}
}
func (m *GetTaskRewardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTaskRewardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTaskRewardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTaskRewardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTaskRewardReq.Merge(m, src)
}
func (m *GetTaskRewardReq) XXX_Size() int {
	return m.Size()
}
func (m *GetTaskRewardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTaskRewardReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetTaskRewardReq proto.InternalMessageInfo

type RewardResp struct {
	Code                 int32           `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string          `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	PropsList            []*PropsDetails `protobuf:"bytes,3,rep,name=props_list,json=propsList,proto3" json:"props_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RewardResp) Reset()         { *m = RewardResp{} }
func (m *RewardResp) String() string { return proto.CompactTextString(m) }
func (*RewardResp) ProtoMessage()    {}
func (*RewardResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{13}
}
func (m *RewardResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardResp.Merge(m, src)
}
func (m *RewardResp) XXX_Size() int {
	return m.Size()
}
func (m *RewardResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardResp.DiscardUnknown(m)
}

var xxx_messageInfo_RewardResp proto.InternalMessageInfo

type GetActivityRewardReq struct {
	UserId               int64    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GameId               int32    `protobuf:"varint,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Activity             int32    `protobuf:"varint,3,opt,name=activity,proto3" json:"activity,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetActivityRewardReq) Reset()         { *m = GetActivityRewardReq{} }
func (m *GetActivityRewardReq) String() string { return proto.CompactTextString(m) }
func (*GetActivityRewardReq) ProtoMessage()    {}
func (*GetActivityRewardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{14}
}
func (m *GetActivityRewardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetActivityRewardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetActivityRewardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetActivityRewardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetActivityRewardReq.Merge(m, src)
}
func (m *GetActivityRewardReq) XXX_Size() int {
	return m.Size()
}
func (m *GetActivityRewardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetActivityRewardReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetActivityRewardReq proto.InternalMessageInfo

type GetRandRewardReq struct {
	UserId               int64    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GameId               int32    `protobuf:"varint,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	TaskProperty         string   `protobuf:"bytes,3,opt,name=task_property,json=taskProperty,proto3" json:"task_property,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRandRewardReq) Reset()         { *m = GetRandRewardReq{} }
func (m *GetRandRewardReq) String() string { return proto.CompactTextString(m) }
func (*GetRandRewardReq) ProtoMessage()    {}
func (*GetRandRewardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{15}
}
func (m *GetRandRewardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRandRewardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRandRewardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRandRewardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRandRewardReq.Merge(m, src)
}
func (m *GetRandRewardReq) XXX_Size() int {
	return m.Size()
}
func (m *GetRandRewardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRandRewardReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetRandRewardReq proto.InternalMessageInfo

type CommonResp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonResp) Reset()         { *m = CommonResp{} }
func (m *CommonResp) String() string { return proto.CompactTextString(m) }
func (*CommonResp) ProtoMessage()    {}
func (*CommonResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{16}
}
func (m *CommonResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonResp.Merge(m, src)
}
func (m *CommonResp) XXX_Size() int {
	return m.Size()
}
func (m *CommonResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonResp.DiscardUnknown(m)
}

var xxx_messageInfo_CommonResp proto.InternalMessageInfo

type SpecialActionResp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	IsContinue           bool     `protobuf:"varint,3,opt,name=is_continue,json=isContinue,proto3" json:"is_continue,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpecialActionResp) Reset()         { *m = SpecialActionResp{} }
func (m *SpecialActionResp) String() string { return proto.CompactTextString(m) }
func (*SpecialActionResp) ProtoMessage()    {}
func (*SpecialActionResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{17}
}
func (m *SpecialActionResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecialActionResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecialActionResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecialActionResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecialActionResp.Merge(m, src)
}
func (m *SpecialActionResp) XXX_Size() int {
	return m.Size()
}
func (m *SpecialActionResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecialActionResp.DiscardUnknown(m)
}

var xxx_messageInfo_SpecialActionResp proto.InternalMessageInfo

type PushOnLineStatusReq struct {
	UserId               int64    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GameId               int32    `protobuf:"varint,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	IsOnline             bool     `protobuf:"varint,3,opt,name=is_online,json=isOnline,proto3" json:"is_online,omitempty"`
	ArenaId              int32    `protobuf:"varint,4,opt,name=arena_id,json=arenaId,proto3" json:"arena_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PushOnLineStatusReq) Reset()         { *m = PushOnLineStatusReq{} }
func (m *PushOnLineStatusReq) String() string { return proto.CompactTextString(m) }
func (*PushOnLineStatusReq) ProtoMessage()    {}
func (*PushOnLineStatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{18}
}
func (m *PushOnLineStatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushOnLineStatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushOnLineStatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushOnLineStatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushOnLineStatusReq.Merge(m, src)
}
func (m *PushOnLineStatusReq) XXX_Size() int {
	return m.Size()
}
func (m *PushOnLineStatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PushOnLineStatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_PushOnLineStatusReq proto.InternalMessageInfo

type OnlineDetail struct {
	LeftTime             int64    `protobuf:"varint,1,opt,name=leftTime,proto3" json:"leftTime,omitempty"`
	TargetTime           int64    `protobuf:"varint,2,opt,name=TargetTime,proto3" json:"TargetTime,omitempty"`
	TaskStage            int32    `protobuf:"varint,3,opt,name=task_stage,json=taskStage,proto3" json:"task_stage,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnlineDetail) Reset()         { *m = OnlineDetail{} }
func (m *OnlineDetail) String() string { return proto.CompactTextString(m) }
func (*OnlineDetail) ProtoMessage()    {}
func (*OnlineDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{19}
}
func (m *OnlineDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnlineDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnlineDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnlineDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnlineDetail.Merge(m, src)
}
func (m *OnlineDetail) XXX_Size() int {
	return m.Size()
}
func (m *OnlineDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_OnlineDetail.DiscardUnknown(m)
}

var xxx_messageInfo_OnlineDetail proto.InternalMessageInfo

type GetHallTaskReq struct {
	UserId               int64    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GameId               int32    `protobuf:"varint,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	TaskProperty         string   `protobuf:"bytes,3,opt,name=task_property,json=taskProperty,proto3" json:"task_property,omitempty"`
	Vip                  int32    `protobuf:"varint,4,opt,name=vip,proto3" json:"vip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetHallTaskReq) Reset()         { *m = GetHallTaskReq{} }
func (m *GetHallTaskReq) String() string { return proto.CompactTextString(m) }
func (*GetHallTaskReq) ProtoMessage()    {}
func (*GetHallTaskReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{20}
}
func (m *GetHallTaskReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetHallTaskReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetHallTaskReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetHallTaskReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHallTaskReq.Merge(m, src)
}
func (m *GetHallTaskReq) XXX_Size() int {
	return m.Size()
}
func (m *GetHallTaskReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHallTaskReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetHallTaskReq proto.InternalMessageInfo

type HallTaskListResp struct {
	Code                 int32          `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string         `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Deadline             int64          `protobuf:"varint,3,opt,name=deadline,proto3" json:"deadline,omitempty"`
	ActiveBeginTime      string         `protobuf:"bytes,4,opt,name=ActiveBeginTime,proto3" json:"ActiveBeginTime,omitempty"`
	ActiveEndTime        string         `protobuf:"bytes,5,opt,name=ActiveEndTime,proto3" json:"ActiveEndTime,omitempty"`
	ActiveNowDay         int32          `protobuf:"varint,6,opt,name=ActiveNowDay,proto3" json:"ActiveNowDay,omitempty"`
	ActiveStatus         int32          `protobuf:"varint,7,opt,name=ActiveStatus,proto3" json:"ActiveStatus,omitempty"`
	TaskList             []*TaskDetails `protobuf:"bytes,8,rep,name=task_list,json=taskList,proto3" json:"task_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *HallTaskListResp) Reset()         { *m = HallTaskListResp{} }
func (m *HallTaskListResp) String() string { return proto.CompactTextString(m) }
func (*HallTaskListResp) ProtoMessage()    {}
func (*HallTaskListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{21}
}
func (m *HallTaskListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HallTaskListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HallTaskListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HallTaskListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HallTaskListResp.Merge(m, src)
}
func (m *HallTaskListResp) XXX_Size() int {
	return m.Size()
}
func (m *HallTaskListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_HallTaskListResp.DiscardUnknown(m)
}

var xxx_messageInfo_HallTaskListResp proto.InternalMessageInfo

type HallTaskRewardReq struct {
	UserId               int64    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GameId               int32    `protobuf:"varint,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	TaskId               string   `protobuf:"bytes,3,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	Vip                  int32    `protobuf:"varint,4,opt,name=vip,proto3" json:"vip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HallTaskRewardReq) Reset()         { *m = HallTaskRewardReq{} }
func (m *HallTaskRewardReq) String() string { return proto.CompactTextString(m) }
func (*HallTaskRewardReq) ProtoMessage()    {}
func (*HallTaskRewardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{22}
}
func (m *HallTaskRewardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HallTaskRewardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HallTaskRewardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HallTaskRewardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HallTaskRewardReq.Merge(m, src)
}
func (m *HallTaskRewardReq) XXX_Size() int {
	return m.Size()
}
func (m *HallTaskRewardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HallTaskRewardReq.DiscardUnknown(m)
}

var xxx_messageInfo_HallTaskRewardReq proto.InternalMessageInfo

type Mission struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	AppId                int32    `protobuf:"varint,2,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	GameId               int32    `protobuf:"varint,3,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	ArenaId              int32    `protobuf:"varint,4,opt,name=arena_id,json=arenaId,proto3" json:"arena_id,omitempty"`
	SourceType           int32    `protobuf:"varint,5,opt,name=source_type,json=sourceType,proto3" json:"source_type,omitempty"`
	Type                 int64    `protobuf:"varint,10,opt,name=type,proto3" json:"type,omitempty"`
	Name                 string   `protobuf:"bytes,11,opt,name=name,proto3" json:"name,omitempty"`
	Description          string   `protobuf:"bytes,12,opt,name=description,proto3" json:"description,omitempty"`
	ParentId             string   `protobuf:"bytes,13,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
	Icon                 string   `protobuf:"bytes,14,opt,name=icon,proto3" json:"icon,omitempty"`
	IsNeedJoin           bool     `protobuf:"varint,15,opt,name=is_need_join,json=isNeedJoin,proto3" json:"is_need_join,omitempty"`
	IsNeedReceive        bool     `protobuf:"varint,16,opt,name=is_need_receive,json=isNeedReceive,proto3" json:"is_need_receive,omitempty"`
	State                int64    `protobuf:"varint,17,opt,name=state,proto3" json:"state,omitempty"`
	Order                int32    `protobuf:"varint,18,opt,name=order,proto3" json:"order,omitempty"`
	PreTime              string   `protobuf:"bytes,20,opt,name=pre_time,json=preTime,proto3" json:"pre_time,omitempty"`
	StartTime            string   `protobuf:"bytes,21,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime              string   `protobuf:"bytes,22,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	DeadTime             string   `protobuf:"bytes,23,opt,name=dead_time,json=deadTime,proto3" json:"dead_time,omitempty"`
	PreTimestamp         int64    `protobuf:"varint,24,opt,name=pre_timestamp,json=preTimestamp,proto3" json:"pre_timestamp,omitempty"`
	StartTimestamp       int64    `protobuf:"varint,25,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	EndTimestamp         int64    `protobuf:"varint,26,opt,name=end_timestamp,json=endTimestamp,proto3" json:"end_timestamp,omitempty"`
	DeadTimestamp        int64    `protobuf:"varint,27,opt,name=dead_timestamp,json=deadTimestamp,proto3" json:"dead_timestamp,omitempty"`
	CycleType            int64    `protobuf:"varint,30,opt,name=cycle_type,json=cycleType,proto3" json:"cycle_type,omitempty"`
	CycleIndex           int64    `protobuf:"varint,31,opt,name=cycle_index,json=cycleIndex,proto3" json:"cycle_index,omitempty"`
	Limits               *Groups  `protobuf:"bytes,40,opt,name=limits,proto3" json:"limits,omitempty"`
	Activities           *Groups  `protobuf:"bytes,41,opt,name=activities,proto3" json:"activities,omitempty"`
	Requirements         *Groups  `protobuf:"bytes,43,opt,name=requirements,proto3" json:"requirements,omitempty"`
	Rewards              *Groups  `protobuf:"bytes,44,opt,name=rewards,proto3" json:"rewards,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Mission) Reset()         { *m = Mission{} }
func (m *Mission) String() string { return proto.CompactTextString(m) }
func (*Mission) ProtoMessage()    {}
func (*Mission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{23}
}
func (m *Mission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mission.Merge(m, src)
}
func (m *Mission) XXX_Size() int {
	return m.Size()
}
func (m *Mission) XXX_DiscardUnknown() {
	xxx_messageInfo_Mission.DiscardUnknown(m)
}

var xxx_messageInfo_Mission proto.InternalMessageInfo

//
type Groups struct {
	TargetIds            []int64  `protobuf:"varint,1,rep,packed,name=target_ids,json=targetIds,proto3" json:"target_ids,omitempty"`
	Counts               []int64  `protobuf:"varint,2,rep,packed,name=counts,proto3" json:"counts,omitempty"`
	GroupIds             []int32  `protobuf:"varint,3,rep,packed,name=group_ids,json=groupIds,proto3" json:"group_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Groups) Reset()         { *m = Groups{} }
func (m *Groups) String() string { return proto.CompactTextString(m) }
func (*Groups) ProtoMessage()    {}
func (*Groups) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{24}
}
func (m *Groups) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Groups) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Groups.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Groups) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Groups.Merge(m, src)
}
func (m *Groups) XXX_Size() int {
	return m.Size()
}
func (m *Groups) XXX_DiscardUnknown() {
	xxx_messageInfo_Groups.DiscardUnknown(m)
}

var xxx_messageInfo_Groups proto.InternalMessageInfo

// 任务完成条件
type Requirement struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Desc                 string   `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	Type                 int64    `protobuf:"varint,10,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Requirement) Reset()         { *m = Requirement{} }
func (m *Requirement) String() string { return proto.CompactTextString(m) }
func (*Requirement) ProtoMessage()    {}
func (*Requirement) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{25}
}
func (m *Requirement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Requirement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Requirement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Requirement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Requirement.Merge(m, src)
}
func (m *Requirement) XXX_Size() int {
	return m.Size()
}
func (m *Requirement) XXX_DiscardUnknown() {
	xxx_messageInfo_Requirement.DiscardUnknown(m)
}

var xxx_messageInfo_Requirement proto.InternalMessageInfo

type Requirements struct {
	Ids                  []int64  `protobuf:"varint,1,rep,packed,name=ids,proto3" json:"ids,omitempty"`
	Counts               []int64  `protobuf:"varint,2,rep,packed,name=counts,proto3" json:"counts,omitempty"`
	GroupIds             []int32  `protobuf:"varint,3,rep,packed,name=group_ids,json=groupIds,proto3" json:"group_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Requirements) Reset()         { *m = Requirements{} }
func (m *Requirements) String() string { return proto.CompactTextString(m) }
func (*Requirements) ProtoMessage()    {}
func (*Requirements) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{26}
}
func (m *Requirements) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Requirements) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Requirements.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Requirements) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Requirements.Merge(m, src)
}
func (m *Requirements) XXX_Size() int {
	return m.Size()
}
func (m *Requirements) XXX_DiscardUnknown() {
	xxx_messageInfo_Requirements.DiscardUnknown(m)
}

var xxx_messageInfo_Requirements proto.InternalMessageInfo

type RequirementMap struct {
	RequirementMap       map[int64]*Requirement `protobuf:"bytes,1,rep,name=requirement_map,json=requirementMap,proto3" json:"requirement_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *RequirementMap) Reset()         { *m = RequirementMap{} }
func (m *RequirementMap) String() string { return proto.CompactTextString(m) }
func (*RequirementMap) ProtoMessage()    {}
func (*RequirementMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{27}
}
func (m *RequirementMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequirementMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequirementMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequirementMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequirementMap.Merge(m, src)
}
func (m *RequirementMap) XXX_Size() int {
	return m.Size()
}
func (m *RequirementMap) XXX_DiscardUnknown() {
	xxx_messageInfo_RequirementMap.DiscardUnknown(m)
}

var xxx_messageInfo_RequirementMap proto.InternalMessageInfo

//任务完成奖励
type Reward struct {
	Id                        int64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type                      int64     `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	RandomWeights             []int64   `protobuf:"varint,10,rep,packed,name=random_weights,json=randomWeights,proto3" json:"random_weights,omitempty"`
	RandomLeft                []int64   `protobuf:"varint,11,rep,packed,name=random_left,json=randomLeft,proto3" json:"random_left,omitempty"`
	RandomRight               []int64   `protobuf:"varint,12,rep,packed,name=random_right,json=randomRight,proto3" json:"random_right,omitempty"`
	RandomItemIds             []int64   `protobuf:"varint,13,rep,packed,name=random_item_ids,json=randomItemIds,proto3" json:"random_item_ids,omitempty"`
	VipRange                  []int64   `protobuf:"varint,14,rep,packed,name=vip_range,json=vipRange,proto3" json:"vip_range,omitempty"`
	Factory                   []float64 `protobuf:"fixed64,15,rep,packed,name=factory,proto3" json:"factory,omitempty"`
	UnActivityRandomWeights   []int64   `protobuf:"varint,20,rep,packed,name=un_activity_random_weights,json=unActivityRandomWeights,proto3" json:"un_activity_random_weights,omitempty"`
	UnActivityRandomLeft      []int64   `protobuf:"varint,21,rep,packed,name=un_activity_random_left,json=unActivityRandomLeft,proto3" json:"un_activity_random_left,omitempty"`
	UnActivityRandomRight     []int64   `protobuf:"varint,22,rep,packed,name=un_activity_random_right,json=unActivityRandomRight,proto3" json:"un_activity_random_right,omitempty"`
	UnActivityRandomItemIds   []int64   `protobuf:"varint,23,rep,packed,name=un_activity_random_item_ids,json=unActivityRandomItemIds,proto3" json:"un_activity_random_item_ids,omitempty"`
	UnActivityVipRange        []int64   `protobuf:"varint,24,rep,packed,name=un_activity_vip_range,json=unActivityVipRange,proto3" json:"un_activity_vip_range,omitempty"`
	UnActivityFactory         []float64 `protobuf:"fixed64,25,rep,packed,name=un_activity_factory,json=unActivityFactory,proto3" json:"un_activity_factory,omitempty"`
	FixedItemIds              []int64   `protobuf:"varint,30,rep,packed,name=fixed_item_ids,json=fixedItemIds,proto3" json:"fixed_item_ids,omitempty"`
	FixedItemCounts           []int64   `protobuf:"varint,31,rep,packed,name=fixed_item_counts,json=fixedItemCounts,proto3" json:"fixed_item_counts,omitempty"`
	UnActivityFixedItemIds    []int64   `protobuf:"varint,40,rep,packed,name=un_activity_fixed_item_ids,json=unActivityFixedItemIds,proto3" json:"un_activity_fixed_item_ids,omitempty"`
	UnActivityFixedItemCounts []int64   `protobuf:"varint,41,rep,packed,name=un_activity_fixed_item_counts,json=unActivityFixedItemCounts,proto3" json:"un_activity_fixed_item_counts,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}  `json:"-"`
	XXX_unrecognized          []byte    `json:"-"`
	XXX_sizecache             int32     `json:"-"`
}

func (m *Reward) Reset()         { *m = Reward{} }
func (m *Reward) String() string { return proto.CompactTextString(m) }
func (*Reward) ProtoMessage()    {}
func (*Reward) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{28}
}
func (m *Reward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reward.Merge(m, src)
}
func (m *Reward) XXX_Size() int {
	return m.Size()
}
func (m *Reward) XXX_DiscardUnknown() {
	xxx_messageInfo_Reward.DiscardUnknown(m)
}

var xxx_messageInfo_Reward proto.InternalMessageInfo

// 具体奖励物品
type Item struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Type                 int64    `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Item) Reset()         { *m = Item{} }
func (m *Item) String() string { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()    {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{29}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

type UserMissionStateMap struct {
	UserMissionStateMap  map[string]int64 `protobuf:"bytes,1,rep,name=user_mission_state_map,json=userMissionStateMap,proto3" json:"user_mission_state_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *UserMissionStateMap) Reset()         { *m = UserMissionStateMap{} }
func (m *UserMissionStateMap) String() string { return proto.CompactTextString(m) }
func (*UserMissionStateMap) ProtoMessage()    {}
func (*UserMissionStateMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{30}
}
func (m *UserMissionStateMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserMissionStateMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserMissionStateMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserMissionStateMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMissionStateMap.Merge(m, src)
}
func (m *UserMissionStateMap) XXX_Size() int {
	return m.Size()
}
func (m *UserMissionStateMap) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMissionStateMap.DiscardUnknown(m)
}

var xxx_messageInfo_UserMissionStateMap proto.InternalMessageInfo

type ListHallMissionsReq struct {
	AppId                int32    `protobuf:"varint,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	UserId               int64    `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GameIds              []int32  `protobuf:"varint,3,rep,packed,name=game_ids,json=gameIds,proto3" json:"game_ids,omitempty"`
	MissionType          int64    `protobuf:"varint,4,opt,name=mission_type,json=missionType,proto3" json:"mission_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListHallMissionsReq) Reset()         { *m = ListHallMissionsReq{} }
func (m *ListHallMissionsReq) String() string { return proto.CompactTextString(m) }
func (*ListHallMissionsReq) ProtoMessage()    {}
func (*ListHallMissionsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{31}
}
func (m *ListHallMissionsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListHallMissionsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListHallMissionsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListHallMissionsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHallMissionsReq.Merge(m, src)
}
func (m *ListHallMissionsReq) XXX_Size() int {
	return m.Size()
}
func (m *ListHallMissionsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHallMissionsReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListHallMissionsReq proto.InternalMessageInfo

type Missions struct {
	Missions             []*Mission `protobuf:"bytes,1,rep,name=missions,proto3" json:"missions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Missions) Reset()         { *m = Missions{} }
func (m *Missions) String() string { return proto.CompactTextString(m) }
func (*Missions) ProtoMessage()    {}
func (*Missions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{32}
}
func (m *Missions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Missions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Missions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Missions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Missions.Merge(m, src)
}
func (m *Missions) XXX_Size() int {
	return m.Size()
}
func (m *Missions) XXX_DiscardUnknown() {
	xxx_messageInfo_Missions.DiscardUnknown(m)
}

var xxx_messageInfo_Missions proto.InternalMessageInfo

type ListHallMissionsResp struct {
	MissionMap           map[int32]*Missions            `protobuf:"bytes,1,rep,name=mission_map,json=missionMap,proto3" json:"mission_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ReportedDetailMap    map[int32]*ReportedDetailMap   `protobuf:"bytes,2,rep,name=reported_detail_map,json=reportedDetailMap,proto3" json:"reported_detail_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RequirementMap       map[int32]*RequirementMap      `protobuf:"bytes,3,rep,name=requirement_map,json=requirementMap,proto3" json:"requirement_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	UserMissionStateMap  map[int32]*UserMissionStateMap `protobuf:"bytes,4,rep,name=user_mission_state_map,json=userMissionStateMap,proto3" json:"user_mission_state_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *ListHallMissionsResp) Reset()         { *m = ListHallMissionsResp{} }
func (m *ListHallMissionsResp) String() string { return proto.CompactTextString(m) }
func (*ListHallMissionsResp) ProtoMessage()    {}
func (*ListHallMissionsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{33}
}
func (m *ListHallMissionsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListHallMissionsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListHallMissionsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListHallMissionsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHallMissionsResp.Merge(m, src)
}
func (m *ListHallMissionsResp) XXX_Size() int {
	return m.Size()
}
func (m *ListHallMissionsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHallMissionsResp.DiscardUnknown(m)
}

var xxx_messageInfo_ListHallMissionsResp proto.InternalMessageInfo

type ReceiveHallMissionRewardReq struct {
	AppId                int32    `protobuf:"varint,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	UserId               int64    `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GameId               int32    `protobuf:"varint,3,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	ArenaId              int32    `protobuf:"varint,4,opt,name=arena_id,json=arenaId,proto3" json:"arena_id,omitempty"`
	MissionId            string   `protobuf:"bytes,5,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	GroupId              int32    `protobuf:"varint,6,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReceiveHallMissionRewardReq) Reset()         { *m = ReceiveHallMissionRewardReq{} }
func (m *ReceiveHallMissionRewardReq) String() string { return proto.CompactTextString(m) }
func (*ReceiveHallMissionRewardReq) ProtoMessage()    {}
func (*ReceiveHallMissionRewardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{34}
}
func (m *ReceiveHallMissionRewardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveHallMissionRewardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveHallMissionRewardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReceiveHallMissionRewardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveHallMissionRewardReq.Merge(m, src)
}
func (m *ReceiveHallMissionRewardReq) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveHallMissionRewardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveHallMissionRewardReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveHallMissionRewardReq proto.InternalMessageInfo

type ReceiveHallMissionRewardResp struct {
	PropsList            []*PropsDetails `protobuf:"bytes,1,rep,name=props_list,json=propsList,proto3" json:"props_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ReceiveHallMissionRewardResp) Reset()         { *m = ReceiveHallMissionRewardResp{} }
func (m *ReceiveHallMissionRewardResp) String() string { return proto.CompactTextString(m) }
func (*ReceiveHallMissionRewardResp) ProtoMessage()    {}
func (*ReceiveHallMissionRewardResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{35}
}
func (m *ReceiveHallMissionRewardResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveHallMissionRewardResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveHallMissionRewardResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReceiveHallMissionRewardResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveHallMissionRewardResp.Merge(m, src)
}
func (m *ReceiveHallMissionRewardResp) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveHallMissionRewardResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveHallMissionRewardResp.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveHallMissionRewardResp proto.InternalMessageInfo

type ReportedDetail struct {
	RequirementId        int64    `protobuf:"varint,1,opt,name=requirement_id,json=requirementId,proto3" json:"requirement_id,omitempty"`
	Count                int64    `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportedDetail) Reset()         { *m = ReportedDetail{} }
func (m *ReportedDetail) String() string { return proto.CompactTextString(m) }
func (*ReportedDetail) ProtoMessage()    {}
func (*ReportedDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{36}
}
func (m *ReportedDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportedDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportedDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportedDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportedDetail.Merge(m, src)
}
func (m *ReportedDetail) XXX_Size() int {
	return m.Size()
}
func (m *ReportedDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportedDetail.DiscardUnknown(m)
}

var xxx_messageInfo_ReportedDetail proto.InternalMessageInfo

type ReportedDetails struct {
	ReportedDetails      []*ReportedDetail `protobuf:"bytes,1,rep,name=reported_details,json=reportedDetails,proto3" json:"reported_details,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ReportedDetails) Reset()         { *m = ReportedDetails{} }
func (m *ReportedDetails) String() string { return proto.CompactTextString(m) }
func (*ReportedDetails) ProtoMessage()    {}
func (*ReportedDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{37}
}
func (m *ReportedDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportedDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportedDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportedDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportedDetails.Merge(m, src)
}
func (m *ReportedDetails) XXX_Size() int {
	return m.Size()
}
func (m *ReportedDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportedDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ReportedDetails proto.InternalMessageInfo

type ReportedDetailMap struct {
	ReportedDetailMap    map[string]*ReportedDetails `protobuf:"bytes,1,rep,name=reported_detail_map,json=reportedDetailMap,proto3" json:"reported_detail_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ReportedDetailMap) Reset()         { *m = ReportedDetailMap{} }
func (m *ReportedDetailMap) String() string { return proto.CompactTextString(m) }
func (*ReportedDetailMap) ProtoMessage()    {}
func (*ReportedDetailMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{38}
}
func (m *ReportedDetailMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportedDetailMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportedDetailMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportedDetailMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportedDetailMap.Merge(m, src)
}
func (m *ReportedDetailMap) XXX_Size() int {
	return m.Size()
}
func (m *ReportedDetailMap) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportedDetailMap.DiscardUnknown(m)
}

var xxx_messageInfo_ReportedDetailMap proto.InternalMessageInfo

type ReportedRequirementReq struct {
	AppId                int32             `protobuf:"varint,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	UserId               int64             `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GameId               int32             `protobuf:"varint,3,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	ArenaId              int32             `protobuf:"varint,4,opt,name=arena_id,json=arenaId,proto3" json:"arena_id,omitempty"`
	ReportedDetails      []*ReportedDetail `protobuf:"bytes,5,rep,name=reported_details,json=reportedDetails,proto3" json:"reported_details,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ReportedRequirementReq) Reset()         { *m = ReportedRequirementReq{} }
func (m *ReportedRequirementReq) String() string { return proto.CompactTextString(m) }
func (*ReportedRequirementReq) ProtoMessage()    {}
func (*ReportedRequirementReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{39}
}
func (m *ReportedRequirementReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportedRequirementReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportedRequirementReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportedRequirementReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportedRequirementReq.Merge(m, src)
}
func (m *ReportedRequirementReq) XXX_Size() int {
	return m.Size()
}
func (m *ReportedRequirementReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportedRequirementReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReportedRequirementReq proto.InternalMessageInfo

type ReportedRequirementResp struct {
	IsContinue           bool     `protobuf:"varint,1,opt,name=is_continue,json=isContinue,proto3" json:"is_continue,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportedRequirementResp) Reset()         { *m = ReportedRequirementResp{} }
func (m *ReportedRequirementResp) String() string { return proto.CompactTextString(m) }
func (*ReportedRequirementResp) ProtoMessage()    {}
func (*ReportedRequirementResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{40}
}
func (m *ReportedRequirementResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportedRequirementResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportedRequirementResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportedRequirementResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportedRequirementResp.Merge(m, src)
}
func (m *ReportedRequirementResp) XXX_Size() int {
	return m.Size()
}
func (m *ReportedRequirementResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportedRequirementResp.DiscardUnknown(m)
}

var xxx_messageInfo_ReportedRequirementResp proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("task.service.v1.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterEnum("task.service.v1.LimitType", LimitType_name, LimitType_value)
	proto.RegisterEnum("task.service.v1.ActivityType", ActivityType_name, ActivityType_value)
	proto.RegisterEnum("task.service.v1.UserMissionState", UserMissionState_name, UserMissionState_value)
	proto.RegisterEnum("task.service.v1.Mission_Type", Mission_Type_name, Mission_Type_value)
	proto.RegisterEnum("task.service.v1.Mission_State", Mission_State_name, Mission_State_value)
	proto.RegisterEnum("task.service.v1.Mission_CycleType", Mission_CycleType_name, Mission_CycleType_value)
	proto.RegisterEnum("task.service.v1.Requirement_Type", Requirement_Type_name, Requirement_Type_value)
	proto.RegisterEnum("task.service.v1.Reward_Type", Reward_Type_name, Reward_Type_value)
	proto.RegisterEnum("task.service.v1.Item_Type", Item_Type_name, Item_Type_value)
	proto.RegisterType((*UserDetails)(nil), "task.service.v1.UserDetails")
	proto.RegisterType((*GameEndReq)(nil), "task.service.v1.GameEndReq")
	proto.RegisterType((*ActionDetails)(nil), "task.service.v1.ActionDetails")
	proto.RegisterType((*SpecialActionReq)(nil), "task.service.v1.SpecialActionReq")
	proto.RegisterType((*BuyPropsReq)(nil), "task.service.v1.BuyPropsReq")
	proto.RegisterType((*PayMoneyReq)(nil), "task.service.v1.PayMoneyReq")
	proto.RegisterType((*QueryTaskReq)(nil), "task.service.v1.QueryTaskReq")
	proto.RegisterType((*PropsDetails)(nil), "task.service.v1.PropsDetails")
	proto.RegisterType((*ActivityDetails)(nil), "task.service.v1.ActivityDetails")
	proto.RegisterType((*TaskDetails)(nil), "task.service.v1.TaskDetails")
	proto.RegisterType((*Date)(nil), "task.service.v1.Date")
	proto.RegisterType((*QueryTaskResp)(nil), "task.service.v1.QueryTaskResp")
	proto.RegisterType((*GetTaskRewardReq)(nil), "task.service.v1.GetTaskRewardReq")
	proto.RegisterType((*RewardResp)(nil), "task.service.v1.RewardResp")
	proto.RegisterType((*GetActivityRewardReq)(nil), "task.service.v1.GetActivityRewardReq")
	proto.RegisterType((*GetRandRewardReq)(nil), "task.service.v1.GetRandRewardReq")
	proto.RegisterType((*CommonResp)(nil), "task.service.v1.CommonResp")
	proto.RegisterType((*SpecialActionResp)(nil), "task.service.v1.SpecialActionResp")
	proto.RegisterType((*PushOnLineStatusReq)(nil), "task.service.v1.PushOnLineStatusReq")
	proto.RegisterType((*OnlineDetail)(nil), "task.service.v1.OnlineDetail")
	proto.RegisterType((*GetHallTaskReq)(nil), "task.service.v1.GetHallTaskReq")
	proto.RegisterType((*HallTaskListResp)(nil), "task.service.v1.HallTaskListResp")
	proto.RegisterType((*HallTaskRewardReq)(nil), "task.service.v1.HallTaskRewardReq")
	proto.RegisterType((*Mission)(nil), "task.service.v1.Mission")
	proto.RegisterType((*Groups)(nil), "task.service.v1.Groups")
	proto.RegisterType((*Requirement)(nil), "task.service.v1.Requirement")
	proto.RegisterType((*Requirements)(nil), "task.service.v1.Requirements")
	proto.RegisterType((*RequirementMap)(nil), "task.service.v1.RequirementMap")
	proto.RegisterMapType((map[int64]*Requirement)(nil), "task.service.v1.RequirementMap.RequirementMapEntry")
	proto.RegisterType((*Reward)(nil), "task.service.v1.Reward")
	proto.RegisterType((*Item)(nil), "task.service.v1.Item")
	proto.RegisterType((*UserMissionStateMap)(nil), "task.service.v1.UserMissionStateMap")
	proto.RegisterMapType((map[string]int64)(nil), "task.service.v1.UserMissionStateMap.UserMissionStateMapEntry")
	proto.RegisterType((*ListHallMissionsReq)(nil), "task.service.v1.ListHallMissionsReq")
	proto.RegisterType((*Missions)(nil), "task.service.v1.Missions")
	proto.RegisterType((*ListHallMissionsResp)(nil), "task.service.v1.ListHallMissionsResp")
	proto.RegisterMapType((map[int32]*Missions)(nil), "task.service.v1.ListHallMissionsResp.MissionMapEntry")
	proto.RegisterMapType((map[int32]*ReportedDetailMap)(nil), "task.service.v1.ListHallMissionsResp.ReportedDetailMapEntry")
	proto.RegisterMapType((map[int32]*RequirementMap)(nil), "task.service.v1.ListHallMissionsResp.RequirementMapEntry")
	proto.RegisterMapType((map[int32]*UserMissionStateMap)(nil), "task.service.v1.ListHallMissionsResp.UserMissionStateMapEntry")
	proto.RegisterType((*ReceiveHallMissionRewardReq)(nil), "task.service.v1.ReceiveHallMissionRewardReq")
	proto.RegisterType((*ReceiveHallMissionRewardResp)(nil), "task.service.v1.ReceiveHallMissionRewardResp")
	proto.RegisterType((*ReportedDetail)(nil), "task.service.v1.ReportedDetail")
	proto.RegisterType((*ReportedDetails)(nil), "task.service.v1.ReportedDetails")
	proto.RegisterType((*ReportedDetailMap)(nil), "task.service.v1.ReportedDetailMap")
	proto.RegisterMapType((map[string]*ReportedDetails)(nil), "task.service.v1.ReportedDetailMap.ReportedDetailMapEntry")
	proto.RegisterType((*ReportedRequirementReq)(nil), "task.service.v1.ReportedRequirementReq")
	proto.RegisterType((*ReportedRequirementResp)(nil), "task.service.v1.ReportedRequirementResp")
}

func init() { proto.RegisterFile("api/api.proto", fileDescriptor_1b40cafcd4234784) }

var fileDescriptor_1b40cafcd4234784 = []byte{
	// 3317 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x3a, 0x5b, 0x6f, 0xdc, 0xc6,
	0xd5, 0xe1, 0x5e, 0xa4, 0xdd, 0xb3, 0x5a, 0x89, 0x1a, 0xdd, 0xa8, 0x95, 0x75, 0x31, 0x6d, 0x27,
	0x8a, 0xbf, 0xc4, 0x82, 0x9d, 0xf8, 0x4b, 0xe2, 0xe4, 0xcb, 0x17, 0x47, 0x96, 0x55, 0x05, 0xb6,
	0xe3, 0xd0, 0x76, 0xd2, 0x06, 0x71, 0xb7, 0xd4, 0x72, 0xb4, 0x9a, 0x7a, 0x97, 0x64, 0x48, 0xae,
	0xec, 0x7d, 0x28, 0x02, 0xb4, 0x40, 0x5f, 0xfa, 0x58, 0xa0, 0x28, 0x50, 0xa0, 0xe9, 0x5b, 0x1f,
	0x8b, 0x3e, 0xf7, 0x0f, 0x04, 0xe8, 0x43, 0x5b, 0xf4, 0x2d, 0x7d, 0x49, 0xd3, 0xa2, 0xbf, 0xa3,
	0x98, 0x33, 0x43, 0xee, 0xf0, 0xb2, 0xb6, 0xa4, 0xa4, 0x7d, 0xe3, 0x9c, 0xfb, 0x9c, 0x39, 0x73,
	0xce, 0x99, 0x19, 0x42, 0xd3, 0xf6, 0xd9, 0x96, 0xed, 0xb3, 0x4b, 0x7e, 0xe0, 0x45, 0x1e, 0x99,
	0x89, 0xec, 0xf0, 0xd1, 0xa5, 0x90, 0x06, 0x47, 0xac, 0x43, 0x2f, 0x1d, 0x5d, 0x6e, 0xbd, 0xdc,
	0x65, 0xd1, 0xe1, 0x60, 0xff, 0x52, 0xc7, 0xeb, 0x6f, 0x75, 0xbd, 0xae, 0xb7, 0x85, 0x74, 0xfb,
	0x83, 0x03, 0x1c, 0xe1, 0x00, 0xbf, 0x04, 0x7f, 0xeb, 0x4c, 0xd7, 0xf3, 0xba, 0x3d, 0xba, 0x85,
	0x52, 0x5d, 0xd7, 0x8b, 0xec, 0x88, 0x79, 0x6e, 0x28, 0xb0, 0xe6, 0x07, 0xd0, 0x78, 0x10, 0xd2,
	0xe0, 0x06, 0x8d, 0x6c, 0xd6, 0x0b, 0xc9, 0x12, 0x4c, 0x0e, 0x42, 0x1a, 0xb4, 0x99, 0x63, 0x68,
	0x1b, 0xda, 0x66, 0xd9, 0x9a, 0xe0, 0xc3, 0x3d, 0x87, 0x2c, 0xc0, 0x04, 0x0b, 0xdb, 0x8f, 0x99,
	0x6b, 0x94, 0x36, 0xb4, 0xcd, 0x9a, 0x55, 0x65, 0xe1, 0x47, 0xcc, 0x25, 0x04, 0x2a, 0x81, 0xd7,
	0xa3, 0x46, 0x79, 0x43, 0xdb, 0xac, 0x5a, 0xf8, 0x6d, 0xfe, 0x42, 0x03, 0xd8, 0xb5, 0xfb, 0x74,
	0xc7, 0x75, 0x2c, 0xfa, 0x29, 0x17, 0xd9, 0xb5, 0xfb, 0x34, 0x16, 0x59, 0xb5, 0x26, 0xf8, 0x70,
	0xcf, 0x21, 0xcb, 0x50, 0xb3, 0x03, 0xea, 0xda, 0x1c, 0x53, 0x42, 0xcc, 0x24, 0x8e, 0x05, 0x2a,
	0xb2, 0xf7, 0x7b, 0xc8, 0x24, 0x44, 0x4f, 0xe2, 0x78, 0xcf, 0x21, 0x6f, 0x40, 0x1d, 0x2d, 0xec,
	0xb1, 0x30, 0x32, 0x2a, 0x1b, 0xe5, 0xcd, 0xc6, 0x95, 0x33, 0x97, 0x32, 0x2e, 0xba, 0xa4, 0x4c,
	0xc9, 0xaa, 0x71, 0xf2, 0x5b, 0x2c, 0x8c, 0xcc, 0xab, 0xd0, 0xbc, 0xde, 0xe1, 0x93, 0x8f, 0x67,
	0x4b, 0xa0, 0x12, 0x0d, 0x7d, 0x2a, 0xed, 0xc2, 0x6f, 0xa2, 0x43, 0xd9, 0x1d, 0xf4, 0xa5, 0x41,
	0xfc, 0xd3, 0xfc, 0x8d, 0x06, 0xfa, 0x3d, 0x9f, 0x76, 0x98, 0xdd, 0x13, 0xec, 0x72, 0x56, 0xc5,
	0x8e, 0x52, 0xa6, 0x5b, 0x1a, 0x3b, 0xdd, 0x72, 0x7a, 0xba, 0xff, 0x0f, 0x0d, 0x1b, 0x25, 0xab,
	0xb3, 0x5a, 0xcb, 0xcd, 0x2a, 0x65, 0xbc, 0x05, 0x82, 0x05, 0x67, 0xf6, 0x31, 0x34, 0xde, 0x1d,
	0x0c, 0xef, 0x06, 0x9e, 0x1f, 0x9e, 0xda, 0x38, 0x9f, 0x73, 0x2b, 0xc6, 0xe1, 0x78, 0xcf, 0x31,
	0x1f, 0x40, 0xe3, 0xae, 0x3d, 0xbc, 0xed, 0xb9, 0x74, 0x78, 0x3a, 0xd9, 0xf3, 0x50, 0xed, 0x73,
	0x6e, 0x29, 0x58, 0x0c, 0x4c, 0x0a, 0x53, 0x1f, 0x0c, 0x68, 0x30, 0xbc, 0x6f, 0x87, 0x8f, 0x4e,
	0x27, 0xf7, 0x1c, 0x34, 0xb9, 0x87, 0xda, 0xdc, 0x50, 0x1a, 0x44, 0x42, 0x7e, 0xdd, 0x9a, 0xe2,
	0xc0, 0xbb, 0x12, 0x66, 0xfa, 0x30, 0x85, 0x6e, 0x89, 0x97, 0x7c, 0x1a, 0x4a, 0x49, 0x20, 0x96,
	0x98, 0x93, 0x5f, 0x6e, 0xb2, 0x08, 0x13, 0x8f, 0x29, 0xeb, 0x1e, 0x46, 0xd2, 0x5e, 0x39, 0x4a,
	0x82, 0xa5, 0x82, 0xd6, 0x89, 0x60, 0x21, 0x50, 0x71, 0xed, 0x3e, 0x35, 0xaa, 0xa8, 0x19, 0xbf,
	0xcd, 0xc7, 0x30, 0xc3, 0x17, 0xea, 0x88, 0x45, 0xc3, 0x58, 0xa9, 0x54, 0xa2, 0x8d, 0x94, 0xcc,
	0x43, 0x35, 0x8c, 0xec, 0x88, 0x4a, 0xc5, 0x62, 0x40, 0xde, 0x02, 0x10, 0xab, 0x80, 0x61, 0x50,
	0xc6, 0x30, 0x58, 0xcd, 0x85, 0x81, 0x3a, 0x1f, 0xab, 0x8e, 0x0c, 0x18, 0x04, 0x5f, 0x96, 0xa1,
	0xc1, 0xbd, 0x99, 0x9f, 0x6a, 0x1d, 0xa7, 0xda, 0x12, 0x6b, 0x8c, 0xae, 0x2a, 0x21, 0x34, 0x19,
	0x27, 0x93, 0x13, 0x2e, 0x14, 0x93, 0x33, 0x60, 0x32, 0x0a, 0x58, 0xb7, 0x4b, 0x03, 0x9c, 0x73,
	0xdd, 0x8a, 0x87, 0x1c, 0xd3, 0x19, 0x04, 0x01, 0x75, 0x23, 0x9c, 0x79, 0xd5, 0x8a, 0x87, 0xdc,
	0x79, 0x07, 0xcc, 0x65, 0xe1, 0xa1, 0x31, 0x21, 0x9c, 0x27, 0x46, 0xa3, 0xf9, 0x4e, 0xaa, 0xf3,
	0x9d, 0x87, 0xaa, 0x17, 0x38, 0x34, 0x30, 0x6a, 0x02, 0x8a, 0x83, 0x8c, 0x17, 0xea, 0x27, 0xf3,
	0x42, 0x6a, 0x9b, 0x41, 0x7a, 0x9b, 0xb5, 0xa0, 0x46, 0x8f, 0x68, 0x30, 0x74, 0xec, 0xa1, 0xd1,
	0x40, 0x54, 0x32, 0x26, 0x97, 0xa1, 0x86, 0xbe, 0xe3, 0x36, 0x4e, 0x6d, 0x68, 0x9b, 0x8d, 0x2b,
	0x0b, 0x39, 0x95, 0x1c, 0x69, 0x25, 0x64, 0xe4, 0x3a, 0x4c, 0xbd, 0xef, 0xf6, 0x98, 0x4b, 0x85,
	0x15, 0x46, 0x13, 0xd9, 0xf2, 0x96, 0xaa, 0x44, 0x56, 0x8a, 0x85, 0xbb, 0xfd, 0x06, 0x0d, 0x3b,
	0xc6, 0xb4, 0x70, 0x3b, 0xff, 0xe6, 0x4e, 0xd9, 0xeb, 0xdb, 0x5d, 0x6a, 0xcc, 0x20, 0x50, 0x0c,
	0xcc, 0xb7, 0xa1, 0x82, 0x4a, 0xcf, 0x40, 0xfd, 0x5e, 0x64, 0x07, 0xd1, 0x7d, 0xd6, 0xa7, 0x72,
	0x6d, 0x47, 0x00, 0xbe, 0x30, 0x3b, 0xae, 0x83, 0x38, 0xb1, 0xc2, 0xf1, 0xd0, 0xfc, 0x69, 0x09,
	0x9a, 0xca, 0x7e, 0x0b, 0x7d, 0xae, 0xbb, 0xe3, 0x39, 0x49, 0xf2, 0xe3, 0xdf, 0x9c, 0xbf, 0x4f,
	0xc3, 0x90, 0x6b, 0x97, 0xfc, 0x72, 0xc8, 0x7d, 0xe7, 0x50, 0xdb, 0xe1, 0xb6, 0x63, 0x90, 0x94,
	0xad, 0x64, 0x4c, 0x5e, 0x04, 0x5d, 0xae, 0x7f, 0xdb, 0x96, 0x91, 0x8f, 0x11, 0x53, 0xb5, 0x66,
	0x24, 0x3c, 0xde, 0x10, 0x3c, 0x7b, 0xe3, 0x9e, 0xc5, 0xa5, 0xad, 0x8e, 0xc9, 0xde, 0x4a, 0x10,
	0x5b, 0x35, 0x8e, 0xc4, 0x85, 0xdd, 0x81, 0x66, 0x2c, 0x5d, 0xb0, 0x4f, 0x20, 0xfb, 0x46, 0x61,
	0x9a, 0x54, 0x76, 0x9f, 0x35, 0x15, 0xb3, 0xe1, 0x2e, 0x79, 0x08, 0xfa, 0x2e, 0x8d, 0x84, 0x17,
	0x1e, 0xdb, 0x81, 0x73, 0xba, 0xdc, 0xb3, 0x04, 0x93, 0x38, 0x0f, 0x99, 0x2e, 0xeb, 0xd6, 0x04,
	0x1f, 0xee, 0x39, 0xe6, 0x13, 0x80, 0x58, 0xee, 0x89, 0x7d, 0xfc, 0xcd, 0xb6, 0xbf, 0x03, 0xf3,
	0xbb, 0x34, 0xf1, 0xf4, 0x37, 0x99, 0x5c, 0x0b, 0x6a, 0xc9, 0x3a, 0x8a, 0x1c, 0x98, 0x8c, 0x4d,
	0x86, 0xee, 0xb3, 0x6c, 0x5e, 0xdb, 0x4f, 0xaf, 0xe1, 0x58, 0xa9, 0xfb, 0x1a, 0xc0, 0xb6, 0xd7,
	0xef, 0xf3, 0x7a, 0x7b, 0x52, 0x57, 0x9a, 0xfb, 0x30, 0x9b, 0x29, 0xd9, 0x27, 0x5e, 0x8d, 0x75,
	0x68, 0xb0, 0xb0, 0xdd, 0xf1, 0xdc, 0x88, 0xb9, 0x03, 0x11, 0xf4, 0x35, 0x0b, 0x58, 0xb8, 0x2d,
	0x21, 0xe6, 0x67, 0x30, 0x77, 0x77, 0x10, 0x1e, 0xbe, 0xef, 0xde, 0x62, 0x2e, 0xbd, 0x17, 0xd9,
	0xd1, 0xe0, 0x94, 0xc5, 0x77, 0x05, 0xea, 0x2c, 0x6c, 0x7b, 0x6e, 0xb2, 0xb9, 0x6a, 0x56, 0x8d,
	0x85, 0x22, 0x51, 0xa4, 0xf2, 0x59, 0x25, 0x95, 0xcf, 0x4c, 0x96, 0x4e, 0x40, 0x7c, 0xdd, 0x7a,
	0xf4, 0x60, 0x94, 0x1a, 0xca, 0x56, 0x32, 0x26, 0x6b, 0x00, 0xf7, 0xed, 0xa0, 0x4b, 0xa3, 0x24,
	0x39, 0x94, 0x2d, 0x05, 0x42, 0x56, 0x01, 0x70, 0x45, 0xc2, 0x88, 0xbb, 0x42, 0xac, 0x3a, 0x6e,
	0xd5, 0x7b, 0x1c, 0x60, 0x0e, 0x61, 0x7a, 0x97, 0x46, 0xdf, 0xb1, 0x7b, 0xbd, 0xff, 0x6c, 0xbd,
	0xe6, 0xa5, 0xf2, 0x88, 0xf9, 0x72, 0xa6, 0xfc, 0xd3, 0xfc, 0x5d, 0x09, 0xf4, 0x58, 0x31, 0x0f,
	0xf4, 0x6f, 0x39, 0x79, 0x6d, 0xca, 0x72, 0x4d, 0xdf, 0xa5, 0x5d, 0xe6, 0xa2, 0x77, 0x44, 0xb5,
	0xcb, 0x82, 0xc9, 0x79, 0xd1, 0x3e, 0x1e, 0xd1, 0x38, 0xc5, 0x8a, 0xaa, 0x9f, 0x06, 0x12, 0x13,
	0xa6, 0x04, 0xe0, 0x8e, 0xf7, 0xf8, 0x86, 0x3d, 0x94, 0x75, 0x30, 0x05, 0x1b, 0xd1, 0x88, 0xa8,
	0x91, 0x45, 0x31, 0x05, 0x4b, 0x67, 0xca, 0xda, 0x49, 0x32, 0xa5, 0xe9, 0xc3, 0xec, 0x68, 0xa5,
	0xbe, 0xfd, 0x1c, 0x57, 0xb0, 0x46, 0x7f, 0x03, 0x98, 0xbc, 0xcd, 0xc2, 0x90, 0x79, 0x6e, 0xae,
	0xed, 0x58, 0x80, 0x09, 0xdb, 0xf7, 0x47, 0xe2, 0xab, 0xb6, 0xef, 0xa7, 0xd5, 0x96, 0xc7, 0xf6,
	0xc9, 0xe9, 0x80, 0xe7, 0x5b, 0x32, 0xf4, 0x06, 0x41, 0x87, 0xb6, 0xb1, 0x59, 0x11, 0xbd, 0x07,
	0x08, 0xd0, 0x7d, 0xd9, 0x8f, 0x21, 0x06, 0x0a, 0x7a, 0xb4, 0xc6, 0xa8, 0x47, 0x23, 0x1b, 0xd0,
	0x70, 0x68, 0xd8, 0x09, 0x98, 0xcf, 0x93, 0x03, 0x16, 0xfc, 0xba, 0xa5, 0x82, 0xf8, 0x9e, 0xf4,
	0x6d, 0x2c, 0x69, 0xcc, 0xc1, 0xca, 0xce, 0xbb, 0x25, 0x04, 0xec, 0x39, 0x5c, 0x24, 0xeb, 0x78,
	0x6e, 0x5c, 0xb6, 0xf9, 0x37, 0xd9, 0x80, 0x29, 0x16, 0xb6, 0x5d, 0x4a, 0x9d, 0xf6, 0x0f, 0x3d,
	0xe6, 0x62, 0xf5, 0xc6, 0x7c, 0x71, 0x87, 0x52, 0xe7, 0x3d, 0x8f, 0xb9, 0xe4, 0x79, 0x98, 0x89,
	0x29, 0x02, 0xda, 0xa1, 0xec, 0x88, 0x1a, 0x3a, 0x12, 0x35, 0x05, 0x91, 0x25, 0x80, 0xa3, 0x5e,
	0x69, 0x16, 0x67, 0x91, 0xed, 0x95, 0x88, 0xda, 0x2b, 0x61, 0xdf, 0x4e, 0xdb, 0x11, 0x0f, 0xc7,
	0x79, 0x11, 0xf4, 0x7e, 0x40, 0xe3, 0x1d, 0x1d, 0xf2, 0xc6, 0x40, 0x20, 0x17, 0x44, 0xab, 0x10,
	0x26, 0xad, 0xc2, 0x32, 0xd4, 0xa8, 0xeb, 0x08, 0xe4, 0xa2, 0xe0, 0xa4, 0x32, 0x84, 0x57, 0xa0,
	0xce, 0xb7, 0x87, 0xc0, 0x2d, 0x89, 0xb9, 0x73, 0x00, 0x22, 0xcf, 0x41, 0x33, 0xd6, 0x18, 0x46,
	0x76, 0xdf, 0x37, 0x0c, 0xb4, 0x72, 0x4a, 0xaa, 0x45, 0x18, 0x79, 0x01, 0x66, 0x46, 0xba, 0x05,
	0xd9, 0x32, 0x92, 0x4d, 0x27, 0x06, 0x08, 0xc2, 0x73, 0xd0, 0x8c, 0xad, 0x10, 0x64, 0x2d, 0x21,
	0x4d, 0x9a, 0x22, 0x88, 0x2e, 0xc0, 0x74, 0x62, 0x8f, 0xa0, 0x5a, 0x41, 0xaa, 0x66, 0x6c, 0x94,
	0x20, 0x5b, 0x05, 0xe8, 0x0c, 0x3b, 0x3d, 0x19, 0x1c, 0x6b, 0x48, 0x52, 0x47, 0x08, 0xc6, 0xc6,
	0x3a, 0x34, 0x04, 0x9a, 0xb9, 0x0e, 0x7d, 0x62, 0xac, 0x8b, 0x14, 0x88, 0xa0, 0x3d, 0x0e, 0x21,
	0x5b, 0x30, 0xd1, 0x63, 0x7d, 0x16, 0x85, 0xc6, 0x26, 0x76, 0x72, 0x4b, 0xb9, 0xed, 0xb6, 0x1b,
	0x78, 0x03, 0x3f, 0xb4, 0x24, 0x19, 0x79, 0x0d, 0x40, 0xd6, 0x45, 0x46, 0x43, 0xe3, 0xc5, 0xa7,
	0x33, 0x29, 0xa4, 0xe4, 0x4d, 0x98, 0x0a, 0xe8, 0xa7, 0x03, 0x16, 0xd0, 0x3e, 0x75, 0xa3, 0xd0,
	0xf8, 0x9f, 0xa7, 0xb3, 0xa6, 0x88, 0xc9, 0x65, 0x98, 0x0c, 0x70, 0x57, 0x87, 0xc6, 0x4b, 0x4f,
	0xe7, 0x8b, 0xe9, 0xcc, 0xcf, 0x35, 0xa8, 0xa0, 0x0f, 0xe6, 0x41, 0x97, 0xdb, 0xb4, 0xcd, 0xc7,
	0xed, 0x3b, 0xac, 0xa7, 0x3f, 0x47, 0x16, 0x81, 0xa4, 0xa0, 0xdb, 0xdc, 0x27, 0xba, 0x46, 0x96,
	0x60, 0x2e, 0x4d, 0xed, 0x05, 0x7d, 0xbb, 0xa7, 0x97, 0x0a, 0x10, 0x5c, 0xb3, 0x5e, 0x26, 0x67,
	0xc0, 0x48, 0x21, 0xae, 0x77, 0x0e, 0x19, 0x3d, 0x42, 0xc3, 0xf5, 0x0a, 0x59, 0x86, 0x85, 0x0c,
	0x56, 0x34, 0x15, 0x7a, 0xd5, 0xfc, 0x11, 0x54, 0xef, 0x61, 0x98, 0x2f, 0xc0, 0x6c, 0x4c, 0x83,
	0x00, 0x69, 0x62, 0x0e, 0x7c, 0x37, 0xc8, 0x58, 0x28, 0xc0, 0xd8, 0x0a, 0xeb, 0xa5, 0x3c, 0x3d,
	0x75, 0x1d, 0xbd, 0xac, 0xce, 0x54, 0x80, 0x6f, 0x50, 0xdb, 0xd1, 0x2b, 0xe6, 0xaf, 0x34, 0xa8,
	0x6f, 0x27, 0x91, 0xd2, 0x82, 0xc5, 0x98, 0x0a, 0x81, 0xaa, 0xaf, 0x8a, 0x71, 0x37, 0xec, 0xa1,
	0xae, 0x91, 0x15, 0x58, 0x2a, 0xc0, 0x7d, 0x44, 0xe9, 0x23, 0xbd, 0xa4, 0xba, 0x46, 0x41, 0xde,
	0xf6, 0xdc, 0xe8, 0x50, 0x2f, 0x8f, 0x61, 0xfd, 0x1e, 0xb5, 0x03, 0xbd, 0x62, 0x7e, 0x02, 0x13,
	0x62, 0x45, 0x45, 0x95, 0xe6, 0x35, 0xbb, 0xcd, 0x9c, 0xd0, 0xd0, 0x36, 0xca, 0x3c, 0xc4, 0x05,
	0x64, 0xcf, 0x09, 0xf9, 0xe9, 0xab, 0xe3, 0x0d, 0x78, 0x44, 0x95, 0x10, 0x25, 0x47, 0x7c, 0x43,
	0x77, 0xb9, 0x00, 0xe4, 0xe2, 0x7d, 0x65, 0xd5, 0xaa, 0x21, 0x60, 0xcf, 0x09, 0xcd, 0xdf, 0x6a,
	0xd0, 0xb0, 0x46, 0x01, 0xa6, 0xe4, 0xef, 0x32, 0xe6, 0x6f, 0x02, 0x15, 0x9e, 0x18, 0xe3, 0xa3,
	0x21, 0xff, 0x2e, 0xca, 0xb3, 0xe6, 0x0f, 0x64, 0x8c, 0x19, 0x30, 0xaf, 0x88, 0x53, 0x7d, 0xb7,
	0x0e, 0x2b, 0x39, 0xcc, 0xf6, 0xa0, 0x3f, 0xe8, 0xd9, 0xbc, 0xee, 0xe9, 0x1a, 0x59, 0x85, 0xe5,
	0x3c, 0x81, 0x6c, 0xb7, 0xf4, 0x92, 0xf9, 0x00, 0xa6, 0x2c, 0x75, 0x27, 0xe8, 0x50, 0x1e, 0xb9,
	0x81, 0x7f, 0x9e, 0xce, 0x01, 0x7f, 0xd2, 0x60, 0x5a, 0x91, 0x7b, 0xdb, 0xf6, 0xc9, 0x27, 0x30,
	0xa3, 0xec, 0xb9, 0x76, 0xdf, 0xf6, 0x51, 0x4b, 0xe3, 0xca, 0x2b, 0xb9, 0xbd, 0x96, 0xe6, 0xcc,
	0x0c, 0x77, 0xdc, 0x28, 0x18, 0x5a, 0xd3, 0x41, 0x0a, 0xd8, 0x6a, 0xc3, 0x5c, 0x01, 0x19, 0x9f,
	0xce, 0x23, 0x3a, 0x94, 0x9e, 0xe7, 0x9f, 0xe4, 0x0a, 0x54, 0x8f, 0xec, 0xde, 0x40, 0xf4, 0x33,
	0x45, 0xf5, 0x5f, 0x11, 0x63, 0x09, 0xd2, 0x6b, 0xa5, 0xd7, 0x35, 0xf3, 0xab, 0x09, 0x98, 0x10,
	0x95, 0xbf, 0x68, 0x35, 0x93, 0x83, 0x7e, 0x5c, 0x21, 0x2f, 0xc0, 0x74, 0x60, 0xbb, 0x8e, 0xd7,
	0x6f, 0x8b, 0xab, 0x8e, 0xd0, 0x00, 0xf4, 0x5e, 0x53, 0x40, 0x3f, 0x12, 0x40, 0x9e, 0x40, 0x25,
	0x19, 0xef, 0x2a, 0x8d, 0x06, 0xd2, 0x80, 0x00, 0xdd, 0xa2, 0x07, 0x11, 0x39, 0x0b, 0x53, 0x92,
	0x20, 0xc0, 0xfb, 0x93, 0x29, 0xa4, 0x90, 0x4c, 0x16, 0x5e, 0xa2, 0x3c, 0x0f, 0x33, 0x92, 0x84,
	0x45, 0xb4, 0x8f, 0xcb, 0xd1, 0x54, 0x75, 0xed, 0x45, 0xb4, 0xcf, 0x23, 0x79, 0x05, 0xea, 0x47,
	0xcc, 0x6f, 0x07, 0xb6, 0xdb, 0xa5, 0xc6, 0x34, 0x52, 0xd4, 0x8e, 0x98, 0x6f, 0xf1, 0x31, 0x6f,
	0xf4, 0x0e, 0xec, 0x4e, 0xe4, 0x05, 0x43, 0x63, 0x66, 0xa3, 0xbc, 0xa9, 0x59, 0xf1, 0x90, 0xbc,
	0x09, 0xad, 0x81, 0x9b, 0x1c, 0x42, 0xdb, 0x99, 0x59, 0xcd, 0xa3, 0x9c, 0xa5, 0x81, 0x9b, 0x1c,
	0x92, 0x52, 0xf3, 0xbb, 0x0a, 0x4b, 0x05, 0xcc, 0x38, 0xd7, 0x05, 0xe4, 0x9c, 0xcf, 0x72, 0xe2,
	0xac, 0x5f, 0x03, 0xa3, 0x80, 0x4d, 0x78, 0x60, 0x11, 0xf9, 0x16, 0xb2, 0x7c, 0xc2, 0x17, 0x6f,
	0xc1, 0x4a, 0x01, 0x63, 0xe2, 0x97, 0xa5, 0x62, 0x6b, 0x63, 0x0f, 0x5d, 0x86, 0x05, 0x95, 0x7b,
	0xe4, 0x2d, 0x03, 0xf9, 0xc8, 0x88, 0xef, 0xc3, 0xd8, 0x6f, 0x97, 0x60, 0x4e, 0x65, 0x89, 0x7d,
	0xb8, 0x8c, 0x3e, 0x9c, 0x1d, 0x31, 0xdc, 0x94, 0xde, 0x3c, 0x0f, 0xd3, 0x07, 0xec, 0x09, 0x75,
	0x46, 0x36, 0xad, 0xa1, 0xec, 0x29, 0x84, 0xc6, 0x86, 0x5c, 0x84, 0x59, 0x85, 0x4a, 0x6e, 0xbf,
	0x75, 0x24, 0x9c, 0x49, 0x08, 0xb7, 0xc5, 0x3e, 0xbc, 0x96, 0x5e, 0x9f, 0x8c, 0xf4, 0x4d, 0x64,
	0x5a, 0x54, 0x0c, 0x51, 0xf5, 0xbc, 0x03, 0xab, 0x63, 0x78, 0xa5, 0xce, 0x17, 0x91, 0x7d, 0xb9,
	0x80, 0x5d, 0x68, 0x37, 0xdf, 0x93, 0x19, 0x6a, 0x0e, 0x66, 0xc4, 0xee, 0x50, 0x93, 0xd3, 0x02,
	0xcc, 0xaa, 0x40, 0xe4, 0xd5, 0x35, 0x5e, 0x31, 0x54, 0xb0, 0x58, 0x03, 0xbd, 0x64, 0xfe, 0x5a,
	0x83, 0x0a, 0x17, 0x5d, 0xb4, 0xc1, 0xb0, 0xdd, 0x2c, 0x29, 0xed, 0x66, 0xc1, 0xa6, 0x33, 0xbf,
	0x2f, 0x8d, 0x99, 0x85, 0x26, 0x97, 0xa3, 0x9a, 0x42, 0x60, 0x7a, 0x04, 0xda, 0xf6, 0x98, 0xab,
	0x6b, 0xbc, 0x76, 0x8e, 0x60, 0x3b, 0x4f, 0x22, 0xde, 0x35, 0x21, 0xaa, 0xc4, 0x8b, 0xfa, 0x08,
	0x75, 0x9f, 0x75, 0x1e, 0xd1, 0x48, 0x2f, 0x9b, 0x7f, 0xd1, 0x60, 0xee, 0x41, 0x48, 0x03, 0x59,
	0x56, 0xb0, 0xdc, 0xf1, 0xd4, 0x16, 0xc0, 0x22, 0x9e, 0x03, 0xfa, 0xb2, 0xdc, 0x60, 0x77, 0xa9,
	0x64, 0xb8, 0xff, 0x2b, 0xbc, 0x4c, 0xcf, 0x48, 0x29, 0x82, 0x89, 0x5c, 0x37, 0x37, 0xc8, 0x63,
	0x5a, 0x37, 0xc1, 0x18, 0xc7, 0xa0, 0x66, 0xbd, 0xba, 0xc8, 0x7a, 0xf3, 0x6a, 0xd6, 0x2b, 0xab,
	0x79, 0xed, 0x27, 0x1a, 0xcc, 0xf1, 0x13, 0x0e, 0x3f, 0xdd, 0x48, 0x61, 0x78, 0xe4, 0x1e, 0x1d,
	0x31, 0xb4, 0xcc, 0x11, 0x23, 0x3e, 0xf2, 0x94, 0x52, 0x47, 0x9e, 0x65, 0xa8, 0xc9, 0xb3, 0x47,
	0x5c, 0x0d, 0x26, 0xc5, 0xe1, 0x23, 0xe4, 0x39, 0x2c, 0xf6, 0x8c, 0x72, 0xdb, 0xdb, 0x90, 0x30,
	0xee, 0x62, 0xf3, 0x1d, 0xa8, 0xc5, 0xca, 0xc9, 0xab, 0x50, 0x93, 0xa8, 0x50, 0xfa, 0xcf, 0xc8,
	0xf9, 0x4f, 0x12, 0x5b, 0x09, 0xa5, 0xf9, 0xc7, 0x09, 0x98, 0xcf, 0xcf, 0x23, 0xf4, 0xc9, 0x87,
	0x10, 0x6b, 0x52, 0x56, 0xe4, 0x6a, 0x4e, 0x62, 0x11, 0x6f, 0xac, 0x26, 0x59, 0x09, 0xe8, 0x27,
	0x00, 0xd2, 0x83, 0xb9, 0x80, 0xfa, 0x5e, 0x10, 0x51, 0xa7, 0xed, 0xe0, 0x79, 0x11, 0xe5, 0x97,
	0x50, 0xfe, 0x5b, 0xc7, 0x93, 0x6f, 0x49, 0x01, 0xe2, 0xbc, 0x99, 0xa8, 0x99, 0x0d, 0xb2, 0x70,
	0xb2, 0x9f, 0xaf, 0x9e, 0xe2, 0x32, 0xeb, 0x8d, 0xe3, 0x6a, 0x7a, 0x66, 0x0d, 0x25, 0xe1, 0xd8,
	0x30, 0x16, 0xaf, 0x27, 0x6f, 0x1f, 0x4f, 0xd5, 0xc9, 0xe2, 0xf8, 0xbb, 0x30, 0x93, 0xf1, 0xb2,
	0x1a, 0xbe, 0x55, 0x11, 0xbe, 0x5b, 0xe9, 0xa2, 0xbd, 0x3c, 0x2e, 0x1e, 0x42, 0x25, 0xb2, 0x5b,
	0x87, 0xb0, 0x58, 0xec, 0xdf, 0x02, 0x05, 0xaf, 0xa7, 0x15, 0x98, 0x05, 0x5d, 0x41, 0x46, 0x92,
	0xaa, 0x69, 0xff, 0x99, 0xcd, 0x87, 0x54, 0x73, 0x35, 0xad, 0x66, 0xfd, 0x19, 0x9d, 0x8f, 0xaa,
	0xa3, 0x77, 0xbc, 0xfd, 0x2e, 0x15, 0x5d, 0x4b, 0x2b, 0x3a, 0x7f, 0x9c, 0x04, 0xa4, 0x66, 0x85,
	0x3f, 0x68, 0xbc, 0xaf, 0xc4, 0xb3, 0xb3, 0xb2, 0xbe, 0xa3, 0x9b, 0x8f, 0x93, 0x66, 0x87, 0xd3,
	0xdc, 0x4c, 0xac, 0x42, 0xbc, 0xdd, 0x38, 0x52, 0x5c, 0x0c, 0xd5, 0x25, 0x44, 0x26, 0x1c, 0xd9,
	0x7f, 0xca, 0x0b, 0xa1, 0x49, 0xd9, 0x7e, 0x9a, 0x9f, 0xc0, 0x99, 0xf1, 0xc6, 0x87, 0x7e, 0xe6,
	0x52, 0x58, 0x3b, 0xe1, 0xa5, 0xf0, 0x6d, 0xde, 0xda, 0xaa, 0xd1, 0x80, 0xcd, 0x9e, 0xb2, 0x39,
	0x93, 0xda, 0xd5, 0x54, 0xa0, 0xe2, 0xd1, 0x0e, 0xcb, 0x6a, 0x9c, 0x84, 0x71, 0x60, 0x3e, 0xe4,
	0x95, 0x53, 0x15, 0x17, 0x92, 0xf7, 0x40, 0xcf, 0xa4, 0x96, 0x38, 0x13, 0xae, 0x3f, 0x23, 0x30,
	0xad, 0x99, 0x74, 0xea, 0x08, 0xcd, 0x7f, 0x69, 0xbc, 0x08, 0x67, 0xd3, 0x09, 0x2b, 0x4e, 0x5e,
	0xda, 0x98, 0x94, 0x92, 0x13, 0x70, 0xfc, 0xcc, 0xd5, 0x3a, 0x38, 0xce, 0x36, 0x94, 0x65, 0xea,
	0x7f, 0xd3, 0x61, 0xbb, 0xf1, 0x0c, 0x43, 0xd4, 0xed, 0x6e, 0x7e, 0xa1, 0x8d, 0x14, 0xa9, 0x3d,
	0xfc, 0x7f, 0x29, 0x5a, 0x8b, 0xd6, 0xac, 0x7a, 0xca, 0x35, 0xbb, 0x06, 0x4b, 0x85, 0x33, 0x09,
	0xfd, 0xec, 0x0d, 0xba, 0x96, 0xbd, 0x41, 0xbf, 0xf8, 0x55, 0x09, 0x26, 0x77, 0x82, 0x60, 0xdb,
	0x73, 0x78, 0x8f, 0x34, 0xbd, 0x13, 0x04, 0x5e, 0xd0, 0xe6, 0x23, 0xd9, 0x08, 0xad, 0xc2, 0xb2,
	0x02, 0xdb, 0xeb, 0xf5, 0x68, 0xd7, 0xee, 0xb5, 0xef, 0xda, 0x81, 0xdd, 0x0f, 0xc5, 0x79, 0x5b,
	0x41, 0xe3, 0xd6, 0x71, 0xbb, 0xd8, 0x06, 0xe9, 0x15, 0x72, 0x16, 0x56, 0x15, 0x24, 0x9e, 0x9f,
	0xf9, 0x59, 0xf2, 0x80, 0x75, 0xdb, 0x08, 0xd7, 0xab, 0x64, 0x03, 0xce, 0xa8, 0xe2, 0x79, 0x0f,
	0x95, 0xa2, 0x98, 0x20, 0xe7, 0x60, 0x3d, 0xab, 0x81, 0x9f, 0xd0, 0x55, 0xa2, 0x49, 0x62, 0xc2,
	0x9a, 0x42, 0x74, 0x8b, 0xf5, 0x59, 0xd4, 0xbe, 0xe3, 0x45, 0xed, 0x7b, 0x76, 0xc4, 0xc2, 0x03,
	0x46, 0x1d, 0xfd, 0x0a, 0x79, 0x09, 0x36, 0x0b, 0x04, 0x71, 0xaa, 0x9b, 0xf8, 0x40, 0x4a, 0x9d,
	0xf6, 0xfb, 0x41, 0x7b, 0xc7, 0x75, 0xa8, 0xa3, 0xbf, 0x42, 0x36, 0xe1, 0x7c, 0x01, 0xb5, 0xec,
	0x43, 0x77, 0x03, 0xdb, 0x8d, 0xda, 0x37, 0x6d, 0xd6, 0xd3, 0x5f, 0xe5, 0x47, 0x6a, 0x85, 0xf2,
	0x7a, 0x2f, 0xa0, 0xb6, 0x33, 0x6c, 0xcb, 0x84, 0xe2, 0xe8, 0x57, 0x2f, 0x7e, 0xae, 0x41, 0x1d,
	0x4d, 0x92, 0xf7, 0xa3, 0xd3, 0xc2, 0xbe, 0x74, 0xb7, 0xa9, 0xc0, 0x3e, 0x64, 0xbe, 0xb8, 0x57,
	0x51, 0x60, 0xc9, 0x3d, 0x4d, 0x89, 0xb7, 0xa1, 0x0a, 0x62, 0x97, 0x07, 0x1e, 0x36, 0xd7, 0x7a,
	0x99, 0xb4, 0x60, 0x51, 0x41, 0xdd, 0xb6, 0xa3, 0xce, 0xa1, 0xc4, 0x55, 0x32, 0x38, 0x71, 0x5d,
	0xd4, 0xde, 0x65, 0x07, 0x91, 0x5e, 0xbd, 0xb8, 0x2f, 0x2f, 0xc3, 0x59, 0x34, 0x44, 0x1b, 0x17,
	0x60, 0x36, 0x1e, 0xab, 0x66, 0x9e, 0x01, 0x23, 0x0d, 0x56, 0x94, 0xe3, 0xcd, 0x41, 0x1a, 0xab,
	0xea, 0x2f, 0x5d, 0xfc, 0xbd, 0x06, 0x7a, 0xb6, 0x8a, 0x70, 0xa3, 0x38, 0xac, 0x9d, 0xbe, 0x11,
	0x72, 0x63, 0x6d, 0x05, 0xb8, 0x5d, 0x8f, 0xb9, 0x5d, 0x5d, 0xe3, 0x5e, 0x2f, 0xc0, 0xc6, 0x2b,
	0xa9, 0x97, 0x78, 0xf0, 0x15, 0x10, 0x3c, 0x70, 0x13, 0x92, 0xf2, 0x18, 0x19, 0xc9, 0xca, 0x55,
	0xae, 0x7c, 0xd9, 0x84, 0xca, 0x7d, 0x3b, 0x7c, 0x44, 0x3e, 0x86, 0x49, 0xf9, 0x3b, 0x0d, 0x59,
	0xc9, 0x5f, 0xf5, 0x25, 0x3f, 0xda, 0xb4, 0xf2, 0xc8, 0xd1, 0xf3, 0x99, 0xb9, 0xf0, 0xe3, 0xbf,
	0xfe, 0xf3, 0xe7, 0xa5, 0x19, 0xb3, 0xb9, 0xc5, 0x89, 0xb6, 0x62, 0x81, 0x21, 0x34, 0x53, 0xef,
	0x64, 0xe4, 0x6c, 0x4e, 0x48, 0xf6, 0xd7, 0x97, 0x96, 0xf9, 0x2c, 0x92, 0xd0, 0x37, 0x57, 0x50,
	0xdd, 0x82, 0x39, 0x27, 0xd4, 0xa5, 0x75, 0x3c, 0x84, 0x5a, 0xfc, 0xb7, 0x0a, 0xc9, 0xdf, 0x69,
	0x28, 0x3f, 0xb2, 0x3c, 0x7d, 0x4a, 0x8b, 0xa8, 0x43, 0x37, 0xa7, 0x85, 0x8e, 0x44, 0xe4, 0x43,
	0xa8, 0xc5, 0x3f, 0xac, 0x14, 0x88, 0x57, 0xfe, 0x65, 0x39, 0x91, 0xf8, 0x44, 0x64, 0x17, 0x1a,
	0xf2, 0x01, 0x19, 0x9f, 0xa5, 0xf3, 0xb5, 0x58, 0xfd, 0xad, 0xa5, 0xb5, 0xf6, 0x34, 0x74, 0xe8,
	0x9b, 0xcb, 0xa8, 0x65, 0xce, 0x9c, 0x95, 0xeb, 0xa2, 0x48, 0xf6, 0x60, 0x46, 0x3e, 0xb5, 0x7e,
	0x5b, 0xca, 0x56, 0x51, 0xd9, 0x92, 0xb9, 0x90, 0x28, 0x4b, 0x49, 0xef, 0x41, 0x33, 0xf5, 0x34,
	0x5e, 0x10, 0x0c, 0xd9, 0xa7, 0xf3, 0x02, 0x17, 0x8e, 0x7a, 0x97, 0x6c, 0x14, 0xa4, 0x85, 0x3f,
	0x81, 0xd9, 0xdc, 0x7b, 0x35, 0xb9, 0x50, 0xa4, 0x31, 0xf7, 0xa6, 0xfd, 0x74, 0xad, 0xeb, 0xa8,
	0x75, 0xd9, 0x5c, 0x4a, 0xb4, 0x66, 0x94, 0x88, 0x79, 0x8e, 0xde, 0xb0, 0x8b, 0xe7, 0x99, 0x7a,
	0xe3, 0x3e, 0xe9, 0x3c, 0x15, 0xe1, 0x03, 0xd0, 0xb3, 0xcf, 0xc4, 0x24, 0xdf, 0xe3, 0x16, 0xbc,
	0x24, 0x3f, 0x3d, 0x3c, 0xd7, 0x50, 0xa7, 0x61, 0x2e, 0xca, 0xf0, 0xcc, 0xaa, 0x88, 0x30, 0x7a,
	0xd4, 0x87, 0x53, 0xb2, 0x5e, 0x34, 0x4d, 0xe5, 0x4d, 0xb7, 0x95, 0xf7, 0x43, 0xf6, 0xe1, 0xb5,
	0x20, 0x84, 0x52, 0x2a, 0x06, 0xb8, 0xa8, 0xe9, 0xd7, 0x47, 0x62, 0x8e, 0x15, 0x7b, 0xea, 0x15,
	0xcd, 0x68, 0xf8, 0x0c, 0xf4, 0xec, 0xf1, 0xae, 0xc0, 0xc7, 0x05, 0x57, 0x07, 0xad, 0x0b, 0xc7,
	0x3a, 0x27, 0x66, 0xbd, 0x9d, 0x53, 0xf6, 0xb9, 0x06, 0xc6, 0xb8, 0x36, 0x9e, 0xbc, 0x54, 0x30,
	0xb7, 0xb1, 0xc7, 0x95, 0xd6, 0xcb, 0x27, 0xa0, 0x0e, 0x7d, 0xf3, 0x79, 0xb4, 0x6c, 0xc3, 0x5c,
	0x13, 0x96, 0x8d, 0x35, 0xe2, 0x67, 0x1a, 0x3f, 0xf8, 0xe5, 0x1a, 0x35, 0xf2, 0xc2, 0xd8, 0x8e,
	0x2f, 0xdd, 0x98, 0xb6, 0x36, 0x8f, 0x47, 0x18, 0xfa, 0xe6, 0x59, 0x34, 0x69, 0xc5, 0x5c, 0x8e,
	0x4d, 0xca, 0x91, 0xbd, 0xbb, 0xfc, 0xc5, 0xdf, 0xd7, 0x9e, 0xfb, 0xe2, 0xeb, 0x35, 0xed, 0xcf,
	0x5f, 0xaf, 0x69, 0x5f, 0x7d, 0xbd, 0xa6, 0xfd, 0xf2, 0x1f, 0x6b, 0xcf, 0x7d, 0x5c, 0xb6, 0x7d,
	0xb6, 0x3f, 0x81, 0x3f, 0xa6, 0xbe, 0xf2, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x08, 0x92, 0x44,
	0xf0, 0x07, 0x2b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TaskClient is the client API for Task service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TaskClient interface {
	//一局结束上报
	GameEnd(ctx context.Context, in *GameEndReq, opts ...grpc.CallOption) (*CommonResp, error)
	//特殊动作上报 ， 棋牌打出 飞机 连队等 捕鱼 捕获特定的鱼等
	SpecialAction(ctx context.Context, in *SpecialActionReq, opts ...grpc.CallOption) (*SpecialActionResp, error)
	//购买道具上报
	BuyProps(ctx context.Context, in *BuyPropsReq, opts ...grpc.CallOption) (*CommonResp, error)
	//充值上报
	PayMoney(ctx context.Context, in *PayMoneyReq, opts ...grpc.CallOption) (*CommonResp, error)
	//获取任务列表
	GetTaskList(ctx context.Context, in *QueryTaskReq, opts ...grpc.CallOption) (*QueryTaskResp, error)
	//获取随机任务列表，目前海外地鼠在用
	GetRandTaskList(ctx context.Context, in *QueryTaskReq, opts ...grpc.CallOption) (*QueryTaskResp, error)
	//获取普通任务奖励
	GetTaskReward(ctx context.Context, in *GetTaskRewardReq, opts ...grpc.CallOption) (*RewardResp, error)
	//获取活跃度奖励
	GetActivityReward(ctx context.Context, in *GetActivityRewardReq, opts ...grpc.CallOption) (*RewardResp, error)
	//获取随机任务奖励，通过根据权重抽取
	GetRandReward(ctx context.Context, in *GetRandRewardReq, opts ...grpc.CallOption) (*RewardResp, error)
	//在线时长 推送用户上下线
	PushOnLineStatus(ctx context.Context, in *PushOnLineStatusReq, opts ...grpc.CallOption) (*CommonResp, error)
	//大厅任务列表获取
	GetHallTaskList(ctx context.Context, in *GetHallTaskReq, opts ...grpc.CallOption) (*HallTaskListResp, error)
	//大厅任务奖励获取
	GetHallTaskReward(ctx context.Context, in *HallTaskRewardReq, opts ...grpc.CallOption) (*RewardResp, error)
	ListHallMissions(ctx context.Context, in *ListHallMissionsReq, opts ...grpc.CallOption) (*ListHallMissionsResp, error)
	ReceiveHallMissionReward(ctx context.Context, in *ReceiveHallMissionRewardReq, opts ...grpc.CallOption) (*ReceiveHallMissionRewardResp, error)
	ReportedRequirement(ctx context.Context, in *ReportedRequirementReq, opts ...grpc.CallOption) (*ReportedRequirementResp, error)
}

type taskClient struct {
	cc *grpc.ClientConn
}

func NewTaskClient(cc *grpc.ClientConn) TaskClient {
	return &taskClient{cc}
}

func (c *taskClient) GameEnd(ctx context.Context, in *GameEndReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/GameEnd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) SpecialAction(ctx context.Context, in *SpecialActionReq, opts ...grpc.CallOption) (*SpecialActionResp, error) {
	out := new(SpecialActionResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/SpecialAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) BuyProps(ctx context.Context, in *BuyPropsReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/BuyProps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) PayMoney(ctx context.Context, in *PayMoneyReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/PayMoney", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) GetTaskList(ctx context.Context, in *QueryTaskReq, opts ...grpc.CallOption) (*QueryTaskResp, error) {
	out := new(QueryTaskResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/GetTaskList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) GetRandTaskList(ctx context.Context, in *QueryTaskReq, opts ...grpc.CallOption) (*QueryTaskResp, error) {
	out := new(QueryTaskResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/GetRandTaskList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) GetTaskReward(ctx context.Context, in *GetTaskRewardReq, opts ...grpc.CallOption) (*RewardResp, error) {
	out := new(RewardResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/GetTaskReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) GetActivityReward(ctx context.Context, in *GetActivityRewardReq, opts ...grpc.CallOption) (*RewardResp, error) {
	out := new(RewardResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/GetActivityReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) GetRandReward(ctx context.Context, in *GetRandRewardReq, opts ...grpc.CallOption) (*RewardResp, error) {
	out := new(RewardResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/GetRandReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) PushOnLineStatus(ctx context.Context, in *PushOnLineStatusReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/PushOnLineStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) GetHallTaskList(ctx context.Context, in *GetHallTaskReq, opts ...grpc.CallOption) (*HallTaskListResp, error) {
	out := new(HallTaskListResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/GetHallTaskList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) GetHallTaskReward(ctx context.Context, in *HallTaskRewardReq, opts ...grpc.CallOption) (*RewardResp, error) {
	out := new(RewardResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/GetHallTaskReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) ListHallMissions(ctx context.Context, in *ListHallMissionsReq, opts ...grpc.CallOption) (*ListHallMissionsResp, error) {
	out := new(ListHallMissionsResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/ListHallMissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) ReceiveHallMissionReward(ctx context.Context, in *ReceiveHallMissionRewardReq, opts ...grpc.CallOption) (*ReceiveHallMissionRewardResp, error) {
	out := new(ReceiveHallMissionRewardResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/ReceiveHallMissionReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskClient) ReportedRequirement(ctx context.Context, in *ReportedRequirementReq, opts ...grpc.CallOption) (*ReportedRequirementResp, error) {
	out := new(ReportedRequirementResp)
	err := c.cc.Invoke(ctx, "/task.service.v1.Task/ReportedRequirement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskServer is the server API for Task service.
type TaskServer interface {
	//一局结束上报
	GameEnd(context.Context, *GameEndReq) (*CommonResp, error)
	//特殊动作上报 ， 棋牌打出 飞机 连队等 捕鱼 捕获特定的鱼等
	SpecialAction(context.Context, *SpecialActionReq) (*SpecialActionResp, error)
	//购买道具上报
	BuyProps(context.Context, *BuyPropsReq) (*CommonResp, error)
	//充值上报
	PayMoney(context.Context, *PayMoneyReq) (*CommonResp, error)
	//获取任务列表
	GetTaskList(context.Context, *QueryTaskReq) (*QueryTaskResp, error)
	//获取随机任务列表，目前海外地鼠在用
	GetRandTaskList(context.Context, *QueryTaskReq) (*QueryTaskResp, error)
	//获取普通任务奖励
	GetTaskReward(context.Context, *GetTaskRewardReq) (*RewardResp, error)
	//获取活跃度奖励
	GetActivityReward(context.Context, *GetActivityRewardReq) (*RewardResp, error)
	//获取随机任务奖励，通过根据权重抽取
	GetRandReward(context.Context, *GetRandRewardReq) (*RewardResp, error)
	//在线时长 推送用户上下线
	PushOnLineStatus(context.Context, *PushOnLineStatusReq) (*CommonResp, error)
	//大厅任务列表获取
	GetHallTaskList(context.Context, *GetHallTaskReq) (*HallTaskListResp, error)
	//大厅任务奖励获取
	GetHallTaskReward(context.Context, *HallTaskRewardReq) (*RewardResp, error)
	ListHallMissions(context.Context, *ListHallMissionsReq) (*ListHallMissionsResp, error)
	ReceiveHallMissionReward(context.Context, *ReceiveHallMissionRewardReq) (*ReceiveHallMissionRewardResp, error)
	ReportedRequirement(context.Context, *ReportedRequirementReq) (*ReportedRequirementResp, error)
}

// UnimplementedTaskServer can be embedded to have forward compatible implementations.
type UnimplementedTaskServer struct {
}

func (*UnimplementedTaskServer) GameEnd(ctx context.Context, req *GameEndReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GameEnd not implemented")
}
func (*UnimplementedTaskServer) SpecialAction(ctx context.Context, req *SpecialActionReq) (*SpecialActionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpecialAction not implemented")
}
func (*UnimplementedTaskServer) BuyProps(ctx context.Context, req *BuyPropsReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuyProps not implemented")
}
func (*UnimplementedTaskServer) PayMoney(ctx context.Context, req *PayMoneyReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PayMoney not implemented")
}
func (*UnimplementedTaskServer) GetTaskList(ctx context.Context, req *QueryTaskReq) (*QueryTaskResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTaskList not implemented")
}
func (*UnimplementedTaskServer) GetRandTaskList(ctx context.Context, req *QueryTaskReq) (*QueryTaskResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRandTaskList not implemented")
}
func (*UnimplementedTaskServer) GetTaskReward(ctx context.Context, req *GetTaskRewardReq) (*RewardResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTaskReward not implemented")
}
func (*UnimplementedTaskServer) GetActivityReward(ctx context.Context, req *GetActivityRewardReq) (*RewardResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActivityReward not implemented")
}
func (*UnimplementedTaskServer) GetRandReward(ctx context.Context, req *GetRandRewardReq) (*RewardResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRandReward not implemented")
}
func (*UnimplementedTaskServer) PushOnLineStatus(ctx context.Context, req *PushOnLineStatusReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushOnLineStatus not implemented")
}
func (*UnimplementedTaskServer) GetHallTaskList(ctx context.Context, req *GetHallTaskReq) (*HallTaskListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHallTaskList not implemented")
}
func (*UnimplementedTaskServer) GetHallTaskReward(ctx context.Context, req *HallTaskRewardReq) (*RewardResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHallTaskReward not implemented")
}
func (*UnimplementedTaskServer) ListHallMissions(ctx context.Context, req *ListHallMissionsReq) (*ListHallMissionsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListHallMissions not implemented")
}
func (*UnimplementedTaskServer) ReceiveHallMissionReward(ctx context.Context, req *ReceiveHallMissionRewardReq) (*ReceiveHallMissionRewardResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveHallMissionReward not implemented")
}
func (*UnimplementedTaskServer) ReportedRequirement(ctx context.Context, req *ReportedRequirementReq) (*ReportedRequirementResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportedRequirement not implemented")
}

func RegisterTaskServer(s *grpc.Server, srv TaskServer) {
	s.RegisterService(&_Task_serviceDesc, srv)
}

func _Task_GameEnd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameEndReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).GameEnd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/GameEnd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).GameEnd(ctx, req.(*GameEndReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_SpecialAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecialActionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).SpecialAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/SpecialAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).SpecialAction(ctx, req.(*SpecialActionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_BuyProps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyPropsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).BuyProps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/BuyProps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).BuyProps(ctx, req.(*BuyPropsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_PayMoney_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PayMoneyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).PayMoney(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/PayMoney",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).PayMoney(ctx, req.(*PayMoneyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_GetTaskList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTaskReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).GetTaskList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/GetTaskList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).GetTaskList(ctx, req.(*QueryTaskReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_GetRandTaskList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTaskReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).GetRandTaskList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/GetRandTaskList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).GetRandTaskList(ctx, req.(*QueryTaskReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_GetTaskReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskRewardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).GetTaskReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/GetTaskReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).GetTaskReward(ctx, req.(*GetTaskRewardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_GetActivityReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActivityRewardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).GetActivityReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/GetActivityReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).GetActivityReward(ctx, req.(*GetActivityRewardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_GetRandReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRandRewardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).GetRandReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/GetRandReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).GetRandReward(ctx, req.(*GetRandRewardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_PushOnLineStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushOnLineStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).PushOnLineStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/PushOnLineStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).PushOnLineStatus(ctx, req.(*PushOnLineStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_GetHallTaskList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHallTaskReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).GetHallTaskList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/GetHallTaskList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).GetHallTaskList(ctx, req.(*GetHallTaskReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_GetHallTaskReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HallTaskRewardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).GetHallTaskReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/GetHallTaskReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).GetHallTaskReward(ctx, req.(*HallTaskRewardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_ListHallMissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHallMissionsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).ListHallMissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/ListHallMissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).ListHallMissions(ctx, req.(*ListHallMissionsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_ReceiveHallMissionReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiveHallMissionRewardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).ReceiveHallMissionReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/ReceiveHallMissionReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).ReceiveHallMissionReward(ctx, req.(*ReceiveHallMissionRewardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Task_ReportedRequirement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportedRequirementReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServer).ReportedRequirement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/task.service.v1.Task/ReportedRequirement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServer).ReportedRequirement(ctx, req.(*ReportedRequirementReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Task_serviceDesc = grpc.ServiceDesc{
	ServiceName: "task.service.v1.Task",
	HandlerType: (*TaskServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GameEnd",
			Handler:    _Task_GameEnd_Handler,
		},
		{
			MethodName: "SpecialAction",
			Handler:    _Task_SpecialAction_Handler,
		},
		{
			MethodName: "BuyProps",
			Handler:    _Task_BuyProps_Handler,
		},
		{
			MethodName: "PayMoney",
			Handler:    _Task_PayMoney_Handler,
		},
		{
			MethodName: "GetTaskList",
			Handler:    _Task_GetTaskList_Handler,
		},
		{
			MethodName: "GetRandTaskList",
			Handler:    _Task_GetRandTaskList_Handler,
		},
		{
			MethodName: "GetTaskReward",
			Handler:    _Task_GetTaskReward_Handler,
		},
		{
			MethodName: "GetActivityReward",
			Handler:    _Task_GetActivityReward_Handler,
		},
		{
			MethodName: "GetRandReward",
			Handler:    _Task_GetRandReward_Handler,
		},
		{
			MethodName: "PushOnLineStatus",
			Handler:    _Task_PushOnLineStatus_Handler,
		},
		{
			MethodName: "GetHallTaskList",
			Handler:    _Task_GetHallTaskList_Handler,
		},
		{
			MethodName: "GetHallTaskReward",
			Handler:    _Task_GetHallTaskReward_Handler,
		},
		{
			MethodName: "ListHallMissions",
			Handler:    _Task_ListHallMissions_Handler,
		},
		{
			MethodName: "ReceiveHallMissionReward",
			Handler:    _Task_ReceiveHallMissionReward_Handler,
		},
		{
			MethodName: "ReportedRequirement",
			Handler:    _Task_ReportedRequirement_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

func (m *UserDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Role != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x18
	}
	if m.IsWin {
		i--
		if m.IsWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameEndReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameEndReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameEndReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserList) > 0 {
		for iNdEx := len(m.UserList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.TableId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x18
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActionDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Num != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpecialActionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecialActionReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecialActionReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ActionList) > 0 {
		for iNdEx := len(m.ActionList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActionList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BuyPropsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyPropsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuyPropsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PropsId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PropsId))
		i--
		dAtA[i] = 0x18
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PayMoneyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayMoneyReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayMoneyReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Money != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x18
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryTaskReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTaskReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTaskReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TaskProperty) > 0 {
		i -= len(m.TaskProperty)
		copy(dAtA[i:], m.TaskProperty)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TaskProperty)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PropsDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropsDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropsDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Weight != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x18
	}
	if m.Num != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActivityDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivityDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PropsList) > 0 {
		for iNdEx := len(m.PropsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PropsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.State != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Num != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TaskDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x72
	}
	if m.OnlineDetail != nil {
		{
			size, err := m.OnlineDetail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.TaskDate != nil {
		{
			size, err := m.TaskDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Everyday != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Everyday))
		i--
		dAtA[i] = 0x58
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x50
	}
	if len(m.PropsList) > 0 {
		for iNdEx := len(m.PropsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PropsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Order != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x40
	}
	if m.State != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x38
	}
	if m.Finish != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Finish))
		i--
		dAtA[i] = 0x30
	}
	if m.Current != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Current))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Trigger) > 0 {
		i -= len(m.Trigger)
		copy(dAtA[i:], m.Trigger)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Trigger)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Property) > 0 {
		i -= len(m.Property)
		copy(dAtA[i:], m.Property)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Property)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Date) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Date) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Date) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryTaskResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTaskResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTaskResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ActivityList) > 0 {
		for iNdEx := len(m.ActivityList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActivityList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.TaskList) > 0 {
		for iNdEx := len(m.TaskList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TaskList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.CurrentActivity != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CurrentActivity))
		i--
		dAtA[i] = 0x20
	}
	if m.Deadline != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Deadline))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTaskRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTaskRewardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTaskRewardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PropsList) > 0 {
		for iNdEx := len(m.PropsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PropsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetActivityRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetActivityRewardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetActivityRewardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Activity != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Activity))
		i--
		dAtA[i] = 0x18
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetRandRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRandRewardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRandRewardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TaskProperty) > 0 {
		i -= len(m.TaskProperty)
		copy(dAtA[i:], m.TaskProperty)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TaskProperty)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommonResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpecialActionResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecialActionResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecialActionResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsContinue {
		i--
		if m.IsContinue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PushOnLineStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushOnLineStatusReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushOnLineStatusReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x20
	}
	if m.IsOnline {
		i--
		if m.IsOnline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OnlineDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnlineDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnlineDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TaskStage != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TaskStage))
		i--
		dAtA[i] = 0x18
	}
	if m.TargetTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TargetTime))
		i--
		dAtA[i] = 0x10
	}
	if m.LeftTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LeftTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetHallTaskReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHallTaskReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetHallTaskReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Vip != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Vip))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TaskProperty) > 0 {
		i -= len(m.TaskProperty)
		copy(dAtA[i:], m.TaskProperty)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TaskProperty)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HallTaskListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HallTaskListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HallTaskListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TaskList) > 0 {
		for iNdEx := len(m.TaskList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TaskList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ActiveStatus != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ActiveStatus))
		i--
		dAtA[i] = 0x38
	}
	if m.ActiveNowDay != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ActiveNowDay))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ActiveEndTime) > 0 {
		i -= len(m.ActiveEndTime)
		copy(dAtA[i:], m.ActiveEndTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ActiveEndTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ActiveBeginTime) > 0 {
		i -= len(m.ActiveBeginTime)
		copy(dAtA[i:], m.ActiveBeginTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ActiveBeginTime)))
		i--
		dAtA[i] = 0x22
	}
	if m.Deadline != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Deadline))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HallTaskRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HallTaskRewardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HallTaskRewardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Vip != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Vip))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Mission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rewards != nil {
		{
			size, err := m.Rewards.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if m.Requirements != nil {
		{
			size, err := m.Requirements.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if m.Activities != nil {
		{
			size, err := m.Activities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.Limits != nil {
		{
			size, err := m.Limits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.CycleIndex != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CycleIndex))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.CycleType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CycleType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.DeadTimestamp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DeadTimestamp))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.EndTimestamp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EndTimestamp))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.StartTimestamp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StartTimestamp))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.PreTimestamp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PreTimestamp))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if len(m.DeadTime) > 0 {
		i -= len(m.DeadTime)
		copy(dAtA[i:], m.DeadTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.DeadTime)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.PreTime) > 0 {
		i -= len(m.PreTime)
		copy(dAtA[i:], m.PreTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.PreTime)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Order != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.State != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.IsNeedReceive {
		i--
		if m.IsNeedReceive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.IsNeedJoin {
		i--
		if m.IsNeedJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x50
	}
	if m.SourceType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SourceType))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x20
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if m.AppId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AppId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Groups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Groups) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Groups) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GroupIds) > 0 {
		dAtA8 := make([]byte, len(m.GroupIds)*10)
		var j7 int
		for _, num1 := range m.GroupIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintApi(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Counts) > 0 {
		dAtA10 := make([]byte, len(m.Counts)*10)
		var j9 int
		for _, num1 := range m.Counts {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintApi(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TargetIds) > 0 {
		dAtA12 := make([]byte, len(m.TargetIds)*10)
		var j11 int
		for _, num1 := range m.TargetIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintApi(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Requirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Requirement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Requirement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Requirements) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Requirements) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Requirements) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GroupIds) > 0 {
		dAtA14 := make([]byte, len(m.GroupIds)*10)
		var j13 int
		for _, num1 := range m.GroupIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintApi(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Counts) > 0 {
		dAtA16 := make([]byte, len(m.Counts)*10)
		var j15 int
		for _, num1 := range m.Counts {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintApi(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ids) > 0 {
		dAtA18 := make([]byte, len(m.Ids)*10)
		var j17 int
		for _, num1 := range m.Ids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintApi(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequirementMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequirementMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequirementMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RequirementMap) > 0 {
		for k := range m.RequirementMap {
			v := m.RequirementMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Reward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UnActivityFixedItemCounts) > 0 {
		dAtA21 := make([]byte, len(m.UnActivityFixedItemCounts)*10)
		var j20 int
		for _, num1 := range m.UnActivityFixedItemCounts {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintApi(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if len(m.UnActivityFixedItemIds) > 0 {
		dAtA23 := make([]byte, len(m.UnActivityFixedItemIds)*10)
		var j22 int
		for _, num1 := range m.UnActivityFixedItemIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintApi(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if len(m.FixedItemCounts) > 0 {
		dAtA25 := make([]byte, len(m.FixedItemCounts)*10)
		var j24 int
		for _, num1 := range m.FixedItemCounts {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintApi(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if len(m.FixedItemIds) > 0 {
		dAtA27 := make([]byte, len(m.FixedItemIds)*10)
		var j26 int
		for _, num1 := range m.FixedItemIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintApi(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.UnActivityFactory) > 0 {
		for iNdEx := len(m.UnActivityFactory) - 1; iNdEx >= 0; iNdEx-- {
			f28 := math.Float64bits(float64(m.UnActivityFactory[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f28))
		}
		i = encodeVarintApi(dAtA, i, uint64(len(m.UnActivityFactory)*8))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.UnActivityVipRange) > 0 {
		dAtA30 := make([]byte, len(m.UnActivityVipRange)*10)
		var j29 int
		for _, num1 := range m.UnActivityVipRange {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		i -= j29
		copy(dAtA[i:], dAtA30[:j29])
		i = encodeVarintApi(dAtA, i, uint64(j29))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.UnActivityRandomItemIds) > 0 {
		dAtA32 := make([]byte, len(m.UnActivityRandomItemIds)*10)
		var j31 int
		for _, num1 := range m.UnActivityRandomItemIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		i -= j31
		copy(dAtA[i:], dAtA32[:j31])
		i = encodeVarintApi(dAtA, i, uint64(j31))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.UnActivityRandomRight) > 0 {
		dAtA34 := make([]byte, len(m.UnActivityRandomRight)*10)
		var j33 int
		for _, num1 := range m.UnActivityRandomRight {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintApi(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.UnActivityRandomLeft) > 0 {
		dAtA36 := make([]byte, len(m.UnActivityRandomLeft)*10)
		var j35 int
		for _, num1 := range m.UnActivityRandomLeft {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		i -= j35
		copy(dAtA[i:], dAtA36[:j35])
		i = encodeVarintApi(dAtA, i, uint64(j35))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.UnActivityRandomWeights) > 0 {
		dAtA38 := make([]byte, len(m.UnActivityRandomWeights)*10)
		var j37 int
		for _, num1 := range m.UnActivityRandomWeights {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		i -= j37
		copy(dAtA[i:], dAtA38[:j37])
		i = encodeVarintApi(dAtA, i, uint64(j37))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Factory) > 0 {
		for iNdEx := len(m.Factory) - 1; iNdEx >= 0; iNdEx-- {
			f39 := math.Float64bits(float64(m.Factory[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f39))
		}
		i = encodeVarintApi(dAtA, i, uint64(len(m.Factory)*8))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.VipRange) > 0 {
		dAtA41 := make([]byte, len(m.VipRange)*10)
		var j40 int
		for _, num1 := range m.VipRange {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA41[j40] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j40++
			}
			dAtA41[j40] = uint8(num)
			j40++
		}
		i -= j40
		copy(dAtA[i:], dAtA41[:j40])
		i = encodeVarintApi(dAtA, i, uint64(j40))
		i--
		dAtA[i] = 0x72
	}
	if len(m.RandomItemIds) > 0 {
		dAtA43 := make([]byte, len(m.RandomItemIds)*10)
		var j42 int
		for _, num1 := range m.RandomItemIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA43[j42] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j42++
			}
			dAtA43[j42] = uint8(num)
			j42++
		}
		i -= j42
		copy(dAtA[i:], dAtA43[:j42])
		i = encodeVarintApi(dAtA, i, uint64(j42))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.RandomRight) > 0 {
		dAtA45 := make([]byte, len(m.RandomRight)*10)
		var j44 int
		for _, num1 := range m.RandomRight {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintApi(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0x62
	}
	if len(m.RandomLeft) > 0 {
		dAtA47 := make([]byte, len(m.RandomLeft)*10)
		var j46 int
		for _, num1 := range m.RandomLeft {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA47[j46] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j46++
			}
			dAtA47[j46] = uint8(num)
			j46++
		}
		i -= j46
		copy(dAtA[i:], dAtA47[:j46])
		i = encodeVarintApi(dAtA, i, uint64(j46))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.RandomWeights) > 0 {
		dAtA49 := make([]byte, len(m.RandomWeights)*10)
		var j48 int
		for _, num1 := range m.RandomWeights {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA49[j48] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j48++
			}
			dAtA49[j48] = uint8(num)
			j48++
		}
		i -= j48
		copy(dAtA[i:], dAtA49[:j48])
		i = encodeVarintApi(dAtA, i, uint64(j48))
		i--
		dAtA[i] = 0x52
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserMissionStateMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMissionStateMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserMissionStateMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserMissionStateMap) > 0 {
		for k := range m.UserMissionStateMap {
			v := m.UserMissionStateMap[k]
			baseI := i
			i = encodeVarintApi(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListHallMissionsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListHallMissionsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListHallMissionsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MissionType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MissionType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.GameIds) > 0 {
		dAtA51 := make([]byte, len(m.GameIds)*10)
		var j50 int
		for _, num1 := range m.GameIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA51[j50] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j50++
			}
			dAtA51[j50] = uint8(num)
			j50++
		}
		i -= j50
		copy(dAtA[i:], dAtA51[:j50])
		i = encodeVarintApi(dAtA, i, uint64(j50))
		i--
		dAtA[i] = 0x1a
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.AppId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AppId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Missions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Missions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Missions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Missions) > 0 {
		for iNdEx := len(m.Missions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Missions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListHallMissionsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListHallMissionsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListHallMissionsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserMissionStateMap) > 0 {
		for k := range m.UserMissionStateMap {
			v := m.UserMissionStateMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RequirementMap) > 0 {
		for k := range m.RequirementMap {
			v := m.RequirementMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ReportedDetailMap) > 0 {
		for k := range m.ReportedDetailMap {
			v := m.ReportedDetailMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MissionMap) > 0 {
		for k := range m.MissionMap {
			v := m.MissionMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReceiveHallMissionRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveHallMissionRewardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReceiveHallMissionRewardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GroupId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.MissionId) > 0 {
		i -= len(m.MissionId)
		copy(dAtA[i:], m.MissionId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.MissionId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x20
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.AppId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AppId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReceiveHallMissionRewardResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveHallMissionRewardResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReceiveHallMissionRewardResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PropsList) > 0 {
		for iNdEx := len(m.PropsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PropsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReportedDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportedDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportedDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.RequirementId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RequirementId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReportedDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportedDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportedDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ReportedDetails) > 0 {
		for iNdEx := len(m.ReportedDetails) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReportedDetails[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReportedDetailMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportedDetailMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportedDetailMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ReportedDetailMap) > 0 {
		for k := range m.ReportedDetailMap {
			v := m.ReportedDetailMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReportedRequirementReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportedRequirementReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportedRequirementReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ReportedDetails) > 0 {
		for iNdEx := len(m.ReportedDetails) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReportedDetails[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x20
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.AppId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AppId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReportedRequirementResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportedRequirementResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportedRequirementResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsContinue {
		i--
		if m.IsContinue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.IsWin {
		n += 2
	}
	if m.Role != 0 {
		n += 1 + sovApi(uint64(m.Role))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameEndReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.TableId != 0 {
		n += 1 + sovApi(uint64(m.TableId))
	}
	if len(m.UserList) > 0 {
		for _, e := range m.UserList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActionDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpecialActionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if len(m.ActionList) > 0 {
		for _, e := range m.ActionList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuyPropsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.PropsId != 0 {
		n += 1 + sovApi(uint64(m.PropsId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PayMoneyReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.Money != 0 {
		n += 1 + sovApi(uint64(m.Money))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryTaskReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	l = len(m.TaskProperty)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropsDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.Weight != 0 {
		n += 1 + sovApi(uint64(m.Weight))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivityDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	if len(m.PropsList) > 0 {
		for _, e := range m.PropsList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Property)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Trigger)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Current != 0 {
		n += 1 + sovApi(uint64(m.Current))
	}
	if m.Finish != 0 {
		n += 1 + sovApi(uint64(m.Finish))
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	if m.Order != 0 {
		n += 1 + sovApi(uint64(m.Order))
	}
	if len(m.PropsList) > 0 {
		for _, e := range m.PropsList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.Everyday != 0 {
		n += 1 + sovApi(uint64(m.Everyday))
	}
	if m.TaskDate != nil {
		l = m.TaskDate.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.OnlineDetail != nil {
		l = m.OnlineDetail.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Date) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryTaskResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Deadline != 0 {
		n += 1 + sovApi(uint64(m.Deadline))
	}
	if m.CurrentActivity != 0 {
		n += 1 + sovApi(uint64(m.CurrentActivity))
	}
	if len(m.TaskList) > 0 {
		for _, e := range m.TaskList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.ActivityList) > 0 {
		for _, e := range m.ActivityList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTaskRewardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.PropsList) > 0 {
		for _, e := range m.PropsList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetActivityRewardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.Activity != 0 {
		n += 1 + sovApi(uint64(m.Activity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRandRewardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	l = len(m.TaskProperty)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpecialActionResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IsContinue {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PushOnLineStatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.IsOnline {
		n += 2
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnlineDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeftTime != 0 {
		n += 1 + sovApi(uint64(m.LeftTime))
	}
	if m.TargetTime != 0 {
		n += 1 + sovApi(uint64(m.TargetTime))
	}
	if m.TaskStage != 0 {
		n += 1 + sovApi(uint64(m.TaskStage))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetHallTaskReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	l = len(m.TaskProperty)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Vip != 0 {
		n += 1 + sovApi(uint64(m.Vip))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HallTaskListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Deadline != 0 {
		n += 1 + sovApi(uint64(m.Deadline))
	}
	l = len(m.ActiveBeginTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ActiveEndTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ActiveNowDay != 0 {
		n += 1 + sovApi(uint64(m.ActiveNowDay))
	}
	if m.ActiveStatus != 0 {
		n += 1 + sovApi(uint64(m.ActiveStatus))
	}
	if len(m.TaskList) > 0 {
		for _, e := range m.TaskList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HallTaskRewardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Vip != 0 {
		n += 1 + sovApi(uint64(m.Vip))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Mission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.AppId != 0 {
		n += 1 + sovApi(uint64(m.AppId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.SourceType != 0 {
		n += 1 + sovApi(uint64(m.SourceType))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IsNeedJoin {
		n += 2
	}
	if m.IsNeedReceive {
		n += 3
	}
	if m.State != 0 {
		n += 2 + sovApi(uint64(m.State))
	}
	if m.Order != 0 {
		n += 2 + sovApi(uint64(m.Order))
	}
	l = len(m.PreTime)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.DeadTime)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.PreTimestamp != 0 {
		n += 2 + sovApi(uint64(m.PreTimestamp))
	}
	if m.StartTimestamp != 0 {
		n += 2 + sovApi(uint64(m.StartTimestamp))
	}
	if m.EndTimestamp != 0 {
		n += 2 + sovApi(uint64(m.EndTimestamp))
	}
	if m.DeadTimestamp != 0 {
		n += 2 + sovApi(uint64(m.DeadTimestamp))
	}
	if m.CycleType != 0 {
		n += 2 + sovApi(uint64(m.CycleType))
	}
	if m.CycleIndex != 0 {
		n += 2 + sovApi(uint64(m.CycleIndex))
	}
	if m.Limits != nil {
		l = m.Limits.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.Activities != nil {
		l = m.Activities.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.Requirements != nil {
		l = m.Requirements.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Groups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TargetIds) > 0 {
		l = 0
		for _, e := range m.TargetIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.Counts) > 0 {
		l = 0
		for _, e := range m.Counts {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.GroupIds) > 0 {
		l = 0
		for _, e := range m.GroupIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Requirement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Requirements) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.Counts) > 0 {
		l = 0
		for _, e := range m.Counts {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.GroupIds) > 0 {
		l = 0
		for _, e := range m.GroupIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequirementMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequirementMap) > 0 {
		for k, v := range m.RequirementMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Reward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if len(m.RandomWeights) > 0 {
		l = 0
		for _, e := range m.RandomWeights {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.RandomLeft) > 0 {
		l = 0
		for _, e := range m.RandomLeft {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.RandomRight) > 0 {
		l = 0
		for _, e := range m.RandomRight {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.RandomItemIds) > 0 {
		l = 0
		for _, e := range m.RandomItemIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.VipRange) > 0 {
		l = 0
		for _, e := range m.VipRange {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.Factory) > 0 {
		n += 1 + sovApi(uint64(len(m.Factory)*8)) + len(m.Factory)*8
	}
	if len(m.UnActivityRandomWeights) > 0 {
		l = 0
		for _, e := range m.UnActivityRandomWeights {
			l += sovApi(uint64(e))
		}
		n += 2 + sovApi(uint64(l)) + l
	}
	if len(m.UnActivityRandomLeft) > 0 {
		l = 0
		for _, e := range m.UnActivityRandomLeft {
			l += sovApi(uint64(e))
		}
		n += 2 + sovApi(uint64(l)) + l
	}
	if len(m.UnActivityRandomRight) > 0 {
		l = 0
		for _, e := range m.UnActivityRandomRight {
			l += sovApi(uint64(e))
		}
		n += 2 + sovApi(uint64(l)) + l
	}
	if len(m.UnActivityRandomItemIds) > 0 {
		l = 0
		for _, e := range m.UnActivityRandomItemIds {
			l += sovApi(uint64(e))
		}
		n += 2 + sovApi(uint64(l)) + l
	}
	if len(m.UnActivityVipRange) > 0 {
		l = 0
		for _, e := range m.UnActivityVipRange {
			l += sovApi(uint64(e))
		}
		n += 2 + sovApi(uint64(l)) + l
	}
	if len(m.UnActivityFactory) > 0 {
		n += 2 + sovApi(uint64(len(m.UnActivityFactory)*8)) + len(m.UnActivityFactory)*8
	}
	if len(m.FixedItemIds) > 0 {
		l = 0
		for _, e := range m.FixedItemIds {
			l += sovApi(uint64(e))
		}
		n += 2 + sovApi(uint64(l)) + l
	}
	if len(m.FixedItemCounts) > 0 {
		l = 0
		for _, e := range m.FixedItemCounts {
			l += sovApi(uint64(e))
		}
		n += 2 + sovApi(uint64(l)) + l
	}
	if len(m.UnActivityFixedItemIds) > 0 {
		l = 0
		for _, e := range m.UnActivityFixedItemIds {
			l += sovApi(uint64(e))
		}
		n += 2 + sovApi(uint64(l)) + l
	}
	if len(m.UnActivityFixedItemCounts) > 0 {
		l = 0
		for _, e := range m.UnActivityFixedItemCounts {
			l += sovApi(uint64(e))
		}
		n += 2 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserMissionStateMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserMissionStateMap) > 0 {
		for k, v := range m.UserMissionStateMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + sovApi(uint64(v))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListHallMissionsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppId != 0 {
		n += 1 + sovApi(uint64(m.AppId))
	}
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if len(m.GameIds) > 0 {
		l = 0
		for _, e := range m.GameIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.MissionType != 0 {
		n += 1 + sovApi(uint64(m.MissionType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Missions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Missions) > 0 {
		for _, e := range m.Missions {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListHallMissionsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MissionMap) > 0 {
		for k, v := range m.MissionMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.ReportedDetailMap) > 0 {
		for k, v := range m.ReportedDetailMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.RequirementMap) > 0 {
		for k, v := range m.RequirementMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.UserMissionStateMap) > 0 {
		for k, v := range m.UserMissionStateMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReceiveHallMissionRewardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppId != 0 {
		n += 1 + sovApi(uint64(m.AppId))
	}
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	l = len(m.MissionId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovApi(uint64(m.GroupId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReceiveHallMissionRewardResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PropsList) > 0 {
		for _, e := range m.PropsList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportedDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequirementId != 0 {
		n += 1 + sovApi(uint64(m.RequirementId))
	}
	if m.Count != 0 {
		n += 1 + sovApi(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportedDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ReportedDetails) > 0 {
		for _, e := range m.ReportedDetails {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportedDetailMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ReportedDetailMap) > 0 {
		for k, v := range m.ReportedDetailMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportedRequirementReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppId != 0 {
		n += 1 + sovApi(uint64(m.AppId))
	}
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if len(m.ReportedDetails) > 0 {
		for _, e := range m.ReportedDetails {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportedRequirementResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsContinue {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWin = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameEndReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameEndReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameEndReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserList = append(m.UserList, &UserDetails{})
			if err := m.UserList[len(m.UserList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecialActionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecialActionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecialActionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionList = append(m.ActionList, &ActionDetails{})
			if err := m.ActionList[len(m.ActionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyPropsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyPropsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyPropsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropsId", wireType)
			}
			m.PropsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PropsId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayMoneyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayMoneyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayMoneyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTaskReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTaskReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTaskReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskProperty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskProperty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropsDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropsDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropsDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PropsList = append(m.PropsList, &PropsDetails{})
			if err := m.PropsList[len(m.PropsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Property", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Property = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trigger = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			m.Current = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Current |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finish", wireType)
			}
			m.Finish = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Finish |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PropsList = append(m.PropsList, &PropsDetails{})
			if err := m.PropsList[len(m.PropsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Everyday", wireType)
			}
			m.Everyday = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Everyday |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaskDate == nil {
				m.TaskDate = &Date{}
			}
			if err := m.TaskDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnlineDetail == nil {
				m.OnlineDetail = &OnlineDetail{}
			}
			if err := m.OnlineDetail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Date) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Date: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Date: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTaskResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTaskResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTaskResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			m.Deadline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deadline |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentActivity", wireType)
			}
			m.CurrentActivity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentActivity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskList = append(m.TaskList, &TaskDetails{})
			if err := m.TaskList[len(m.TaskList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivityList = append(m.ActivityList, &ActivityDetails{})
			if err := m.ActivityList[len(m.ActivityList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTaskRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTaskRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTaskRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PropsList = append(m.PropsList, &PropsDetails{})
			if err := m.PropsList[len(m.PropsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetActivityRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetActivityRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetActivityRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activity", wireType)
			}
			m.Activity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Activity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRandRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRandRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRandRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskProperty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskProperty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecialActionResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecialActionResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecialActionResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsContinue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsContinue = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushOnLineStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushOnLineStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushOnLineStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOnline = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnlineDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnlineDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnlineDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftTime", wireType)
			}
			m.LeftTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTime", wireType)
			}
			m.TargetTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskStage", wireType)
			}
			m.TaskStage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskStage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHallTaskReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHallTaskReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHallTaskReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskProperty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskProperty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HallTaskListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HallTaskListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HallTaskListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			m.Deadline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deadline |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveBeginTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveBeginTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveEndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveEndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveNowDay", wireType)
			}
			m.ActiveNowDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveNowDay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveStatus", wireType)
			}
			m.ActiveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskList = append(m.TaskList, &TaskDetails{})
			if err := m.TaskList[len(m.TaskList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HallTaskRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HallTaskRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HallTaskRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNeedJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNeedJoin = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNeedReceive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNeedReceive = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeadTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreTimestamp", wireType)
			}
			m.PreTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			m.StartTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTimestamp", wireType)
			}
			m.EndTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadTimestamp", wireType)
			}
			m.DeadTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeadTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CycleType", wireType)
			}
			m.CycleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CycleType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CycleIndex", wireType)
			}
			m.CycleIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CycleIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limits == nil {
				m.Limits = &Groups{}
			}
			if err := m.Limits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Activities == nil {
				m.Activities = &Groups{}
			}
			if err := m.Activities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Requirements == nil {
				m.Requirements = &Groups{}
			}
			if err := m.Requirements.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &Groups{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Groups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Groups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Groups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TargetIds = append(m.TargetIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TargetIds) == 0 {
					m.TargetIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TargetIds = append(m.TargetIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetIds", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Counts = append(m.Counts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Counts) == 0 {
					m.Counts = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Counts = append(m.Counts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Counts", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupIds = append(m.GroupIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupIds) == 0 {
					m.GroupIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupIds = append(m.GroupIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Requirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Requirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Requirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Requirements) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Requirements: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Requirements: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ids = append(m.Ids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ids) == 0 {
					m.Ids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ids = append(m.Ids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Counts = append(m.Counts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Counts) == 0 {
					m.Counts = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Counts = append(m.Counts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Counts", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupIds = append(m.GroupIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupIds) == 0 {
					m.GroupIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupIds = append(m.GroupIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequirementMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequirementMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequirementMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequirementMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequirementMap == nil {
				m.RequirementMap = make(map[int64]*Requirement)
			}
			var mapkey int64
			var mapvalue *Requirement
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Requirement{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequirementMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RandomWeights = append(m.RandomWeights, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RandomWeights) == 0 {
					m.RandomWeights = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RandomWeights = append(m.RandomWeights, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomWeights", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RandomLeft = append(m.RandomLeft, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RandomLeft) == 0 {
					m.RandomLeft = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RandomLeft = append(m.RandomLeft, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomLeft", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RandomRight = append(m.RandomRight, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RandomRight) == 0 {
					m.RandomRight = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RandomRight = append(m.RandomRight, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomRight", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RandomItemIds = append(m.RandomItemIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RandomItemIds) == 0 {
					m.RandomItemIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RandomItemIds = append(m.RandomItemIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomItemIds", wireType)
			}
		case 14:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VipRange = append(m.VipRange, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.VipRange) == 0 {
					m.VipRange = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VipRange = append(m.VipRange, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VipRange", wireType)
			}
		case 15:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Factory = append(m.Factory, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Factory) == 0 {
					m.Factory = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Factory = append(m.Factory, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Factory", wireType)
			}
		case 20:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnActivityRandomWeights = append(m.UnActivityRandomWeights, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnActivityRandomWeights) == 0 {
					m.UnActivityRandomWeights = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnActivityRandomWeights = append(m.UnActivityRandomWeights, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnActivityRandomWeights", wireType)
			}
		case 21:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnActivityRandomLeft = append(m.UnActivityRandomLeft, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnActivityRandomLeft) == 0 {
					m.UnActivityRandomLeft = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnActivityRandomLeft = append(m.UnActivityRandomLeft, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnActivityRandomLeft", wireType)
			}
		case 22:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnActivityRandomRight = append(m.UnActivityRandomRight, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnActivityRandomRight) == 0 {
					m.UnActivityRandomRight = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnActivityRandomRight = append(m.UnActivityRandomRight, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnActivityRandomRight", wireType)
			}
		case 23:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnActivityRandomItemIds = append(m.UnActivityRandomItemIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnActivityRandomItemIds) == 0 {
					m.UnActivityRandomItemIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnActivityRandomItemIds = append(m.UnActivityRandomItemIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnActivityRandomItemIds", wireType)
			}
		case 24:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnActivityVipRange = append(m.UnActivityVipRange, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnActivityVipRange) == 0 {
					m.UnActivityVipRange = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnActivityVipRange = append(m.UnActivityVipRange, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnActivityVipRange", wireType)
			}
		case 25:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.UnActivityFactory = append(m.UnActivityFactory, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.UnActivityFactory) == 0 {
					m.UnActivityFactory = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.UnActivityFactory = append(m.UnActivityFactory, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnActivityFactory", wireType)
			}
		case 30:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FixedItemIds = append(m.FixedItemIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FixedItemIds) == 0 {
					m.FixedItemIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FixedItemIds = append(m.FixedItemIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedItemIds", wireType)
			}
		case 31:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FixedItemCounts = append(m.FixedItemCounts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FixedItemCounts) == 0 {
					m.FixedItemCounts = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FixedItemCounts = append(m.FixedItemCounts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedItemCounts", wireType)
			}
		case 40:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnActivityFixedItemIds = append(m.UnActivityFixedItemIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnActivityFixedItemIds) == 0 {
					m.UnActivityFixedItemIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnActivityFixedItemIds = append(m.UnActivityFixedItemIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnActivityFixedItemIds", wireType)
			}
		case 41:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnActivityFixedItemCounts = append(m.UnActivityFixedItemCounts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnActivityFixedItemCounts) == 0 {
					m.UnActivityFixedItemCounts = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnActivityFixedItemCounts = append(m.UnActivityFixedItemCounts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnActivityFixedItemCounts", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMissionStateMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMissionStateMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMissionStateMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMissionStateMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserMissionStateMap == nil {
				m.UserMissionStateMap = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserMissionStateMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListHallMissionsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListHallMissionsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListHallMissionsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GameIds = append(m.GameIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GameIds) == 0 {
					m.GameIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GameIds = append(m.GameIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GameIds", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissionType", wireType)
			}
			m.MissionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MissionType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Missions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Missions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Missions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Missions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Missions = append(m.Missions, &Mission{})
			if err := m.Missions[len(m.Missions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListHallMissionsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListHallMissionsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListHallMissionsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissionMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MissionMap == nil {
				m.MissionMap = make(map[int32]*Missions)
			}
			var mapkey int32
			var mapvalue *Missions
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Missions{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MissionMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportedDetailMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportedDetailMap == nil {
				m.ReportedDetailMap = make(map[int32]*ReportedDetailMap)
			}
			var mapkey int32
			var mapvalue *ReportedDetailMap
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ReportedDetailMap{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ReportedDetailMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequirementMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequirementMap == nil {
				m.RequirementMap = make(map[int32]*RequirementMap)
			}
			var mapkey int32
			var mapvalue *RequirementMap
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RequirementMap{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequirementMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMissionStateMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserMissionStateMap == nil {
				m.UserMissionStateMap = make(map[int32]*UserMissionStateMap)
			}
			var mapkey int32
			var mapvalue *UserMissionStateMap
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &UserMissionStateMap{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserMissionStateMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveHallMissionRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveHallMissionRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveHallMissionRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MissionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveHallMissionRewardResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveHallMissionRewardResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveHallMissionRewardResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PropsList = append(m.PropsList, &PropsDetails{})
			if err := m.PropsList[len(m.PropsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportedDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportedDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportedDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequirementId", wireType)
			}
			m.RequirementId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequirementId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportedDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportedDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportedDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportedDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportedDetails = append(m.ReportedDetails, &ReportedDetail{})
			if err := m.ReportedDetails[len(m.ReportedDetails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportedDetailMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportedDetailMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportedDetailMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportedDetailMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportedDetailMap == nil {
				m.ReportedDetailMap = make(map[string]*ReportedDetails)
			}
			var mapkey string
			var mapvalue *ReportedDetails
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ReportedDetails{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ReportedDetailMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportedRequirementReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportedRequirementReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportedRequirementReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportedDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportedDetails = append(m.ReportedDetails, &ReportedDetail{})
			if err := m.ReportedDetails[len(m.ReportedDetails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportedRequirementResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportedRequirementResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportedRequirementResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsContinue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsContinue = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
