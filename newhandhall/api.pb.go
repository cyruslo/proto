// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

// package 命名使用 {appid}.{version} 的方式, version 形如 v1, v2 ..

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

///////////////////////////////////////////////////枚举<begin>/////////////////////////////////////////////////////////
// 错误码
type NewhandhallErrCode int32

const (
	NewhandhallErrCode_Success                   NewhandhallErrCode = 0
	NewhandhallErrCode_ParameterError            NewhandhallErrCode = 10001
	NewhandhallErrCode_DBError                   NewhandhallErrCode = 10002
	NewhandhallErrCode_TimeNotEnough             NewhandhallErrCode = 10003
	NewhandhallErrCode_ConsumeAndEarnedNotEnough NewhandhallErrCode = 10004
	NewhandhallErrCode_VipScoreNotEnough         NewhandhallErrCode = 10005
	NewhandhallErrCode_GuideIndexError           NewhandhallErrCode = 10006
	NewhandhallErrCode_ConfigError               NewhandhallErrCode = 10007
)

var NewhandhallErrCode_name = map[int32]string{
	0:     "Success",
	10001: "ParameterError",
	10002: "DBError",
	10003: "TimeNotEnough",
	10004: "ConsumeAndEarnedNotEnough",
	10005: "VipScoreNotEnough",
	10006: "GuideIndexError",
	10007: "ConfigError",
}

var NewhandhallErrCode_value = map[string]int32{
	"Success":                   0,
	"ParameterError":            10001,
	"DBError":                   10002,
	"TimeNotEnough":             10003,
	"ConsumeAndEarnedNotEnough": 10004,
	"VipScoreNotEnough":         10005,
	"GuideIndexError":           10006,
	"ConfigError":               10007,
}

func (x NewhandhallErrCode) String() string {
	return proto.EnumName(NewhandhallErrCode_name, int32(x))
}

func (NewhandhallErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

type TaskStatus int32

const (
	TaskStatus_UnOpen     TaskStatus = 0
	TaskStatus_UnComplete TaskStatus = 1
	TaskStatus_UnReceive  TaskStatus = 2
	TaskStatus_Done       TaskStatus = 3
)

var TaskStatus_name = map[int32]string{
	0: "UnOpen",
	1: "UnComplete",
	2: "UnReceive",
	3: "Done",
}

var TaskStatus_value = map[string]int32{
	"UnOpen":     0,
	"UnComplete": 1,
	"UnReceive":  2,
	"Done":       3,
}

func (x TaskStatus) String() string {
	return proto.EnumName(TaskStatus_name, int32(x))
}

func (TaskStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}

///////////////////////////////////////////////////嵌套<begin>/////////////////////////////////////////////////////////
type NextGiftTimeInfo struct {
	Id                   int32    `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	TimeLeft             int64    `protobuf:"varint,2,opt,name=TimeLeft,proto3" json:"TimeLeft,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NextGiftTimeInfo) Reset()         { *m = NextGiftTimeInfo{} }
func (m *NextGiftTimeInfo) String() string { return proto.CompactTextString(m) }
func (*NextGiftTimeInfo) ProtoMessage()    {}
func (*NextGiftTimeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *NextGiftTimeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextGiftTimeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextGiftTimeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NextGiftTimeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextGiftTimeInfo.Merge(m, src)
}
func (m *NextGiftTimeInfo) XXX_Size() int {
	return m.Size()
}
func (m *NextGiftTimeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NextGiftTimeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NextGiftTimeInfo proto.InternalMessageInfo

////////////////////////////////////////////////客户端协议<begin>//////////////////////////////////////////////////////
type CommonRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonRsp) Reset()         { *m = CommonRsp{} }
func (m *CommonRsp) String() string { return proto.CompactTextString(m) }
func (*CommonRsp) ProtoMessage()    {}
func (*CommonRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *CommonRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonRsp.Merge(m, src)
}
func (m *CommonRsp) XXX_Size() int {
	return m.Size()
}
func (m *CommonRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CommonRsp proto.InternalMessageInfo

type GetConfigReq struct {
	PlayerId             int64    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	ChannelId            int32    `protobuf:"varint,2,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetConfigReq) Reset()         { *m = GetConfigReq{} }
func (m *GetConfigReq) String() string { return proto.CompactTextString(m) }
func (*GetConfigReq) ProtoMessage()    {}
func (*GetConfigReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *GetConfigReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigReq.Merge(m, src)
}
func (m *GetConfigReq) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigReq proto.InternalMessageInfo

type GetConfigRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Config               string   `protobuf:"bytes,3,opt,name=Config,proto3" json:"Config,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetConfigRsp) Reset()         { *m = GetConfigRsp{} }
func (m *GetConfigRsp) String() string { return proto.CompactTextString(m) }
func (*GetConfigRsp) ProtoMessage()    {}
func (*GetConfigRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *GetConfigRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigRsp.Merge(m, src)
}
func (m *GetConfigRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigRsp proto.InternalMessageInfo

type GetGuideDataReq struct {
	PlayerId             int64    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	ChannelId            int32    `protobuf:"varint,2,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetGuideDataReq) Reset()         { *m = GetGuideDataReq{} }
func (m *GetGuideDataReq) String() string { return proto.CompactTextString(m) }
func (*GetGuideDataReq) ProtoMessage()    {}
func (*GetGuideDataReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *GetGuideDataReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGuideDataReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGuideDataReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGuideDataReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGuideDataReq.Merge(m, src)
}
func (m *GetGuideDataReq) XXX_Size() int {
	return m.Size()
}
func (m *GetGuideDataReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGuideDataReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetGuideDataReq proto.InternalMessageInfo

type GetGuideDataRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Index                int32    `protobuf:"varint,3,opt,name=Index,proto3" json:"Index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetGuideDataRsp) Reset()         { *m = GetGuideDataRsp{} }
func (m *GetGuideDataRsp) String() string { return proto.CompactTextString(m) }
func (*GetGuideDataRsp) ProtoMessage()    {}
func (*GetGuideDataRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *GetGuideDataRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGuideDataRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGuideDataRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGuideDataRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGuideDataRsp.Merge(m, src)
}
func (m *GetGuideDataRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetGuideDataRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGuideDataRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetGuideDataRsp proto.InternalMessageInfo

type CompleteGuideReq struct {
	PlayerId             int64    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	ChannelId            int32    `protobuf:"varint,2,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	Index                int32    `protobuf:"varint,3,opt,name=Index,proto3" json:"Index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompleteGuideReq) Reset()         { *m = CompleteGuideReq{} }
func (m *CompleteGuideReq) String() string { return proto.CompactTextString(m) }
func (*CompleteGuideReq) ProtoMessage()    {}
func (*CompleteGuideReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *CompleteGuideReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompleteGuideReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompleteGuideReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompleteGuideReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompleteGuideReq.Merge(m, src)
}
func (m *CompleteGuideReq) XXX_Size() int {
	return m.Size()
}
func (m *CompleteGuideReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CompleteGuideReq.DiscardUnknown(m)
}

var xxx_messageInfo_CompleteGuideReq proto.InternalMessageInfo

type GetNextGiftTimeReq struct {
	PlayerId             int64    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	ChannelId            int32    `protobuf:"varint,2,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	Id                   []int32  `protobuf:"varint,3,rep,packed,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetNextGiftTimeReq) Reset()         { *m = GetNextGiftTimeReq{} }
func (m *GetNextGiftTimeReq) String() string { return proto.CompactTextString(m) }
func (*GetNextGiftTimeReq) ProtoMessage()    {}
func (*GetNextGiftTimeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *GetNextGiftTimeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetNextGiftTimeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetNextGiftTimeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetNextGiftTimeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNextGiftTimeReq.Merge(m, src)
}
func (m *GetNextGiftTimeReq) XXX_Size() int {
	return m.Size()
}
func (m *GetNextGiftTimeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNextGiftTimeReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetNextGiftTimeReq proto.InternalMessageInfo

type GetNextGiftTimeRsp struct {
	Code                 int32               `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string              `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Data                 []*NextGiftTimeInfo `protobuf:"bytes,3,rep,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetNextGiftTimeRsp) Reset()         { *m = GetNextGiftTimeRsp{} }
func (m *GetNextGiftTimeRsp) String() string { return proto.CompactTextString(m) }
func (*GetNextGiftTimeRsp) ProtoMessage()    {}
func (*GetNextGiftTimeRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *GetNextGiftTimeRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetNextGiftTimeRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetNextGiftTimeRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetNextGiftTimeRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNextGiftTimeRsp.Merge(m, src)
}
func (m *GetNextGiftTimeRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetNextGiftTimeRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNextGiftTimeRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetNextGiftTimeRsp proto.InternalMessageInfo

type ReceiveGiftReq struct {
	PlayerId             int64    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	ChannelId            int32    `protobuf:"varint,2,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	Id                   int32    `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReceiveGiftReq) Reset()         { *m = ReceiveGiftReq{} }
func (m *ReceiveGiftReq) String() string { return proto.CompactTextString(m) }
func (*ReceiveGiftReq) ProtoMessage()    {}
func (*ReceiveGiftReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *ReceiveGiftReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveGiftReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveGiftReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReceiveGiftReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveGiftReq.Merge(m, src)
}
func (m *ReceiveGiftReq) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveGiftReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveGiftReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveGiftReq proto.InternalMessageInfo

type GetGoldConsumeAndEarnedReq struct {
	PlayerId             int64    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	ChannelId            int32    `protobuf:"varint,2,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetGoldConsumeAndEarnedReq) Reset()         { *m = GetGoldConsumeAndEarnedReq{} }
func (m *GetGoldConsumeAndEarnedReq) String() string { return proto.CompactTextString(m) }
func (*GetGoldConsumeAndEarnedReq) ProtoMessage()    {}
func (*GetGoldConsumeAndEarnedReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *GetGoldConsumeAndEarnedReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGoldConsumeAndEarnedReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGoldConsumeAndEarnedReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGoldConsumeAndEarnedReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGoldConsumeAndEarnedReq.Merge(m, src)
}
func (m *GetGoldConsumeAndEarnedReq) XXX_Size() int {
	return m.Size()
}
func (m *GetGoldConsumeAndEarnedReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGoldConsumeAndEarnedReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetGoldConsumeAndEarnedReq proto.InternalMessageInfo

type GetGoldConsumeAndEarnedRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Consume              int64    `protobuf:"varint,3,opt,name=Consume,proto3" json:"Consume,omitempty"`
	Earned               int64    `protobuf:"varint,4,opt,name=Earned,proto3" json:"Earned,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetGoldConsumeAndEarnedRsp) Reset()         { *m = GetGoldConsumeAndEarnedRsp{} }
func (m *GetGoldConsumeAndEarnedRsp) String() string { return proto.CompactTextString(m) }
func (*GetGoldConsumeAndEarnedRsp) ProtoMessage()    {}
func (*GetGoldConsumeAndEarnedRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *GetGoldConsumeAndEarnedRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGoldConsumeAndEarnedRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGoldConsumeAndEarnedRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGoldConsumeAndEarnedRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGoldConsumeAndEarnedRsp.Merge(m, src)
}
func (m *GetGoldConsumeAndEarnedRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetGoldConsumeAndEarnedRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGoldConsumeAndEarnedRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetGoldConsumeAndEarnedRsp proto.InternalMessageInfo

type UnlockHallReq struct {
	PlayerId             int64    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	ChannelId            int32    `protobuf:"varint,2,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnlockHallReq) Reset()         { *m = UnlockHallReq{} }
func (m *UnlockHallReq) String() string { return proto.CompactTextString(m) }
func (*UnlockHallReq) ProtoMessage()    {}
func (*UnlockHallReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *UnlockHallReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockHallReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockHallReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockHallReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockHallReq.Merge(m, src)
}
func (m *UnlockHallReq) XXX_Size() int {
	return m.Size()
}
func (m *UnlockHallReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockHallReq.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockHallReq proto.InternalMessageInfo

type GetHallIsLockReq struct {
	PlayerId             int64    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetHallIsLockReq) Reset()         { *m = GetHallIsLockReq{} }
func (m *GetHallIsLockReq) String() string { return proto.CompactTextString(m) }
func (*GetHallIsLockReq) ProtoMessage()    {}
func (*GetHallIsLockReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *GetHallIsLockReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetHallIsLockReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetHallIsLockReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetHallIsLockReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHallIsLockReq.Merge(m, src)
}
func (m *GetHallIsLockReq) XXX_Size() int {
	return m.Size()
}
func (m *GetHallIsLockReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHallIsLockReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetHallIsLockReq proto.InternalMessageInfo

type GetHallIsLockRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	IsUnlock             bool     `protobuf:"varint,3,opt,name=IsUnlock,proto3" json:"IsUnlock,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetHallIsLockRsp) Reset()         { *m = GetHallIsLockRsp{} }
func (m *GetHallIsLockRsp) String() string { return proto.CompactTextString(m) }
func (*GetHallIsLockRsp) ProtoMessage()    {}
func (*GetHallIsLockRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *GetHallIsLockRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetHallIsLockRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetHallIsLockRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetHallIsLockRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHallIsLockRsp.Merge(m, src)
}
func (m *GetHallIsLockRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetHallIsLockRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHallIsLockRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetHallIsLockRsp proto.InternalMessageInfo

type UnlockGameReq struct {
	PlayerId             int64    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	ChannelId            int32    `protobuf:"varint,2,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	GameId               int32    `protobuf:"varint,3,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnlockGameReq) Reset()         { *m = UnlockGameReq{} }
func (m *UnlockGameReq) String() string { return proto.CompactTextString(m) }
func (*UnlockGameReq) ProtoMessage()    {}
func (*UnlockGameReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *UnlockGameReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockGameReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockGameReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockGameReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockGameReq.Merge(m, src)
}
func (m *UnlockGameReq) XXX_Size() int {
	return m.Size()
}
func (m *UnlockGameReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockGameReq.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockGameReq proto.InternalMessageInfo

type GetGameInfoReq struct {
	PlayerId             int64    `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	ChannelId            int32    `protobuf:"varint,2,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetGameInfoReq) Reset()         { *m = GetGameInfoReq{} }
func (m *GetGameInfoReq) String() string { return proto.CompactTextString(m) }
func (*GetGameInfoReq) ProtoMessage()    {}
func (*GetGameInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *GetGameInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGameInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGameInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGameInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGameInfoReq.Merge(m, src)
}
func (m *GetGameInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *GetGameInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGameInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetGameInfoReq proto.InternalMessageInfo

type GetGameInfoRsp struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	LockId               []int32  `protobuf:"varint,3,rep,packed,name=LockId,proto3" json:"LockId,omitempty"`
	UnlockId             []int32  `protobuf:"varint,4,rep,packed,name=UnlockId,proto3" json:"UnlockId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetGameInfoRsp) Reset()         { *m = GetGameInfoRsp{} }
func (m *GetGameInfoRsp) String() string { return proto.CompactTextString(m) }
func (*GetGameInfoRsp) ProtoMessage()    {}
func (*GetGameInfoRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *GetGameInfoRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGameInfoRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGameInfoRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGameInfoRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGameInfoRsp.Merge(m, src)
}
func (m *GetGameInfoRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetGameInfoRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGameInfoRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetGameInfoRsp proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("newhandhall.service.v1.NewhandhallErrCode", NewhandhallErrCode_name, NewhandhallErrCode_value)
	proto.RegisterEnum("newhandhall.service.v1.TaskStatus", TaskStatus_name, TaskStatus_value)
	proto.RegisterType((*NextGiftTimeInfo)(nil), "newhandhall.service.v1.NextGiftTimeInfo")
	proto.RegisterType((*CommonRsp)(nil), "newhandhall.service.v1.CommonRsp")
	proto.RegisterType((*GetConfigReq)(nil), "newhandhall.service.v1.GetConfigReq")
	proto.RegisterType((*GetConfigRsp)(nil), "newhandhall.service.v1.GetConfigRsp")
	proto.RegisterType((*GetGuideDataReq)(nil), "newhandhall.service.v1.GetGuideDataReq")
	proto.RegisterType((*GetGuideDataRsp)(nil), "newhandhall.service.v1.GetGuideDataRsp")
	proto.RegisterType((*CompleteGuideReq)(nil), "newhandhall.service.v1.CompleteGuideReq")
	proto.RegisterType((*GetNextGiftTimeReq)(nil), "newhandhall.service.v1.GetNextGiftTimeReq")
	proto.RegisterType((*GetNextGiftTimeRsp)(nil), "newhandhall.service.v1.GetNextGiftTimeRsp")
	proto.RegisterType((*ReceiveGiftReq)(nil), "newhandhall.service.v1.ReceiveGiftReq")
	proto.RegisterType((*GetGoldConsumeAndEarnedReq)(nil), "newhandhall.service.v1.GetGoldConsumeAndEarnedReq")
	proto.RegisterType((*GetGoldConsumeAndEarnedRsp)(nil), "newhandhall.service.v1.GetGoldConsumeAndEarnedRsp")
	proto.RegisterType((*UnlockHallReq)(nil), "newhandhall.service.v1.UnlockHallReq")
	proto.RegisterType((*GetHallIsLockReq)(nil), "newhandhall.service.v1.GetHallIsLockReq")
	proto.RegisterType((*GetHallIsLockRsp)(nil), "newhandhall.service.v1.GetHallIsLockRsp")
	proto.RegisterType((*UnlockGameReq)(nil), "newhandhall.service.v1.UnlockGameReq")
	proto.RegisterType((*GetGameInfoReq)(nil), "newhandhall.service.v1.GetGameInfoReq")
	proto.RegisterType((*GetGameInfoRsp)(nil), "newhandhall.service.v1.GetGameInfoRsp")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 1002 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xae, 0x93, 0xfe, 0xe5, 0xa4, 0x4d, 0xbd, 0xc3, 0xaa, 0x4a, 0xbd, 0x25, 0xca, 0x0e, 0x4b,
	0xa9, 0x2a, 0x91, 0x88, 0x72, 0x85, 0x84, 0x90, 0x76, 0xd3, 0x2a, 0x6b, 0x58, 0x9c, 0x95, 0xdb,
	0xec, 0xc5, 0x0a, 0x21, 0x4d, 0xe3, 0x49, 0x62, 0xd5, 0x99, 0x31, 0xf6, 0xa4, 0x2c, 0x5a, 0x84,
	0x10, 0x20, 0x71, 0xc1, 0x15, 0x94, 0xbf, 0xf7, 0xe0, 0x86, 0x47, 0xd8, 0x4b, 0x24, 0x5e, 0x00,
	0x0a, 0xaf, 0xc0, 0x3d, 0xf2, 0xd8, 0x49, 0x6c, 0x37, 0x49, 0x13, 0xc2, 0x5d, 0x8e, 0xe7, 0xcc,
	0xf9, 0xbe, 0x39, 0xf3, 0xcd, 0xf9, 0x5a, 0xc8, 0x11, 0xd7, 0xae, 0xb8, 0x1e, 0x17, 0x1c, 0x6d,
	0x33, 0xfa, 0x71, 0x97, 0x30, 0xab, 0x4b, 0x1c, 0xa7, 0xe2, 0x53, 0xef, 0xc2, 0x6e, 0xd1, 0xca,
	0xc5, 0x1b, 0xda, 0xeb, 0x1d, 0x5b, 0x74, 0xfb, 0x67, 0x95, 0x16, 0xef, 0x55, 0x3b, 0xbc, 0xc3,
	0xab, 0x32, 0xfd, 0xac, 0xdf, 0x96, 0x91, 0x0c, 0xe4, 0xaf, 0xb0, 0x8c, 0xb6, 0xdb, 0xe1, 0xbc,
	0xe3, 0xd0, 0x2a, 0x71, 0xed, 0x2a, 0x61, 0x8c, 0x0b, 0x22, 0x6c, 0xce, 0xfc, 0x70, 0x15, 0xbf,
	0x03, 0xaa, 0x41, 0x9f, 0x89, 0xba, 0xdd, 0x16, 0xa7, 0x76, 0x8f, 0xea, 0xac, 0xcd, 0x51, 0x01,
	0x32, 0xba, 0x55, 0x54, 0xca, 0xca, 0xfe, 0x8a, 0x99, 0xd1, 0x2d, 0xa4, 0xc1, 0x7a, 0xb0, 0xf6,
	0x88, 0xb6, 0x45, 0x31, 0x53, 0x56, 0xf6, 0xb3, 0xe6, 0x30, 0xc6, 0x6f, 0x41, 0xae, 0xc6, 0x7b,
	0x3d, 0xce, 0x4c, 0xdf, 0x45, 0x08, 0x96, 0x6b, 0xdc, 0xa2, 0xd1, 0x56, 0xf9, 0x1b, 0x15, 0x61,
	0xed, 0x7d, 0xea, 0xfb, 0xa4, 0x43, 0xe5, 0xde, 0x9c, 0x39, 0x08, 0xf1, 0x43, 0xd8, 0xa8, 0x53,
	0x51, 0xe3, 0xac, 0x6d, 0x77, 0x4c, 0xfa, 0x51, 0x00, 0xf3, 0xd8, 0x21, 0x9f, 0x50, 0x2f, 0x02,
	0xcf, 0x9a, 0xc3, 0x18, 0xed, 0x42, 0xae, 0xd6, 0x25, 0x8c, 0x51, 0x47, 0xb7, 0x64, 0x9d, 0x15,
	0x73, 0xf4, 0x01, 0x9f, 0xc6, 0x2b, 0xcd, 0xcb, 0x03, 0x6d, 0xc3, 0x6a, 0xb8, 0xb5, 0x98, 0x95,
	0x0b, 0x51, 0x84, 0xdf, 0x83, 0xad, 0x3a, 0x15, 0xf5, 0xbe, 0x6d, 0xd1, 0x23, 0x22, 0xc8, 0x62,
	0x14, 0x9b, 0xa9, 0x62, 0x73, 0xb3, 0xbc, 0x0d, 0x2b, 0x3a, 0xb3, 0xe8, 0x33, 0x49, 0x72, 0xc5,
	0x0c, 0x03, 0x7c, 0x06, 0x6a, 0x8d, 0xf7, 0x5c, 0x87, 0x0a, 0x2a, 0x6b, 0x2f, 0x44, 0x72, 0x02,
	0xc6, 0x87, 0x80, 0xea, 0x54, 0xc4, 0x55, 0xb2, 0x18, 0x4a, 0x28, 0xaf, 0x6c, 0x39, 0x1b, 0xca,
	0x0b, 0x7f, 0xae, 0x5c, 0x07, 0x98, 0xbb, 0x3d, 0x6f, 0xc3, 0x72, 0xd0, 0x57, 0x59, 0x36, 0x7f,
	0xb8, 0x5f, 0x19, 0xff, 0x76, 0x2a, 0x69, 0xad, 0x9b, 0x72, 0x17, 0x7e, 0x0a, 0x05, 0x93, 0xb6,
	0xa8, 0x7d, 0x41, 0x83, 0xc5, 0xff, 0xe7, 0x78, 0xd1, 0xeb, 0xc1, 0x4f, 0x40, 0x0b, 0x6e, 0x9e,
	0x3b, 0x56, 0x8d, 0x33, 0xbf, 0xdf, 0xa3, 0xf7, 0x99, 0x75, 0x4c, 0x3c, 0x46, 0xad, 0xc5, 0x14,
	0xf5, 0xe9, 0xe4, 0xba, 0x73, 0x77, 0xaf, 0x08, 0x6b, 0x51, 0x11, 0x49, 0x3c, 0x6b, 0x0e, 0xc2,
	0xe0, 0x71, 0x84, 0x45, 0x8b, 0xcb, 0x72, 0x21, 0x8a, 0xb0, 0x0e, 0x9b, 0x4d, 0xe6, 0xf0, 0xd6,
	0xf9, 0x43, 0xe2, 0x38, 0x8b, 0x1d, 0xa4, 0x02, 0x6a, 0x9d, 0x8a, 0xa0, 0x8e, 0xee, 0x3f, 0xe2,
	0xad, 0xf3, 0x1b, 0xaa, 0xe1, 0x0f, 0xd2, 0xf9, 0x73, 0x1f, 0x57, 0x83, 0x75, 0xdd, 0x0f, 0xe9,
	0xcb, 0xf3, 0xae, 0x9b, 0xc3, 0x18, 0x93, 0xc1, 0xc1, 0xea, 0x64, 0x51, 0xa1, 0x6f, 0xc3, 0x6a,
	0x50, 0x64, 0xa8, 0x86, 0x28, 0xc2, 0xef, 0x42, 0x21, 0xb8, 0x39, 0x12, 0x49, 0x70, 0xa1, 0xe6,
	0x79, 0xc9, 0x5a, 0xff, 0x65, 0xf8, 0x05, 0x3d, 0x1c, 0x3e, 0xc8, 0x28, 0x0a, 0x18, 0x85, 0x6d,
	0xd0, 0x83, 0x9b, 0x0f, 0x56, 0x86, 0xf1, 0xc1, 0xaf, 0x0a, 0x20, 0x63, 0xf4, 0xbe, 0x8e, 0x3d,
	0x4f, 0x82, 0xe4, 0x61, 0xed, 0xa4, 0xdf, 0x6a, 0x51, 0xdf, 0x57, 0x97, 0xd0, 0x4b, 0x50, 0x78,
	0x4c, 0x3c, 0xd2, 0xa3, 0x82, 0x7a, 0xc7, 0x9e, 0xc7, 0x3d, 0xf5, 0x5b, 0x03, 0x6d, 0xc0, 0xda,
	0xd1, 0x83, 0x30, 0xfa, 0xce, 0x40, 0x08, 0x36, 0x83, 0x67, 0x68, 0x70, 0x71, 0xcc, 0x78, 0xbf,
	0xd3, 0x55, 0x2f, 0x0d, 0x54, 0x82, 0x9d, 0xb4, 0x9a, 0x47, 0xeb, 0xdf, 0x1b, 0x68, 0x1b, 0x6e,
	0x3d, 0xb1, 0xdd, 0x93, 0x16, 0xf7, 0x62, 0xfb, 0x7e, 0x30, 0xd0, 0x6d, 0xd8, 0x92, 0xf3, 0x4f,
	0x4e, 0xac, 0x10, 0xe1, 0x47, 0x03, 0xa9, 0x90, 0x0f, 0x67, 0x79, 0xf8, 0xe5, 0x27, 0xe3, 0xe0,
	0x3e, 0xc0, 0x29, 0xf1, 0xcf, 0x4f, 0x04, 0x11, 0x7d, 0x1f, 0x01, 0xac, 0x36, 0x59, 0xc3, 0xa5,
	0x4c, 0x5d, 0x42, 0x05, 0x80, 0x26, 0x1b, 0xcc, 0x52, 0x55, 0x41, 0x9b, 0x90, 0x6b, 0xb2, 0x68,
	0x28, 0xa8, 0x19, 0xb4, 0x0e, 0xcb, 0x47, 0x9c, 0x51, 0x35, 0x7b, 0xf8, 0x0f, 0x40, 0x3e, 0x76,
	0x7a, 0xf4, 0x1c, 0xf2, 0x0d, 0x36, 0xb4, 0x1f, 0x74, 0x6f, 0xd2, 0xe8, 0x89, 0x7b, 0x9d, 0x36,
	0x43, 0x96, 0xef, 0xe2, 0xf2, 0x17, 0xbf, 0xff, 0x7d, 0x99, 0xd1, 0x70, 0xb1, 0x1a, 0xcb, 0xae,
	0xc6, 0xd1, 0xbe, 0x56, 0xa0, 0x20, 0xe3, 0xa1, 0xb3, 0xa0, 0xd7, 0xa6, 0x94, 0x8e, 0x9b, 0x99,
	0x36, 0x5b, 0xa2, 0xef, 0xe2, 0x57, 0x24, 0x8d, 0x97, 0xf1, 0x9d, 0xeb, 0x34, 0x46, 0xb0, 0x5f,
	0x29, 0xb0, 0xd5, 0x60, 0x09, 0x33, 0x42, 0x13, 0xc7, 0x70, 0xda, 0xb3, 0xb4, 0xbb, 0x53, 0x32,
	0xc3, 0x3f, 0x2e, 0xf0, 0x3d, 0xc9, 0xa2, 0x84, 0x77, 0x53, 0x2c, 0x92, 0x90, 0x97, 0x0a, 0xdc,
	0x92, 0xcc, 0xe2, 0x93, 0x1e, 0x1d, 0x4c, 0x39, 0x6a, 0xca, 0xd8, 0xb4, 0x99, 0x73, 0x7d, 0x17,
	0xef, 0x49, 0x4e, 0x65, 0x5c, 0xba, 0xde, 0x99, 0x04, 0xfe, 0x67, 0xb0, 0xd9, 0x60, 0x31, 0x87,
	0x41, 0x7b, 0x93, 0x40, 0x92, 0x36, 0x34, 0x4b, 0x5f, 0xb0, 0xe4, 0xb0, 0x8b, 0xb5, 0x14, 0x87,
	0x38, 0xdc, 0x2f, 0x0a, 0xec, 0x84, 0xf7, 0x35, 0xc6, 0x2e, 0xd0, 0xe1, 0x34, 0x21, 0x8c, 0xf7,
	0x2d, 0x6d, 0xee, 0x3d, 0xbe, 0x8b, 0x2b, 0x92, 0xe9, 0x3e, 0xde, 0x1b, 0xa3, 0xa3, 0x71, 0xbc,
	0x9e, 0xc3, 0x46, 0x83, 0x8d, 0x5c, 0x06, 0xbd, 0x3a, 0x09, 0x33, 0xe1, 0x44, 0xb3, 0xf4, 0xec,
	0xae, 0x64, 0x72, 0x07, 0xef, 0xa4, 0x98, 0xc4, 0xc0, 0xbe, 0x91, 0x7a, 0x4e, 0x18, 0xcd, 0x64,
	0x3d, 0xa7, 0xfd, 0x4b, 0x9b, 0x31, 0x73, 0x8a, 0xac, 0x93, 0xc8, 0xb1, 0x56, 0x04, 0xb3, 0xfe,
	0xa6, 0x56, 0x44, 0xde, 0xb5, 0x78, 0x2b, 0x24, 0xd8, 0x97, 0x4a, 0x20, 0xdf, 0x98, 0xcd, 0x4c,
	0x96, 0x6f, 0xd2, 0xd7, 0xb4, 0x99, 0xf2, 0xa6, 0x68, 0x38, 0x96, 0xf6, 0x60, 0xe7, 0xc5, 0x9f,
	0xa5, 0xa5, 0x17, 0x57, 0x25, 0xe5, 0xb7, 0xab, 0x92, 0xf2, 0xc7, 0x55, 0x49, 0xf9, 0xf9, 0xaf,
	0xd2, 0xd2, 0xd3, 0x2c, 0x71, 0xed, 0xb3, 0x55, 0xf9, 0xbf, 0xcc, 0x9b, 0xff, 0x06, 0x00, 0x00,
	0xff, 0xff, 0xbe, 0x6d, 0x53, 0x5a, 0x3d, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NewhandhallClient is the client API for Newhandhall service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NewhandhallClient interface {
	///////////////////////////////////客户端的http请求/////////////////////////////////////////////////////////////////
	// 获取服务器配置
	OnGetConfig(ctx context.Context, in *GetConfigReq, opts ...grpc.CallOption) (*GetConfigRsp, error)
	// 获取引导步骤信息
	OnGetGuideData(ctx context.Context, in *GetGuideDataReq, opts ...grpc.CallOption) (*GetGuideDataRsp, error)
	// 完成引导步骤
	OnCompleteGuide(ctx context.Context, in *CompleteGuideReq, opts ...grpc.CallOption) (*CommonRsp, error)
	// 获取下次免费礼包时间
	OnGetNextGiftTime(ctx context.Context, in *GetNextGiftTimeReq, opts ...grpc.CallOption) (*GetNextGiftTimeRsp, error)
	// 获取免费礼包
	OnReceiveGift(ctx context.Context, in *ReceiveGiftReq, opts ...grpc.CallOption) (*CommonRsp, error)
	// 获取累计消耗获得货币数据
	OnGetGoldConsumeAndEarned(ctx context.Context, in *GetGoldConsumeAndEarnedReq, opts ...grpc.CallOption) (*GetGoldConsumeAndEarnedRsp, error)
	// 解锁大厅
	OnUnlockHall(ctx context.Context, in *UnlockHallReq, opts ...grpc.CallOption) (*CommonRsp, error)
	// 获取大厅解锁情况
	OnGetHallIsLock(ctx context.Context, in *GetHallIsLockReq, opts ...grpc.CallOption) (*GetHallIsLockRsp, error)
	// 解锁游戏
	OnUnlockGame(ctx context.Context, in *UnlockGameReq, opts ...grpc.CallOption) (*CommonRsp, error)
	// 获取游戏列表
	OnGetGameInfo(ctx context.Context, in *GetGameInfoReq, opts ...grpc.CallOption) (*GetGameInfoRsp, error)
}

type newhandhallClient struct {
	cc *grpc.ClientConn
}

func NewNewhandhallClient(cc *grpc.ClientConn) NewhandhallClient {
	return &newhandhallClient{cc}
}

func (c *newhandhallClient) OnGetConfig(ctx context.Context, in *GetConfigReq, opts ...grpc.CallOption) (*GetConfigRsp, error) {
	out := new(GetConfigRsp)
	err := c.cc.Invoke(ctx, "/newhandhall.service.v1.Newhandhall/OnGetConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newhandhallClient) OnGetGuideData(ctx context.Context, in *GetGuideDataReq, opts ...grpc.CallOption) (*GetGuideDataRsp, error) {
	out := new(GetGuideDataRsp)
	err := c.cc.Invoke(ctx, "/newhandhall.service.v1.Newhandhall/OnGetGuideData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newhandhallClient) OnCompleteGuide(ctx context.Context, in *CompleteGuideReq, opts ...grpc.CallOption) (*CommonRsp, error) {
	out := new(CommonRsp)
	err := c.cc.Invoke(ctx, "/newhandhall.service.v1.Newhandhall/OnCompleteGuide", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newhandhallClient) OnGetNextGiftTime(ctx context.Context, in *GetNextGiftTimeReq, opts ...grpc.CallOption) (*GetNextGiftTimeRsp, error) {
	out := new(GetNextGiftTimeRsp)
	err := c.cc.Invoke(ctx, "/newhandhall.service.v1.Newhandhall/OnGetNextGiftTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newhandhallClient) OnReceiveGift(ctx context.Context, in *ReceiveGiftReq, opts ...grpc.CallOption) (*CommonRsp, error) {
	out := new(CommonRsp)
	err := c.cc.Invoke(ctx, "/newhandhall.service.v1.Newhandhall/OnReceiveGift", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newhandhallClient) OnGetGoldConsumeAndEarned(ctx context.Context, in *GetGoldConsumeAndEarnedReq, opts ...grpc.CallOption) (*GetGoldConsumeAndEarnedRsp, error) {
	out := new(GetGoldConsumeAndEarnedRsp)
	err := c.cc.Invoke(ctx, "/newhandhall.service.v1.Newhandhall/OnGetGoldConsumeAndEarned", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newhandhallClient) OnUnlockHall(ctx context.Context, in *UnlockHallReq, opts ...grpc.CallOption) (*CommonRsp, error) {
	out := new(CommonRsp)
	err := c.cc.Invoke(ctx, "/newhandhall.service.v1.Newhandhall/OnUnlockHall", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newhandhallClient) OnGetHallIsLock(ctx context.Context, in *GetHallIsLockReq, opts ...grpc.CallOption) (*GetHallIsLockRsp, error) {
	out := new(GetHallIsLockRsp)
	err := c.cc.Invoke(ctx, "/newhandhall.service.v1.Newhandhall/OnGetHallIsLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newhandhallClient) OnUnlockGame(ctx context.Context, in *UnlockGameReq, opts ...grpc.CallOption) (*CommonRsp, error) {
	out := new(CommonRsp)
	err := c.cc.Invoke(ctx, "/newhandhall.service.v1.Newhandhall/OnUnlockGame", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newhandhallClient) OnGetGameInfo(ctx context.Context, in *GetGameInfoReq, opts ...grpc.CallOption) (*GetGameInfoRsp, error) {
	out := new(GetGameInfoRsp)
	err := c.cc.Invoke(ctx, "/newhandhall.service.v1.Newhandhall/OnGetGameInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NewhandhallServer is the server API for Newhandhall service.
type NewhandhallServer interface {
	///////////////////////////////////客户端的http请求/////////////////////////////////////////////////////////////////
	// 获取服务器配置
	OnGetConfig(context.Context, *GetConfigReq) (*GetConfigRsp, error)
	// 获取引导步骤信息
	OnGetGuideData(context.Context, *GetGuideDataReq) (*GetGuideDataRsp, error)
	// 完成引导步骤
	OnCompleteGuide(context.Context, *CompleteGuideReq) (*CommonRsp, error)
	// 获取下次免费礼包时间
	OnGetNextGiftTime(context.Context, *GetNextGiftTimeReq) (*GetNextGiftTimeRsp, error)
	// 获取免费礼包
	OnReceiveGift(context.Context, *ReceiveGiftReq) (*CommonRsp, error)
	// 获取累计消耗获得货币数据
	OnGetGoldConsumeAndEarned(context.Context, *GetGoldConsumeAndEarnedReq) (*GetGoldConsumeAndEarnedRsp, error)
	// 解锁大厅
	OnUnlockHall(context.Context, *UnlockHallReq) (*CommonRsp, error)
	// 获取大厅解锁情况
	OnGetHallIsLock(context.Context, *GetHallIsLockReq) (*GetHallIsLockRsp, error)
	// 解锁游戏
	OnUnlockGame(context.Context, *UnlockGameReq) (*CommonRsp, error)
	// 获取游戏列表
	OnGetGameInfo(context.Context, *GetGameInfoReq) (*GetGameInfoRsp, error)
}

// UnimplementedNewhandhallServer can be embedded to have forward compatible implementations.
type UnimplementedNewhandhallServer struct {
}

func (*UnimplementedNewhandhallServer) OnGetConfig(ctx context.Context, req *GetConfigReq) (*GetConfigRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnGetConfig not implemented")
}
func (*UnimplementedNewhandhallServer) OnGetGuideData(ctx context.Context, req *GetGuideDataReq) (*GetGuideDataRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnGetGuideData not implemented")
}
func (*UnimplementedNewhandhallServer) OnCompleteGuide(ctx context.Context, req *CompleteGuideReq) (*CommonRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnCompleteGuide not implemented")
}
func (*UnimplementedNewhandhallServer) OnGetNextGiftTime(ctx context.Context, req *GetNextGiftTimeReq) (*GetNextGiftTimeRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnGetNextGiftTime not implemented")
}
func (*UnimplementedNewhandhallServer) OnReceiveGift(ctx context.Context, req *ReceiveGiftReq) (*CommonRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnReceiveGift not implemented")
}
func (*UnimplementedNewhandhallServer) OnGetGoldConsumeAndEarned(ctx context.Context, req *GetGoldConsumeAndEarnedReq) (*GetGoldConsumeAndEarnedRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnGetGoldConsumeAndEarned not implemented")
}
func (*UnimplementedNewhandhallServer) OnUnlockHall(ctx context.Context, req *UnlockHallReq) (*CommonRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnUnlockHall not implemented")
}
func (*UnimplementedNewhandhallServer) OnGetHallIsLock(ctx context.Context, req *GetHallIsLockReq) (*GetHallIsLockRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnGetHallIsLock not implemented")
}
func (*UnimplementedNewhandhallServer) OnUnlockGame(ctx context.Context, req *UnlockGameReq) (*CommonRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnUnlockGame not implemented")
}
func (*UnimplementedNewhandhallServer) OnGetGameInfo(ctx context.Context, req *GetGameInfoReq) (*GetGameInfoRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnGetGameInfo not implemented")
}

func RegisterNewhandhallServer(s *grpc.Server, srv NewhandhallServer) {
	s.RegisterService(&_Newhandhall_serviceDesc, srv)
}

func _Newhandhall_OnGetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewhandhallServer).OnGetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newhandhall.service.v1.Newhandhall/OnGetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewhandhallServer).OnGetConfig(ctx, req.(*GetConfigReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Newhandhall_OnGetGuideData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGuideDataReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewhandhallServer).OnGetGuideData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newhandhall.service.v1.Newhandhall/OnGetGuideData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewhandhallServer).OnGetGuideData(ctx, req.(*GetGuideDataReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Newhandhall_OnCompleteGuide_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteGuideReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewhandhallServer).OnCompleteGuide(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newhandhall.service.v1.Newhandhall/OnCompleteGuide",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewhandhallServer).OnCompleteGuide(ctx, req.(*CompleteGuideReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Newhandhall_OnGetNextGiftTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNextGiftTimeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewhandhallServer).OnGetNextGiftTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newhandhall.service.v1.Newhandhall/OnGetNextGiftTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewhandhallServer).OnGetNextGiftTime(ctx, req.(*GetNextGiftTimeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Newhandhall_OnReceiveGift_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiveGiftReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewhandhallServer).OnReceiveGift(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newhandhall.service.v1.Newhandhall/OnReceiveGift",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewhandhallServer).OnReceiveGift(ctx, req.(*ReceiveGiftReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Newhandhall_OnGetGoldConsumeAndEarned_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGoldConsumeAndEarnedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewhandhallServer).OnGetGoldConsumeAndEarned(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newhandhall.service.v1.Newhandhall/OnGetGoldConsumeAndEarned",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewhandhallServer).OnGetGoldConsumeAndEarned(ctx, req.(*GetGoldConsumeAndEarnedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Newhandhall_OnUnlockHall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockHallReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewhandhallServer).OnUnlockHall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newhandhall.service.v1.Newhandhall/OnUnlockHall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewhandhallServer).OnUnlockHall(ctx, req.(*UnlockHallReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Newhandhall_OnGetHallIsLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHallIsLockReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewhandhallServer).OnGetHallIsLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newhandhall.service.v1.Newhandhall/OnGetHallIsLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewhandhallServer).OnGetHallIsLock(ctx, req.(*GetHallIsLockReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Newhandhall_OnUnlockGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockGameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewhandhallServer).OnUnlockGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newhandhall.service.v1.Newhandhall/OnUnlockGame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewhandhallServer).OnUnlockGame(ctx, req.(*UnlockGameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Newhandhall_OnGetGameInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGameInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewhandhallServer).OnGetGameInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/newhandhall.service.v1.Newhandhall/OnGetGameInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewhandhallServer).OnGetGameInfo(ctx, req.(*GetGameInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Newhandhall_serviceDesc = grpc.ServiceDesc{
	ServiceName: "newhandhall.service.v1.Newhandhall",
	HandlerType: (*NewhandhallServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnGetConfig",
			Handler:    _Newhandhall_OnGetConfig_Handler,
		},
		{
			MethodName: "OnGetGuideData",
			Handler:    _Newhandhall_OnGetGuideData_Handler,
		},
		{
			MethodName: "OnCompleteGuide",
			Handler:    _Newhandhall_OnCompleteGuide_Handler,
		},
		{
			MethodName: "OnGetNextGiftTime",
			Handler:    _Newhandhall_OnGetNextGiftTime_Handler,
		},
		{
			MethodName: "OnReceiveGift",
			Handler:    _Newhandhall_OnReceiveGift_Handler,
		},
		{
			MethodName: "OnGetGoldConsumeAndEarned",
			Handler:    _Newhandhall_OnGetGoldConsumeAndEarned_Handler,
		},
		{
			MethodName: "OnUnlockHall",
			Handler:    _Newhandhall_OnUnlockHall_Handler,
		},
		{
			MethodName: "OnGetHallIsLock",
			Handler:    _Newhandhall_OnGetHallIsLock_Handler,
		},
		{
			MethodName: "OnUnlockGame",
			Handler:    _Newhandhall_OnUnlockGame_Handler,
		},
		{
			MethodName: "OnGetGameInfo",
			Handler:    _Newhandhall_OnGetGameInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *NextGiftTimeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextGiftTimeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextGiftTimeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TimeLeft != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TimeLeft))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommonRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetConfigReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChannelId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ChannelId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetConfigRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetGuideDataReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGuideDataReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetGuideDataReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChannelId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ChannelId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetGuideDataRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGuideDataRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetGuideDataRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompleteGuideReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompleteGuideReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteGuideReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if m.ChannelId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ChannelId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetNextGiftTimeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNextGiftTimeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetNextGiftTimeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		dAtA2 := make([]byte, len(m.Id)*10)
		var j1 int
		for _, num1 := range m.Id {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintApi(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.ChannelId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ChannelId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetNextGiftTimeRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNextGiftTimeRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetNextGiftTimeRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReceiveGiftReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveGiftReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReceiveGiftReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if m.ChannelId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ChannelId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetGoldConsumeAndEarnedReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGoldConsumeAndEarnedReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetGoldConsumeAndEarnedReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChannelId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ChannelId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetGoldConsumeAndEarnedRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGoldConsumeAndEarnedRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetGoldConsumeAndEarnedRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Earned != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Earned))
		i--
		dAtA[i] = 0x20
	}
	if m.Consume != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Consume))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnlockHallReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockHallReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockHallReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChannelId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ChannelId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetHallIsLockReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHallIsLockReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetHallIsLockReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetHallIsLockRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHallIsLockRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetHallIsLockRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsUnlock {
		i--
		if m.IsUnlock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnlockGameReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockGameReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockGameReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if m.ChannelId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ChannelId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetGameInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGameInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetGameInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChannelId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ChannelId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetGameInfoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGameInfoRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetGameInfoRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UnlockId) > 0 {
		dAtA4 := make([]byte, len(m.UnlockId)*10)
		var j3 int
		for _, num1 := range m.UnlockId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintApi(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LockId) > 0 {
		dAtA6 := make([]byte, len(m.LockId)*10)
		var j5 int
		for _, num1 := range m.LockId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintApi(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NextGiftTimeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.TimeLeft != 0 {
		n += 1 + sovApi(uint64(m.TimeLeft))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetConfigReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovApi(uint64(m.ChannelId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetConfigRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetGuideDataReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovApi(uint64(m.ChannelId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetGuideDataRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovApi(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompleteGuideReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovApi(uint64(m.ChannelId))
	}
	if m.Index != 0 {
		n += 1 + sovApi(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetNextGiftTimeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovApi(uint64(m.ChannelId))
	}
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetNextGiftTimeRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReceiveGiftReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovApi(uint64(m.ChannelId))
	}
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetGoldConsumeAndEarnedReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovApi(uint64(m.ChannelId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetGoldConsumeAndEarnedRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Consume != 0 {
		n += 1 + sovApi(uint64(m.Consume))
	}
	if m.Earned != 0 {
		n += 1 + sovApi(uint64(m.Earned))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnlockHallReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovApi(uint64(m.ChannelId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetHallIsLockReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetHallIsLockRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IsUnlock {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnlockGameReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovApi(uint64(m.ChannelId))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetGameInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovApi(uint64(m.PlayerId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovApi(uint64(m.ChannelId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetGameInfoRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.LockId) > 0 {
		l = 0
		for _, e := range m.LockId {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.UnlockId) > 0 {
		l = 0
		for _, e := range m.UnlockId {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NextGiftTimeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextGiftTimeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextGiftTimeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLeft", wireType)
			}
			m.TimeLeft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeLeft |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGuideDataReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGuideDataReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGuideDataReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGuideDataRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGuideDataRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGuideDataRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompleteGuideReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompleteGuideReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompleteGuideReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNextGiftTimeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNextGiftTimeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNextGiftTimeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Id) == 0 {
					m.Id = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNextGiftTimeRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNextGiftTimeRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNextGiftTimeRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &NextGiftTimeInfo{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveGiftReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveGiftReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveGiftReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGoldConsumeAndEarnedReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGoldConsumeAndEarnedReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGoldConsumeAndEarnedReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGoldConsumeAndEarnedRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGoldConsumeAndEarnedRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGoldConsumeAndEarnedRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consume", wireType)
			}
			m.Consume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Consume |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Earned", wireType)
			}
			m.Earned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Earned |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockHallReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockHallReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockHallReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHallIsLockReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHallIsLockReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHallIsLockReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHallIsLockRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHallIsLockRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHallIsLockRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnlock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUnlock = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockGameReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockGameReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockGameReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGameInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGameInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGameInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGameInfoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGameInfoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGameInfoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LockId = append(m.LockId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LockId) == 0 {
					m.LockId = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LockId = append(m.LockId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LockId", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnlockId = append(m.UnlockId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnlockId) == 0 {
					m.UnlockId = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnlockId = append(m.UnlockId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
