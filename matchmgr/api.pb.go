// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

// package 命名使用 {appid}.{version} 的方式, version 形如 v1, v2 ..

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ErrCode int32

const (
	ErrCode_Success            ErrCode = 0
	ErrCode_Failed             ErrCode = 1
	ErrCode_TimeOut            ErrCode = 2
	ErrCode_InvalidParameter   ErrCode = 3
	ErrCode_DeserializedFailed ErrCode = 4
	ErrCode_InvalidToken       ErrCode = 5
	ErrCode_NotExistPlayer     ErrCode = 6
	ErrCode_NotMatchTime       ErrCode = 7
	ErrCode_NoGameConf         ErrCode = 8
)

var ErrCode_name = map[int32]string{
	0: "Success",
	1: "Failed",
	2: "TimeOut",
	3: "InvalidParameter",
	4: "DeserializedFailed",
	5: "InvalidToken",
	6: "NotExistPlayer",
	7: "NotMatchTime",
	8: "NoGameConf",
}

var ErrCode_value = map[string]int32{
	"Success":            0,
	"Failed":             1,
	"TimeOut":            2,
	"InvalidParameter":   3,
	"DeserializedFailed": 4,
	"InvalidToken":       5,
	"NotExistPlayer":     6,
	"NotMatchTime":       7,
	"NoGameConf":         8,
}

func (x ErrCode) Enum() *ErrCode {
	p := new(ErrCode)
	*p = x
	return p
}

func (x ErrCode) String() string {
	return proto.EnumName(ErrCode_name, int32(x))
}

func (x *ErrCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ErrCode_value, data, "ErrCode")
	if err != nil {
		return err
	}
	*x = ErrCode(value)
	return nil
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

type MsgCode int32

const (
	// 从10000开始，防止与大厅冲突
	MsgCode_MatchCodeMatchResult MsgCode = 10000
)

var MsgCode_name = map[int32]string{
	10000: "MatchCodeMatchResult",
}

var MsgCode_value = map[string]int32{
	"MatchCodeMatchResult": 10000,
}

func (x MsgCode) Enum() *MsgCode {
	p := new(MsgCode)
	*p = x
	return p
}

func (x MsgCode) String() string {
	return proto.EnumName(MsgCode_name, int32(x))
}

func (x *MsgCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MsgCode_value, data, "MsgCode")
	if err != nil {
		return err
	}
	*x = MsgCode(value)
	return nil
}

func (MsgCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}

type Object3 struct {
	Key                  *int32   `protobuf:"varint,1,req,name=key" json:"key,omitempty"`
	Value                *int64   `protobuf:"varint,2,req,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Object3) Reset()         { *m = Object3{} }
func (m *Object3) String() string { return proto.CompactTextString(m) }
func (*Object3) ProtoMessage()    {}
func (*Object3) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *Object3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Object3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Object3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object3.Merge(m, src)
}
func (m *Object3) XXX_Size() int {
	return m.Size()
}
func (m *Object3) XXX_DiscardUnknown() {
	xxx_messageInfo_Object3.DiscardUnknown(m)
}

var xxx_messageInfo_Object3 proto.InternalMessageInfo

func (m *Object3) GetKey() int32 {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return 0
}

func (m *Object3) GetValue() int64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

type CSHBonusPool struct {
	MathcId              *int32   `protobuf:"varint,1,req,name=mathcId" json:"mathcId,omitempty"`
	TimeId               *int32   `protobuf:"varint,2,req,name=timeId" json:"timeId,omitempty"`
	PlayerId             *int64   `protobuf:"varint,3,req,name=playerId" json:"playerId,omitempty"`
	GameId               *int32   `protobuf:"varint,4,opt,name=gameId,def=10086" json:"gameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSHBonusPool) Reset()         { *m = CSHBonusPool{} }
func (m *CSHBonusPool) String() string { return proto.CompactTextString(m) }
func (*CSHBonusPool) ProtoMessage()    {}
func (*CSHBonusPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *CSHBonusPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSHBonusPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSHBonusPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSHBonusPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSHBonusPool.Merge(m, src)
}
func (m *CSHBonusPool) XXX_Size() int {
	return m.Size()
}
func (m *CSHBonusPool) XXX_DiscardUnknown() {
	xxx_messageInfo_CSHBonusPool.DiscardUnknown(m)
}

var xxx_messageInfo_CSHBonusPool proto.InternalMessageInfo

const Default_CSHBonusPool_GameId int32 = 10086

func (m *CSHBonusPool) GetMathcId() int32 {
	if m != nil && m.MathcId != nil {
		return *m.MathcId
	}
	return 0
}

func (m *CSHBonusPool) GetTimeId() int32 {
	if m != nil && m.TimeId != nil {
		return *m.TimeId
	}
	return 0
}

func (m *CSHBonusPool) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *CSHBonusPool) GetGameId() int32 {
	if m != nil && m.GameId != nil {
		return *m.GameId
	}
	return Default_CSHBonusPool_GameId
}

type HBonusPool struct {
	MatchId              *int32   `protobuf:"varint,1,req,name=matchId" json:"matchId,omitempty"`
	Name                 *string  `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	Value                *int64   `protobuf:"varint,3,opt,name=value" json:"value,omitempty"`
	Count                *int64   `protobuf:"varint,4,opt,name=count" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HBonusPool) Reset()         { *m = HBonusPool{} }
func (m *HBonusPool) String() string { return proto.CompactTextString(m) }
func (*HBonusPool) ProtoMessage()    {}
func (*HBonusPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *HBonusPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HBonusPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HBonusPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HBonusPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HBonusPool.Merge(m, src)
}
func (m *HBonusPool) XXX_Size() int {
	return m.Size()
}
func (m *HBonusPool) XXX_DiscardUnknown() {
	xxx_messageInfo_HBonusPool.DiscardUnknown(m)
}

var xxx_messageInfo_HBonusPool proto.InternalMessageInfo

func (m *HBonusPool) GetMatchId() int32 {
	if m != nil && m.MatchId != nil {
		return *m.MatchId
	}
	return 0
}

func (m *HBonusPool) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *HBonusPool) GetValue() int64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

func (m *HBonusPool) GetCount() int64 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

type SCHBonusPool struct {
	Pool                 []*HBonusPool `protobuf:"bytes,1,rep,name=pool" json:"pool,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SCHBonusPool) Reset()         { *m = SCHBonusPool{} }
func (m *SCHBonusPool) String() string { return proto.CompactTextString(m) }
func (*SCHBonusPool) ProtoMessage()    {}
func (*SCHBonusPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *SCHBonusPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCHBonusPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCHBonusPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCHBonusPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCHBonusPool.Merge(m, src)
}
func (m *SCHBonusPool) XXX_Size() int {
	return m.Size()
}
func (m *SCHBonusPool) XXX_DiscardUnknown() {
	xxx_messageInfo_SCHBonusPool.DiscardUnknown(m)
}

var xxx_messageInfo_SCHBonusPool proto.InternalMessageInfo

func (m *SCHBonusPool) GetPool() []*HBonusPool {
	if m != nil {
		return m.Pool
	}
	return nil
}

type CSHRankBar struct {
	MathcId              *int32   `protobuf:"varint,1,req,name=mathcId" json:"mathcId,omitempty"`
	TimeId               *int32   `protobuf:"varint,2,req,name=timeId" json:"timeId,omitempty"`
	PlayerId             *int64   `protobuf:"varint,3,req,name=playerId" json:"playerId,omitempty"`
	GameId               *int32   `protobuf:"varint,4,opt,name=gameId,def=10086" json:"gameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSHRankBar) Reset()         { *m = CSHRankBar{} }
func (m *CSHRankBar) String() string { return proto.CompactTextString(m) }
func (*CSHRankBar) ProtoMessage()    {}
func (*CSHRankBar) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *CSHRankBar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSHRankBar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSHRankBar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSHRankBar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSHRankBar.Merge(m, src)
}
func (m *CSHRankBar) XXX_Size() int {
	return m.Size()
}
func (m *CSHRankBar) XXX_DiscardUnknown() {
	xxx_messageInfo_CSHRankBar.DiscardUnknown(m)
}

var xxx_messageInfo_CSHRankBar proto.InternalMessageInfo

const Default_CSHRankBar_GameId int32 = 10086

func (m *CSHRankBar) GetMathcId() int32 {
	if m != nil && m.MathcId != nil {
		return *m.MathcId
	}
	return 0
}

func (m *CSHRankBar) GetTimeId() int32 {
	if m != nil && m.TimeId != nil {
		return *m.TimeId
	}
	return 0
}

func (m *CSHRankBar) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *CSHRankBar) GetGameId() int32 {
	if m != nil && m.GameId != nil {
		return *m.GameId
	}
	return Default_CSHRankBar_GameId
}

type SCHRankBar struct {
	Idx                  *int64   `protobuf:"varint,1,req,name=idx" json:"idx,omitempty"`
	Total                *int64   `protobuf:"varint,2,req,name=total" json:"total,omitempty"`
	Reaward              *int64   `protobuf:"varint,3,req,name=reaward" json:"reaward,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCHRankBar) Reset()         { *m = SCHRankBar{} }
func (m *SCHRankBar) String() string { return proto.CompactTextString(m) }
func (*SCHRankBar) ProtoMessage()    {}
func (*SCHRankBar) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *SCHRankBar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCHRankBar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCHRankBar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCHRankBar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCHRankBar.Merge(m, src)
}
func (m *SCHRankBar) XXX_Size() int {
	return m.Size()
}
func (m *SCHRankBar) XXX_DiscardUnknown() {
	xxx_messageInfo_SCHRankBar.DiscardUnknown(m)
}

var xxx_messageInfo_SCHRankBar proto.InternalMessageInfo

func (m *SCHRankBar) GetIdx() int64 {
	if m != nil && m.Idx != nil {
		return *m.Idx
	}
	return 0
}

func (m *SCHRankBar) GetTotal() int64 {
	if m != nil && m.Total != nil {
		return *m.Total
	}
	return 0
}

func (m *SCHRankBar) GetReaward() int64 {
	if m != nil && m.Reaward != nil {
		return *m.Reaward
	}
	return 0
}

type RealRank struct {
	Idx                  *int64     `protobuf:"varint,1,req,name=idx" json:"idx,omitempty"`
	Icon                 *string    `protobuf:"bytes,2,req,name=icon" json:"icon,omitempty"`
	Name                 *string    `protobuf:"bytes,3,req,name=name" json:"name,omitempty"`
	Score                *int64     `protobuf:"varint,4,opt,name=score" json:"score,omitempty"`
	Goods                []*Object3 `protobuf:"bytes,5,rep,name=goods" json:"goods,omitempty"`
	BigGiftId            *string    `protobuf:"bytes,6,req,name=bigGiftId" json:"bigGiftId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RealRank) Reset()         { *m = RealRank{} }
func (m *RealRank) String() string { return proto.CompactTextString(m) }
func (*RealRank) ProtoMessage()    {}
func (*RealRank) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *RealRank) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RealRank) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RealRank.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RealRank) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RealRank.Merge(m, src)
}
func (m *RealRank) XXX_Size() int {
	return m.Size()
}
func (m *RealRank) XXX_DiscardUnknown() {
	xxx_messageInfo_RealRank.DiscardUnknown(m)
}

var xxx_messageInfo_RealRank proto.InternalMessageInfo

func (m *RealRank) GetIdx() int64 {
	if m != nil && m.Idx != nil {
		return *m.Idx
	}
	return 0
}

func (m *RealRank) GetIcon() string {
	if m != nil && m.Icon != nil {
		return *m.Icon
	}
	return ""
}

func (m *RealRank) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *RealRank) GetScore() int64 {
	if m != nil && m.Score != nil {
		return *m.Score
	}
	return 0
}

func (m *RealRank) GetGoods() []*Object3 {
	if m != nil {
		return m.Goods
	}
	return nil
}

func (m *RealRank) GetBigGiftId() string {
	if m != nil && m.BigGiftId != nil {
		return *m.BigGiftId
	}
	return ""
}

type CSHRealRank struct {
	PlayerId             *int64   `protobuf:"varint,1,req,name=playerId" json:"playerId,omitempty"`
	MathcId              *int32   `protobuf:"varint,2,req,name=mathcId" json:"mathcId,omitempty"`
	TimeId               *int32   `protobuf:"varint,3,req,name=timeId" json:"timeId,omitempty"`
	GameId               *int32   `protobuf:"varint,4,opt,name=gameId,def=10086" json:"gameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSHRealRank) Reset()         { *m = CSHRealRank{} }
func (m *CSHRealRank) String() string { return proto.CompactTextString(m) }
func (*CSHRealRank) ProtoMessage()    {}
func (*CSHRealRank) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *CSHRealRank) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSHRealRank) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSHRealRank.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSHRealRank) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSHRealRank.Merge(m, src)
}
func (m *CSHRealRank) XXX_Size() int {
	return m.Size()
}
func (m *CSHRealRank) XXX_DiscardUnknown() {
	xxx_messageInfo_CSHRealRank.DiscardUnknown(m)
}

var xxx_messageInfo_CSHRealRank proto.InternalMessageInfo

const Default_CSHRealRank_GameId int32 = 10086

func (m *CSHRealRank) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *CSHRealRank) GetMathcId() int32 {
	if m != nil && m.MathcId != nil {
		return *m.MathcId
	}
	return 0
}

func (m *CSHRealRank) GetTimeId() int32 {
	if m != nil && m.TimeId != nil {
		return *m.TimeId
	}
	return 0
}

func (m *CSHRealRank) GetGameId() int32 {
	if m != nil && m.GameId != nil {
		return *m.GameId
	}
	return Default_CSHRealRank_GameId
}

type SCHRealRank struct {
	RealRank             []*RealRank `protobuf:"bytes,1,rep,name=real_rank,json=realRank" json:"real_rank,omitempty"`
	OnselfRank           *RealRank   `protobuf:"bytes,2,opt,name=onself_rank,json=onselfRank" json:"onself_rank,omitempty"`
	TotalNum             *int64      `protobuf:"varint,3,opt,name=total_num,json=totalNum" json:"total_num,omitempty"`
	ScoreAddition        *int32      `protobuf:"varint,4,opt,name=score_addition,json=scoreAddition" json:"score_addition,omitempty"`
	RewardAddition       *int32      `protobuf:"varint,5,opt,name=reward_addition,json=rewardAddition" json:"reward_addition,omitempty"`
	CardAddition         *int64      `protobuf:"varint,6,opt,name=card_addition,json=cardAddition" json:"card_addition,omitempty"`
	VipAddition          *int32      `protobuf:"varint,7,opt,name=vip_addition,json=vipAddition" json:"vip_addition,omitempty"`
	SplitAwardId         *int32      `protobuf:"varint,8,opt,name=split_award_id,json=splitAwardId" json:"split_award_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SCHRealRank) Reset()         { *m = SCHRealRank{} }
func (m *SCHRealRank) String() string { return proto.CompactTextString(m) }
func (*SCHRealRank) ProtoMessage()    {}
func (*SCHRealRank) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *SCHRealRank) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCHRealRank) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCHRealRank.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCHRealRank) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCHRealRank.Merge(m, src)
}
func (m *SCHRealRank) XXX_Size() int {
	return m.Size()
}
func (m *SCHRealRank) XXX_DiscardUnknown() {
	xxx_messageInfo_SCHRealRank.DiscardUnknown(m)
}

var xxx_messageInfo_SCHRealRank proto.InternalMessageInfo

func (m *SCHRealRank) GetRealRank() []*RealRank {
	if m != nil {
		return m.RealRank
	}
	return nil
}

func (m *SCHRealRank) GetOnselfRank() *RealRank {
	if m != nil {
		return m.OnselfRank
	}
	return nil
}

func (m *SCHRealRank) GetTotalNum() int64 {
	if m != nil && m.TotalNum != nil {
		return *m.TotalNum
	}
	return 0
}

func (m *SCHRealRank) GetScoreAddition() int32 {
	if m != nil && m.ScoreAddition != nil {
		return *m.ScoreAddition
	}
	return 0
}

func (m *SCHRealRank) GetRewardAddition() int32 {
	if m != nil && m.RewardAddition != nil {
		return *m.RewardAddition
	}
	return 0
}

func (m *SCHRealRank) GetCardAddition() int64 {
	if m != nil && m.CardAddition != nil {
		return *m.CardAddition
	}
	return 0
}

func (m *SCHRealRank) GetVipAddition() int32 {
	if m != nil && m.VipAddition != nil {
		return *m.VipAddition
	}
	return 0
}

func (m *SCHRealRank) GetSplitAwardId() int32 {
	if m != nil && m.SplitAwardId != nil {
		return *m.SplitAwardId
	}
	return 0
}

type Reward struct {
	Idxl                 *int64     `protobuf:"varint,1,req,name=idxl" json:"idxl,omitempty"`
	Idxr                 *int64     `protobuf:"varint,2,req,name=idxr" json:"idxr,omitempty"`
	Goods                []*Object3 `protobuf:"bytes,3,rep,name=goods" json:"goods,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Reward) Reset()         { *m = Reward{} }
func (m *Reward) String() string { return proto.CompactTextString(m) }
func (*Reward) ProtoMessage()    {}
func (*Reward) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *Reward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reward.Merge(m, src)
}
func (m *Reward) XXX_Size() int {
	return m.Size()
}
func (m *Reward) XXX_DiscardUnknown() {
	xxx_messageInfo_Reward.DiscardUnknown(m)
}

var xxx_messageInfo_Reward proto.InternalMessageInfo

func (m *Reward) GetIdxl() int64 {
	if m != nil && m.Idxl != nil {
		return *m.Idxl
	}
	return 0
}

func (m *Reward) GetIdxr() int64 {
	if m != nil && m.Idxr != nil {
		return *m.Idxr
	}
	return 0
}

func (m *Reward) GetGoods() []*Object3 {
	if m != nil {
		return m.Goods
	}
	return nil
}

type CSHReward struct {
	MathcId              *int32   `protobuf:"varint,1,req,name=mathcId" json:"mathcId,omitempty"`
	TimeId               *int32   `protobuf:"varint,2,req,name=timeId" json:"timeId,omitempty"`
	GameId               *int32   `protobuf:"varint,3,opt,name=gameId,def=10086" json:"gameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSHReward) Reset()         { *m = CSHReward{} }
func (m *CSHReward) String() string { return proto.CompactTextString(m) }
func (*CSHReward) ProtoMessage()    {}
func (*CSHReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *CSHReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSHReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSHReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSHReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSHReward.Merge(m, src)
}
func (m *CSHReward) XXX_Size() int {
	return m.Size()
}
func (m *CSHReward) XXX_DiscardUnknown() {
	xxx_messageInfo_CSHReward.DiscardUnknown(m)
}

var xxx_messageInfo_CSHReward proto.InternalMessageInfo

const Default_CSHReward_GameId int32 = 10086

func (m *CSHReward) GetMathcId() int32 {
	if m != nil && m.MathcId != nil {
		return *m.MathcId
	}
	return 0
}

func (m *CSHReward) GetTimeId() int32 {
	if m != nil && m.TimeId != nil {
		return *m.TimeId
	}
	return 0
}

func (m *CSHReward) GetGameId() int32 {
	if m != nil && m.GameId != nil {
		return *m.GameId
	}
	return Default_CSHReward_GameId
}

type SCHReward struct {
	Rewards              []*Reward `protobuf:"bytes,1,rep,name=rewards" json:"rewards,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SCHReward) Reset()         { *m = SCHReward{} }
func (m *SCHReward) String() string { return proto.CompactTextString(m) }
func (*SCHReward) ProtoMessage()    {}
func (*SCHReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *SCHReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCHReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCHReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCHReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCHReward.Merge(m, src)
}
func (m *SCHReward) XXX_Size() int {
	return m.Size()
}
func (m *SCHReward) XXX_DiscardUnknown() {
	xxx_messageInfo_SCHReward.DiscardUnknown(m)
}

var xxx_messageInfo_SCHReward proto.InternalMessageInfo

func (m *SCHReward) GetRewards() []*Reward {
	if m != nil {
		return m.Rewards
	}
	return nil
}

type CSHMatchInfoTip struct {
	GameId               *int32   `protobuf:"varint,1,opt,name=gameId,def=10086" json:"gameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSHMatchInfoTip) Reset()         { *m = CSHMatchInfoTip{} }
func (m *CSHMatchInfoTip) String() string { return proto.CompactTextString(m) }
func (*CSHMatchInfoTip) ProtoMessage()    {}
func (*CSHMatchInfoTip) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *CSHMatchInfoTip) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSHMatchInfoTip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSHMatchInfoTip.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSHMatchInfoTip) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSHMatchInfoTip.Merge(m, src)
}
func (m *CSHMatchInfoTip) XXX_Size() int {
	return m.Size()
}
func (m *CSHMatchInfoTip) XXX_DiscardUnknown() {
	xxx_messageInfo_CSHMatchInfoTip.DiscardUnknown(m)
}

var xxx_messageInfo_CSHMatchInfoTip proto.InternalMessageInfo

const Default_CSHMatchInfoTip_GameId int32 = 10086

func (m *CSHMatchInfoTip) GetGameId() int32 {
	if m != nil && m.GameId != nil {
		return *m.GameId
	}
	return Default_CSHMatchInfoTip_GameId
}

type MatchInfoTip struct {
	Name                 *string    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	MathcId              *int32     `protobuf:"varint,2,opt,name=mathcId" json:"mathcId,omitempty"`
	Time                 *string    `protobuf:"bytes,3,req,name=time" json:"time,omitempty"`
	Goods                []*Object3 `protobuf:"bytes,4,rep,name=goods" json:"goods,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MatchInfoTip) Reset()         { *m = MatchInfoTip{} }
func (m *MatchInfoTip) String() string { return proto.CompactTextString(m) }
func (*MatchInfoTip) ProtoMessage()    {}
func (*MatchInfoTip) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *MatchInfoTip) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchInfoTip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchInfoTip.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchInfoTip) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchInfoTip.Merge(m, src)
}
func (m *MatchInfoTip) XXX_Size() int {
	return m.Size()
}
func (m *MatchInfoTip) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchInfoTip.DiscardUnknown(m)
}

var xxx_messageInfo_MatchInfoTip proto.InternalMessageInfo

func (m *MatchInfoTip) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *MatchInfoTip) GetMathcId() int32 {
	if m != nil && m.MathcId != nil {
		return *m.MathcId
	}
	return 0
}

func (m *MatchInfoTip) GetTime() string {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return ""
}

func (m *MatchInfoTip) GetGoods() []*Object3 {
	if m != nil {
		return m.Goods
	}
	return nil
}

type SCHMatchInfoTip struct {
	MatchTips            []*MatchInfoTip `protobuf:"bytes,1,rep,name=matchTips" json:"matchTips,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SCHMatchInfoTip) Reset()         { *m = SCHMatchInfoTip{} }
func (m *SCHMatchInfoTip) String() string { return proto.CompactTextString(m) }
func (*SCHMatchInfoTip) ProtoMessage()    {}
func (*SCHMatchInfoTip) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *SCHMatchInfoTip) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCHMatchInfoTip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCHMatchInfoTip.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCHMatchInfoTip) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCHMatchInfoTip.Merge(m, src)
}
func (m *SCHMatchInfoTip) XXX_Size() int {
	return m.Size()
}
func (m *SCHMatchInfoTip) XXX_DiscardUnknown() {
	xxx_messageInfo_SCHMatchInfoTip.DiscardUnknown(m)
}

var xxx_messageInfo_SCHMatchInfoTip proto.InternalMessageInfo

func (m *SCHMatchInfoTip) GetMatchTips() []*MatchInfoTip {
	if m != nil {
		return m.MatchTips
	}
	return nil
}

type CSHMatchInfo struct {
	PlayerId             *int64   `protobuf:"varint,1,req,name=playerId" json:"playerId,omitempty"`
	GameId               *int32   `protobuf:"varint,2,opt,name=gameId,def=10086" json:"gameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSHMatchInfo) Reset()         { *m = CSHMatchInfo{} }
func (m *CSHMatchInfo) String() string { return proto.CompactTextString(m) }
func (*CSHMatchInfo) ProtoMessage()    {}
func (*CSHMatchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *CSHMatchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSHMatchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSHMatchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSHMatchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSHMatchInfo.Merge(m, src)
}
func (m *CSHMatchInfo) XXX_Size() int {
	return m.Size()
}
func (m *CSHMatchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CSHMatchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CSHMatchInfo proto.InternalMessageInfo

const Default_CSHMatchInfo_GameId int32 = 10086

func (m *CSHMatchInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *CSHMatchInfo) GetGameId() int32 {
	if m != nil && m.GameId != nil {
		return *m.GameId
	}
	return Default_CSHMatchInfo_GameId
}

type SCHMatchInfo struct {
	Name                 *string  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	MathcId              *int32   `protobuf:"varint,2,opt,name=mathcId" json:"mathcId,omitempty"`
	TimeId               *int32   `protobuf:"varint,3,opt,name=timeId" json:"timeId,omitempty"`
	Status               *int64   `protobuf:"varint,4,opt,name=status" json:"status,omitempty"`
	Down                 *int64   `protobuf:"varint,5,opt,name=down" json:"down,omitempty"`
	Time                 *string  `protobuf:"bytes,6,req,name=time" json:"time,omitempty"`
	MatchOpen            *bool    `protobuf:"varint,7,req,name=match_open,json=matchOpen" json:"match_open,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCHMatchInfo) Reset()         { *m = SCHMatchInfo{} }
func (m *SCHMatchInfo) String() string { return proto.CompactTextString(m) }
func (*SCHMatchInfo) ProtoMessage()    {}
func (*SCHMatchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *SCHMatchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCHMatchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCHMatchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCHMatchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCHMatchInfo.Merge(m, src)
}
func (m *SCHMatchInfo) XXX_Size() int {
	return m.Size()
}
func (m *SCHMatchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SCHMatchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SCHMatchInfo proto.InternalMessageInfo

func (m *SCHMatchInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *SCHMatchInfo) GetMathcId() int32 {
	if m != nil && m.MathcId != nil {
		return *m.MathcId
	}
	return 0
}

func (m *SCHMatchInfo) GetTimeId() int32 {
	if m != nil && m.TimeId != nil {
		return *m.TimeId
	}
	return 0
}

func (m *SCHMatchInfo) GetStatus() int64 {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return 0
}

func (m *SCHMatchInfo) GetDown() int64 {
	if m != nil && m.Down != nil {
		return *m.Down
	}
	return 0
}

func (m *SCHMatchInfo) GetTime() string {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return ""
}

func (m *SCHMatchInfo) GetMatchOpen() bool {
	if m != nil && m.MatchOpen != nil {
		return *m.MatchOpen
	}
	return false
}

type HistoryRank struct {
	Idx                  *int64     `protobuf:"varint,1,req,name=idx" json:"idx,omitempty"`
	Icon                 *string    `protobuf:"bytes,2,opt,name=icon" json:"icon,omitempty"`
	Name                 *string    `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	AdditionSource       *int32     `protobuf:"varint,4,opt,name=addition_source,json=additionSource" json:"addition_source,omitempty"`
	Addition             *int32     `protobuf:"varint,5,opt,name=addition" json:"addition,omitempty"`
	MatchGoods           []*Object3 `protobuf:"bytes,6,rep,name=match_goods,json=matchGoods" json:"match_goods,omitempty"`
	PackGoods            []*Object3 `protobuf:"bytes,7,rep,name=pack_goods,json=packGoods" json:"pack_goods,omitempty"`
	LuckyGoods           []*Object3 `protobuf:"bytes,8,rep,name=lucky_goods,json=luckyGoods" json:"lucky_goods,omitempty"`
	BigGiftId            *string    `protobuf:"bytes,9,req,name=bigGiftId" json:"bigGiftId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *HistoryRank) Reset()         { *m = HistoryRank{} }
func (m *HistoryRank) String() string { return proto.CompactTextString(m) }
func (*HistoryRank) ProtoMessage()    {}
func (*HistoryRank) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *HistoryRank) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HistoryRank) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HistoryRank.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HistoryRank) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistoryRank.Merge(m, src)
}
func (m *HistoryRank) XXX_Size() int {
	return m.Size()
}
func (m *HistoryRank) XXX_DiscardUnknown() {
	xxx_messageInfo_HistoryRank.DiscardUnknown(m)
}

var xxx_messageInfo_HistoryRank proto.InternalMessageInfo

func (m *HistoryRank) GetIdx() int64 {
	if m != nil && m.Idx != nil {
		return *m.Idx
	}
	return 0
}

func (m *HistoryRank) GetIcon() string {
	if m != nil && m.Icon != nil {
		return *m.Icon
	}
	return ""
}

func (m *HistoryRank) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *HistoryRank) GetAdditionSource() int32 {
	if m != nil && m.AdditionSource != nil {
		return *m.AdditionSource
	}
	return 0
}

func (m *HistoryRank) GetAddition() int32 {
	if m != nil && m.Addition != nil {
		return *m.Addition
	}
	return 0
}

func (m *HistoryRank) GetMatchGoods() []*Object3 {
	if m != nil {
		return m.MatchGoods
	}
	return nil
}

func (m *HistoryRank) GetPackGoods() []*Object3 {
	if m != nil {
		return m.PackGoods
	}
	return nil
}

func (m *HistoryRank) GetLuckyGoods() []*Object3 {
	if m != nil {
		return m.LuckyGoods
	}
	return nil
}

func (m *HistoryRank) GetBigGiftId() string {
	if m != nil && m.BigGiftId != nil {
		return *m.BigGiftId
	}
	return ""
}

type CSHHistoryRank struct {
	PlayerId *int64 `protobuf:"varint,1,req,name=playerId" json:"playerId,omitempty"`
	//比赛Id(1001:nvip日赛，1002:vip日赛，1003:nvip周赛，1004:vip周赛，1005:nvip月赛，1006:vip月赛)
	//比赛Id(1011:積分賽底場日赛，1012:積分賽高場日赛，1013:積分賽底場周赛，1014:積分賽高場周赛，1015:積分賽底場月赛，1016:積分賽高場月赛)
	MatchId              *int32   `protobuf:"varint,2,req,name=matchId" json:"matchId,omitempty"`
	GameId               *int32   `protobuf:"varint,3,opt,name=gameId,def=10086" json:"gameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSHHistoryRank) Reset()         { *m = CSHHistoryRank{} }
func (m *CSHHistoryRank) String() string { return proto.CompactTextString(m) }
func (*CSHHistoryRank) ProtoMessage()    {}
func (*CSHHistoryRank) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{18}
}
func (m *CSHHistoryRank) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSHHistoryRank) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSHHistoryRank.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSHHistoryRank) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSHHistoryRank.Merge(m, src)
}
func (m *CSHHistoryRank) XXX_Size() int {
	return m.Size()
}
func (m *CSHHistoryRank) XXX_DiscardUnknown() {
	xxx_messageInfo_CSHHistoryRank.DiscardUnknown(m)
}

var xxx_messageInfo_CSHHistoryRank proto.InternalMessageInfo

const Default_CSHHistoryRank_GameId int32 = 10086

func (m *CSHHistoryRank) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *CSHHistoryRank) GetMatchId() int32 {
	if m != nil && m.MatchId != nil {
		return *m.MatchId
	}
	return 0
}

func (m *CSHHistoryRank) GetGameId() int32 {
	if m != nil && m.GameId != nil {
		return *m.GameId
	}
	return Default_CSHHistoryRank_GameId
}

type SCHHistoryRank struct {
	MatchId              *int32         `protobuf:"varint,1,req,name=matchId" json:"matchId,omitempty"`
	RankList             []*HistoryRank `protobuf:"bytes,2,rep,name=rank_list,json=rankList" json:"rank_list,omitempty"`
	OneselfRank          *HistoryRank   `protobuf:"bytes,3,req,name=oneself_rank,json=oneselfRank" json:"oneself_rank,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SCHHistoryRank) Reset()         { *m = SCHHistoryRank{} }
func (m *SCHHistoryRank) String() string { return proto.CompactTextString(m) }
func (*SCHHistoryRank) ProtoMessage()    {}
func (*SCHHistoryRank) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{19}
}
func (m *SCHHistoryRank) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCHHistoryRank) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCHHistoryRank.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCHHistoryRank) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCHHistoryRank.Merge(m, src)
}
func (m *SCHHistoryRank) XXX_Size() int {
	return m.Size()
}
func (m *SCHHistoryRank) XXX_DiscardUnknown() {
	xxx_messageInfo_SCHHistoryRank.DiscardUnknown(m)
}

var xxx_messageInfo_SCHHistoryRank proto.InternalMessageInfo

func (m *SCHHistoryRank) GetMatchId() int32 {
	if m != nil && m.MatchId != nil {
		return *m.MatchId
	}
	return 0
}

func (m *SCHHistoryRank) GetRankList() []*HistoryRank {
	if m != nil {
		return m.RankList
	}
	return nil
}

func (m *SCHHistoryRank) GetOneselfRank() *HistoryRank {
	if m != nil {
		return m.OneselfRank
	}
	return nil
}

type CSHLuckyInfo struct {
	MatchId              *int32   `protobuf:"varint,1,req,name=matchId" json:"matchId,omitempty"`
	GameId               *int32   `protobuf:"varint,2,opt,name=gameId,def=10086" json:"gameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSHLuckyInfo) Reset()         { *m = CSHLuckyInfo{} }
func (m *CSHLuckyInfo) String() string { return proto.CompactTextString(m) }
func (*CSHLuckyInfo) ProtoMessage()    {}
func (*CSHLuckyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{20}
}
func (m *CSHLuckyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSHLuckyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSHLuckyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSHLuckyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSHLuckyInfo.Merge(m, src)
}
func (m *CSHLuckyInfo) XXX_Size() int {
	return m.Size()
}
func (m *CSHLuckyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CSHLuckyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CSHLuckyInfo proto.InternalMessageInfo

const Default_CSHLuckyInfo_GameId int32 = 10086

func (m *CSHLuckyInfo) GetMatchId() int32 {
	if m != nil && m.MatchId != nil {
		return *m.MatchId
	}
	return 0
}

func (m *CSHLuckyInfo) GetGameId() int32 {
	if m != nil && m.GameId != nil {
		return *m.GameId
	}
	return Default_CSHLuckyInfo_GameId
}

type LuckyInfo struct {
	LRange               *int32   `protobuf:"varint,1,req,name=lRange" json:"lRange,omitempty"`
	RRange               *int32   `protobuf:"varint,2,req,name=rRange" json:"rRange,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuckyInfo) Reset()         { *m = LuckyInfo{} }
func (m *LuckyInfo) String() string { return proto.CompactTextString(m) }
func (*LuckyInfo) ProtoMessage()    {}
func (*LuckyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{21}
}
func (m *LuckyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuckyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuckyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuckyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuckyInfo.Merge(m, src)
}
func (m *LuckyInfo) XXX_Size() int {
	return m.Size()
}
func (m *LuckyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LuckyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LuckyInfo proto.InternalMessageInfo

func (m *LuckyInfo) GetLRange() int32 {
	if m != nil && m.LRange != nil {
		return *m.LRange
	}
	return 0
}

func (m *LuckyInfo) GetRRange() int32 {
	if m != nil && m.RRange != nil {
		return *m.RRange
	}
	return 0
}

type SCHLuckyInfo struct {
	MatchId *int32       `protobuf:"varint,1,opt,name=matchId" json:"matchId,omitempty"`
	Data    []*LuckyInfo `protobuf:"bytes,2,rep,name=data" json:"data,omitempty"`
	// 没有数据说明瓜分奖未开启； 如果LuckyInfo.rScore = 0，说明无上限限制，在lScore以上
	SplitData            []*LuckyInfo `protobuf:"bytes,3,rep,name=split_data,json=splitData" json:"split_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SCHLuckyInfo) Reset()         { *m = SCHLuckyInfo{} }
func (m *SCHLuckyInfo) String() string { return proto.CompactTextString(m) }
func (*SCHLuckyInfo) ProtoMessage()    {}
func (*SCHLuckyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{22}
}
func (m *SCHLuckyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCHLuckyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCHLuckyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCHLuckyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCHLuckyInfo.Merge(m, src)
}
func (m *SCHLuckyInfo) XXX_Size() int {
	return m.Size()
}
func (m *SCHLuckyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SCHLuckyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SCHLuckyInfo proto.InternalMessageInfo

func (m *SCHLuckyInfo) GetMatchId() int32 {
	if m != nil && m.MatchId != nil {
		return *m.MatchId
	}
	return 0
}

func (m *SCHLuckyInfo) GetData() []*LuckyInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *SCHLuckyInfo) GetSplitData() []*LuckyInfo {
	if m != nil {
		return m.SplitData
	}
	return nil
}

type CSMatchCfg struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSMatchCfg) Reset()         { *m = CSMatchCfg{} }
func (m *CSMatchCfg) String() string { return proto.CompactTextString(m) }
func (*CSMatchCfg) ProtoMessage()    {}
func (*CSMatchCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{23}
}
func (m *CSMatchCfg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSMatchCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSMatchCfg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSMatchCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSMatchCfg.Merge(m, src)
}
func (m *CSMatchCfg) XXX_Size() int {
	return m.Size()
}
func (m *CSMatchCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_CSMatchCfg.DiscardUnknown(m)
}

var xxx_messageInfo_CSMatchCfg proto.InternalMessageInfo

type SCMatchCfg struct {
	// 比赛列表
	MatchList            []*MatchCfg `protobuf:"bytes,1,rep,name=match_list,json=matchList" json:"match_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SCMatchCfg) Reset()         { *m = SCMatchCfg{} }
func (m *SCMatchCfg) String() string { return proto.CompactTextString(m) }
func (*SCMatchCfg) ProtoMessage()    {}
func (*SCMatchCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{24}
}
func (m *SCMatchCfg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCMatchCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCMatchCfg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCMatchCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCMatchCfg.Merge(m, src)
}
func (m *SCMatchCfg) XXX_Size() int {
	return m.Size()
}
func (m *SCMatchCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_SCMatchCfg.DiscardUnknown(m)
}

var xxx_messageInfo_SCMatchCfg proto.InternalMessageInfo

func (m *SCMatchCfg) GetMatchList() []*MatchCfg {
	if m != nil {
		return m.MatchList
	}
	return nil
}

type MatchCfg struct {
	// 游戏id
	GameId *int32 `protobuf:"varint,1,req,name=game_id,json=gameId" json:"game_id,omitempty"`
	// 比赛id
	MatchId *int32 `protobuf:"varint,2,req,name=match_id,json=matchId" json:"match_id,omitempty"`
	// 比赛类型 0-流水赛（金牛赛）
	MatchType *int32 `protobuf:"varint,3,req,name=match_type,json=matchType" json:"match_type,omitempty"`
	// 比赛开始展示时间 2006-01-02 15:04:05
	ShowBeginTime *string `protobuf:"bytes,4,req,name=show_begin_time,json=showBeginTime" json:"show_begin_time,omitempty"`
	// 比赛结束展示时间
	ShowEndTime *string `protobuf:"bytes,5,req,name=show_end_time,json=showEndTime" json:"show_end_time,omitempty"`
	// 比赛开始时间 08:20:00
	MatchBeginTime *string `protobuf:"bytes,6,req,name=match_begin_time,json=matchBeginTime" json:"match_begin_time,omitempty"`
	// 比赛结束时间 10:59:00
	MatchEndTime         *string  `protobuf:"bytes,7,req,name=match_end_time,json=matchEndTime" json:"match_end_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchCfg) Reset()         { *m = MatchCfg{} }
func (m *MatchCfg) String() string { return proto.CompactTextString(m) }
func (*MatchCfg) ProtoMessage()    {}
func (*MatchCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{25}
}
func (m *MatchCfg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchCfg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchCfg.Merge(m, src)
}
func (m *MatchCfg) XXX_Size() int {
	return m.Size()
}
func (m *MatchCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchCfg.DiscardUnknown(m)
}

var xxx_messageInfo_MatchCfg proto.InternalMessageInfo

func (m *MatchCfg) GetGameId() int32 {
	if m != nil && m.GameId != nil {
		return *m.GameId
	}
	return 0
}

func (m *MatchCfg) GetMatchId() int32 {
	if m != nil && m.MatchId != nil {
		return *m.MatchId
	}
	return 0
}

func (m *MatchCfg) GetMatchType() int32 {
	if m != nil && m.MatchType != nil {
		return *m.MatchType
	}
	return 0
}

func (m *MatchCfg) GetShowBeginTime() string {
	if m != nil && m.ShowBeginTime != nil {
		return *m.ShowBeginTime
	}
	return ""
}

func (m *MatchCfg) GetShowEndTime() string {
	if m != nil && m.ShowEndTime != nil {
		return *m.ShowEndTime
	}
	return ""
}

func (m *MatchCfg) GetMatchBeginTime() string {
	if m != nil && m.MatchBeginTime != nil {
		return *m.MatchBeginTime
	}
	return ""
}

func (m *MatchCfg) GetMatchEndTime() string {
	if m != nil && m.MatchEndTime != nil {
		return *m.MatchEndTime
	}
	return ""
}

//-----------------服务内grpc接口
type CSUpdateBonus struct {
	GameId               *int32   `protobuf:"varint,1,req,name=gameId,def=10086" json:"gameId,omitempty"`
	Key                  *string  `protobuf:"bytes,2,req,name=key" json:"key,omitempty"`
	Field                *string  `protobuf:"bytes,3,req,name=field" json:"field,omitempty"`
	Value                *string  `protobuf:"bytes,4,req,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSUpdateBonus) Reset()         { *m = CSUpdateBonus{} }
func (m *CSUpdateBonus) String() string { return proto.CompactTextString(m) }
func (*CSUpdateBonus) ProtoMessage()    {}
func (*CSUpdateBonus) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{26}
}
func (m *CSUpdateBonus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSUpdateBonus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSUpdateBonus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSUpdateBonus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSUpdateBonus.Merge(m, src)
}
func (m *CSUpdateBonus) XXX_Size() int {
	return m.Size()
}
func (m *CSUpdateBonus) XXX_DiscardUnknown() {
	xxx_messageInfo_CSUpdateBonus.DiscardUnknown(m)
}

var xxx_messageInfo_CSUpdateBonus proto.InternalMessageInfo

const Default_CSUpdateBonus_GameId int32 = 10086

func (m *CSUpdateBonus) GetGameId() int32 {
	if m != nil && m.GameId != nil {
		return *m.GameId
	}
	return Default_CSUpdateBonus_GameId
}

func (m *CSUpdateBonus) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *CSUpdateBonus) GetField() string {
	if m != nil && m.Field != nil {
		return *m.Field
	}
	return ""
}

func (m *CSUpdateBonus) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type SCUpdateBonus struct {
	Code                 *int32   `protobuf:"varint,1,req,name=code" json:"code,omitempty"`
	Msg                  *string  `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCUpdateBonus) Reset()         { *m = SCUpdateBonus{} }
func (m *SCUpdateBonus) String() string { return proto.CompactTextString(m) }
func (*SCUpdateBonus) ProtoMessage()    {}
func (*SCUpdateBonus) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{27}
}
func (m *SCUpdateBonus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCUpdateBonus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCUpdateBonus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCUpdateBonus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCUpdateBonus.Merge(m, src)
}
func (m *SCUpdateBonus) XXX_Size() int {
	return m.Size()
}
func (m *SCUpdateBonus) XXX_DiscardUnknown() {
	xxx_messageInfo_SCUpdateBonus.DiscardUnknown(m)
}

var xxx_messageInfo_SCUpdateBonus proto.InternalMessageInfo

func (m *SCUpdateBonus) GetCode() int32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *SCUpdateBonus) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

type MatchIdentify struct {
	MatchId              *int32   `protobuf:"varint,1,req,name=matchId" json:"matchId,omitempty"`
	Date                 *string  `protobuf:"bytes,2,req,name=date" json:"date,omitempty"`
	RoundId              *int32   `protobuf:"varint,3,req,name=roundId" json:"roundId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchIdentify) Reset()         { *m = MatchIdentify{} }
func (m *MatchIdentify) String() string { return proto.CompactTextString(m) }
func (*MatchIdentify) ProtoMessage()    {}
func (*MatchIdentify) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{28}
}
func (m *MatchIdentify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchIdentify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchIdentify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchIdentify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchIdentify.Merge(m, src)
}
func (m *MatchIdentify) XXX_Size() int {
	return m.Size()
}
func (m *MatchIdentify) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchIdentify.DiscardUnknown(m)
}

var xxx_messageInfo_MatchIdentify proto.InternalMessageInfo

func (m *MatchIdentify) GetMatchId() int32 {
	if m != nil && m.MatchId != nil {
		return *m.MatchId
	}
	return 0
}

func (m *MatchIdentify) GetDate() string {
	if m != nil && m.Date != nil {
		return *m.Date
	}
	return ""
}

func (m *MatchIdentify) GetRoundId() int32 {
	if m != nil && m.RoundId != nil {
		return *m.RoundId
	}
	return 0
}

//请求自己未领取的奖励的结算界面信息
type CSMatchResult struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSMatchResult) Reset()         { *m = CSMatchResult{} }
func (m *CSMatchResult) String() string { return proto.CompactTextString(m) }
func (*CSMatchResult) ProtoMessage()    {}
func (*CSMatchResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{29}
}
func (m *CSMatchResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSMatchResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSMatchResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSMatchResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSMatchResult.Merge(m, src)
}
func (m *CSMatchResult) XXX_Size() int {
	return m.Size()
}
func (m *CSMatchResult) XXX_DiscardUnknown() {
	xxx_messageInfo_CSMatchResult.DiscardUnknown(m)
}

var xxx_messageInfo_CSMatchResult proto.InternalMessageInfo

type UserInfo struct {
	Idx                  *int32   `protobuf:"varint,2,req,name=idx" json:"idx,omitempty"`
	Icon                 *string  `protobuf:"bytes,3,req,name=icon" json:"icon,omitempty"`
	Name                 *string  `protobuf:"bytes,4,req,name=name" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserInfo) Reset()         { *m = UserInfo{} }
func (m *UserInfo) String() string { return proto.CompactTextString(m) }
func (*UserInfo) ProtoMessage()    {}
func (*UserInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{30}
}
func (m *UserInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserInfo.Merge(m, src)
}
func (m *UserInfo) XXX_Size() int {
	return m.Size()
}
func (m *UserInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UserInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UserInfo proto.InternalMessageInfo

func (m *UserInfo) GetIdx() int32 {
	if m != nil && m.Idx != nil {
		return *m.Idx
	}
	return 0
}

func (m *UserInfo) GetIcon() string {
	if m != nil && m.Icon != nil {
		return *m.Icon
	}
	return ""
}

func (m *UserInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

//比赛结果推送
type SCMatchResult struct {
	Match                *MatchIdentify `protobuf:"bytes,1,req,name=match" json:"match,omitempty"`
	Ranks                []int64        `protobuf:"varint,2,rep,name=ranks" json:"ranks,omitempty"`
	User3                []*UserInfo    `protobuf:"bytes,3,rep,name=user3" json:"user3,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SCMatchResult) Reset()         { *m = SCMatchResult{} }
func (m *SCMatchResult) String() string { return proto.CompactTextString(m) }
func (*SCMatchResult) ProtoMessage()    {}
func (*SCMatchResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{31}
}
func (m *SCMatchResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCMatchResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCMatchResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCMatchResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCMatchResult.Merge(m, src)
}
func (m *SCMatchResult) XXX_Size() int {
	return m.Size()
}
func (m *SCMatchResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SCMatchResult.DiscardUnknown(m)
}

var xxx_messageInfo_SCMatchResult proto.InternalMessageInfo

func (m *SCMatchResult) GetMatch() *MatchIdentify {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *SCMatchResult) GetRanks() []int64 {
	if m != nil {
		return m.Ranks
	}
	return nil
}

func (m *SCMatchResult) GetUser3() []*UserInfo {
	if m != nil {
		return m.User3
	}
	return nil
}

type CSGetAwardRecord struct {
	PlayerId             *int64   `protobuf:"varint,1,req,name=playerId" json:"playerId,omitempty"`
	GameId               *int32   `protobuf:"varint,2,opt,name=gameId,def=10086" json:"gameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSGetAwardRecord) Reset()         { *m = CSGetAwardRecord{} }
func (m *CSGetAwardRecord) String() string { return proto.CompactTextString(m) }
func (*CSGetAwardRecord) ProtoMessage()    {}
func (*CSGetAwardRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{32}
}
func (m *CSGetAwardRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSGetAwardRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSGetAwardRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSGetAwardRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSGetAwardRecord.Merge(m, src)
}
func (m *CSGetAwardRecord) XXX_Size() int {
	return m.Size()
}
func (m *CSGetAwardRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_CSGetAwardRecord.DiscardUnknown(m)
}

var xxx_messageInfo_CSGetAwardRecord proto.InternalMessageInfo

const Default_CSGetAwardRecord_GameId int32 = 10086

func (m *CSGetAwardRecord) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *CSGetAwardRecord) GetGameId() int32 {
	if m != nil && m.GameId != nil {
		return *m.GameId
	}
	return Default_CSGetAwardRecord_GameId
}

type AwardRecord struct {
	Rank                 *int64         `protobuf:"varint,1,req,name=rank" json:"rank,omitempty"`
	MatchGoods           []*Object3     `protobuf:"bytes,2,rep,name=match_goods,json=matchGoods" json:"match_goods,omitempty"`
	LuckyGoods           []*Object3     `protobuf:"bytes,3,rep,name=lucky_goods,json=luckyGoods" json:"lucky_goods,omitempty"`
	SplitAwardGoods      []*Object3     `protobuf:"bytes,4,rep,name=split_award_goods,json=splitAwardGoods" json:"split_award_goods,omitempty"`
	Match                *MatchIdentify `protobuf:"bytes,5,req,name=match" json:"match,omitempty"`
	User3                []*UserInfo    `protobuf:"bytes,6,rep,name=user3" json:"user3,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AwardRecord) Reset()         { *m = AwardRecord{} }
func (m *AwardRecord) String() string { return proto.CompactTextString(m) }
func (*AwardRecord) ProtoMessage()    {}
func (*AwardRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{33}
}
func (m *AwardRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwardRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AwardRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AwardRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwardRecord.Merge(m, src)
}
func (m *AwardRecord) XXX_Size() int {
	return m.Size()
}
func (m *AwardRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_AwardRecord.DiscardUnknown(m)
}

var xxx_messageInfo_AwardRecord proto.InternalMessageInfo

func (m *AwardRecord) GetRank() int64 {
	if m != nil && m.Rank != nil {
		return *m.Rank
	}
	return 0
}

func (m *AwardRecord) GetMatchGoods() []*Object3 {
	if m != nil {
		return m.MatchGoods
	}
	return nil
}

func (m *AwardRecord) GetLuckyGoods() []*Object3 {
	if m != nil {
		return m.LuckyGoods
	}
	return nil
}

func (m *AwardRecord) GetSplitAwardGoods() []*Object3 {
	if m != nil {
		return m.SplitAwardGoods
	}
	return nil
}

func (m *AwardRecord) GetMatch() *MatchIdentify {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *AwardRecord) GetUser3() []*UserInfo {
	if m != nil {
		return m.User3
	}
	return nil
}

type SCGetAwardRecord struct {
	Records              []*AwardRecord `protobuf:"bytes,1,rep,name=records" json:"records,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SCGetAwardRecord) Reset()         { *m = SCGetAwardRecord{} }
func (m *SCGetAwardRecord) String() string { return proto.CompactTextString(m) }
func (*SCGetAwardRecord) ProtoMessage()    {}
func (*SCGetAwardRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{34}
}
func (m *SCGetAwardRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCGetAwardRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCGetAwardRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCGetAwardRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCGetAwardRecord.Merge(m, src)
}
func (m *SCGetAwardRecord) XXX_Size() int {
	return m.Size()
}
func (m *SCGetAwardRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_SCGetAwardRecord.DiscardUnknown(m)
}

var xxx_messageInfo_SCGetAwardRecord proto.InternalMessageInfo

func (m *SCGetAwardRecord) GetRecords() []*AwardRecord {
	if m != nil {
		return m.Records
	}
	return nil
}

//领取奖励
type CSGetAward struct {
	PlayerId             *int64         `protobuf:"varint,1,req,name=playerId" json:"playerId,omitempty"`
	Match                *MatchIdentify `protobuf:"bytes,2,req,name=match" json:"match,omitempty"`
	GameId               *int32         `protobuf:"varint,3,opt,name=gameId,def=10086" json:"gameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CSGetAward) Reset()         { *m = CSGetAward{} }
func (m *CSGetAward) String() string { return proto.CompactTextString(m) }
func (*CSGetAward) ProtoMessage()    {}
func (*CSGetAward) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{35}
}
func (m *CSGetAward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSGetAward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSGetAward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSGetAward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSGetAward.Merge(m, src)
}
func (m *CSGetAward) XXX_Size() int {
	return m.Size()
}
func (m *CSGetAward) XXX_DiscardUnknown() {
	xxx_messageInfo_CSGetAward.DiscardUnknown(m)
}

var xxx_messageInfo_CSGetAward proto.InternalMessageInfo

const Default_CSGetAward_GameId int32 = 10086

func (m *CSGetAward) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *CSGetAward) GetMatch() *MatchIdentify {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *CSGetAward) GetGameId() int32 {
	if m != nil && m.GameId != nil {
		return *m.GameId
	}
	return Default_CSGetAward_GameId
}

type SCGetAward struct {
	MatchGoods           []*Object3 `protobuf:"bytes,2,rep,name=match_goods,json=matchGoods" json:"match_goods,omitempty"`
	LuckyGoods           []*Object3 `protobuf:"bytes,3,rep,name=lucky_goods,json=luckyGoods" json:"lucky_goods,omitempty"`
	SplitAwardGoods      []*Object3 `protobuf:"bytes,4,rep,name=split_award_goods,json=splitAwardGoods" json:"split_award_goods,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SCGetAward) Reset()         { *m = SCGetAward{} }
func (m *SCGetAward) String() string { return proto.CompactTextString(m) }
func (*SCGetAward) ProtoMessage()    {}
func (*SCGetAward) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{36}
}
func (m *SCGetAward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCGetAward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCGetAward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCGetAward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCGetAward.Merge(m, src)
}
func (m *SCGetAward) XXX_Size() int {
	return m.Size()
}
func (m *SCGetAward) XXX_DiscardUnknown() {
	xxx_messageInfo_SCGetAward.DiscardUnknown(m)
}

var xxx_messageInfo_SCGetAward proto.InternalMessageInfo

func (m *SCGetAward) GetMatchGoods() []*Object3 {
	if m != nil {
		return m.MatchGoods
	}
	return nil
}

func (m *SCGetAward) GetLuckyGoods() []*Object3 {
	if m != nil {
		return m.LuckyGoods
	}
	return nil
}

func (m *SCGetAward) GetSplitAwardGoods() []*Object3 {
	if m != nil {
		return m.SplitAwardGoods
	}
	return nil
}

type CSUpdateUserInfo struct {
	PlayerId             *int64   `protobuf:"varint,1,req,name=playerId" json:"playerId,omitempty"`
	GameId               *int32   `protobuf:"varint,2,req,name=gameId,def=10086" json:"gameId,omitempty"`
	ArenaId              *int32   `protobuf:"varint,3,req,name=arenaId" json:"arenaId,omitempty"`
	Icon                 *string  `protobuf:"bytes,4,req,name=icon" json:"icon,omitempty"`
	Nick                 *string  `protobuf:"bytes,5,req,name=nick" json:"nick,omitempty"`
	BigGiftId            *string  `protobuf:"bytes,6,req,name=bigGiftId" json:"bigGiftId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSUpdateUserInfo) Reset()         { *m = CSUpdateUserInfo{} }
func (m *CSUpdateUserInfo) String() string { return proto.CompactTextString(m) }
func (*CSUpdateUserInfo) ProtoMessage()    {}
func (*CSUpdateUserInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{37}
}
func (m *CSUpdateUserInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSUpdateUserInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSUpdateUserInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSUpdateUserInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSUpdateUserInfo.Merge(m, src)
}
func (m *CSUpdateUserInfo) XXX_Size() int {
	return m.Size()
}
func (m *CSUpdateUserInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CSUpdateUserInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CSUpdateUserInfo proto.InternalMessageInfo

const Default_CSUpdateUserInfo_GameId int32 = 10086

func (m *CSUpdateUserInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *CSUpdateUserInfo) GetGameId() int32 {
	if m != nil && m.GameId != nil {
		return *m.GameId
	}
	return Default_CSUpdateUserInfo_GameId
}

func (m *CSUpdateUserInfo) GetArenaId() int32 {
	if m != nil && m.ArenaId != nil {
		return *m.ArenaId
	}
	return 0
}

func (m *CSUpdateUserInfo) GetIcon() string {
	if m != nil && m.Icon != nil {
		return *m.Icon
	}
	return ""
}

func (m *CSUpdateUserInfo) GetNick() string {
	if m != nil && m.Nick != nil {
		return *m.Nick
	}
	return ""
}

func (m *CSUpdateUserInfo) GetBigGiftId() string {
	if m != nil && m.BigGiftId != nil {
		return *m.BigGiftId
	}
	return ""
}

type SCUpdateUserInfo struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCUpdateUserInfo) Reset()         { *m = SCUpdateUserInfo{} }
func (m *SCUpdateUserInfo) String() string { return proto.CompactTextString(m) }
func (*SCUpdateUserInfo) ProtoMessage()    {}
func (*SCUpdateUserInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{38}
}
func (m *SCUpdateUserInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCUpdateUserInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCUpdateUserInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCUpdateUserInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCUpdateUserInfo.Merge(m, src)
}
func (m *SCUpdateUserInfo) XXX_Size() int {
	return m.Size()
}
func (m *SCUpdateUserInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SCUpdateUserInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SCUpdateUserInfo proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("matchmgr.service.v1.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterEnum("matchmgr.service.v1.MsgCode", MsgCode_name, MsgCode_value)
	proto.RegisterType((*Object3)(nil), "matchmgr.service.v1.Object3")
	proto.RegisterType((*CSHBonusPool)(nil), "matchmgr.service.v1.CSHBonusPool")
	proto.RegisterType((*HBonusPool)(nil), "matchmgr.service.v1.HBonusPool")
	proto.RegisterType((*SCHBonusPool)(nil), "matchmgr.service.v1.SCHBonusPool")
	proto.RegisterType((*CSHRankBar)(nil), "matchmgr.service.v1.CSHRankBar")
	proto.RegisterType((*SCHRankBar)(nil), "matchmgr.service.v1.SCHRankBar")
	proto.RegisterType((*RealRank)(nil), "matchmgr.service.v1.RealRank")
	proto.RegisterType((*CSHRealRank)(nil), "matchmgr.service.v1.CSHRealRank")
	proto.RegisterType((*SCHRealRank)(nil), "matchmgr.service.v1.SCHRealRank")
	proto.RegisterType((*Reward)(nil), "matchmgr.service.v1.Reward")
	proto.RegisterType((*CSHReward)(nil), "matchmgr.service.v1.CSHReward")
	proto.RegisterType((*SCHReward)(nil), "matchmgr.service.v1.SCHReward")
	proto.RegisterType((*CSHMatchInfoTip)(nil), "matchmgr.service.v1.CSHMatchInfoTip")
	proto.RegisterType((*MatchInfoTip)(nil), "matchmgr.service.v1.MatchInfoTip")
	proto.RegisterType((*SCHMatchInfoTip)(nil), "matchmgr.service.v1.SCHMatchInfoTip")
	proto.RegisterType((*CSHMatchInfo)(nil), "matchmgr.service.v1.CSHMatchInfo")
	proto.RegisterType((*SCHMatchInfo)(nil), "matchmgr.service.v1.SCHMatchInfo")
	proto.RegisterType((*HistoryRank)(nil), "matchmgr.service.v1.HistoryRank")
	proto.RegisterType((*CSHHistoryRank)(nil), "matchmgr.service.v1.CSHHistoryRank")
	proto.RegisterType((*SCHHistoryRank)(nil), "matchmgr.service.v1.SCHHistoryRank")
	proto.RegisterType((*CSHLuckyInfo)(nil), "matchmgr.service.v1.CSHLuckyInfo")
	proto.RegisterType((*LuckyInfo)(nil), "matchmgr.service.v1.LuckyInfo")
	proto.RegisterType((*SCHLuckyInfo)(nil), "matchmgr.service.v1.SCHLuckyInfo")
	proto.RegisterType((*CSMatchCfg)(nil), "matchmgr.service.v1.CSMatchCfg")
	proto.RegisterType((*SCMatchCfg)(nil), "matchmgr.service.v1.SCMatchCfg")
	proto.RegisterType((*MatchCfg)(nil), "matchmgr.service.v1.MatchCfg")
	proto.RegisterType((*CSUpdateBonus)(nil), "matchmgr.service.v1.CSUpdateBonus")
	proto.RegisterType((*SCUpdateBonus)(nil), "matchmgr.service.v1.SCUpdateBonus")
	proto.RegisterType((*MatchIdentify)(nil), "matchmgr.service.v1.MatchIdentify")
	proto.RegisterType((*CSMatchResult)(nil), "matchmgr.service.v1.CSMatchResult")
	proto.RegisterType((*UserInfo)(nil), "matchmgr.service.v1.UserInfo")
	proto.RegisterType((*SCMatchResult)(nil), "matchmgr.service.v1.SCMatchResult")
	proto.RegisterType((*CSGetAwardRecord)(nil), "matchmgr.service.v1.CSGetAwardRecord")
	proto.RegisterType((*AwardRecord)(nil), "matchmgr.service.v1.AwardRecord")
	proto.RegisterType((*SCGetAwardRecord)(nil), "matchmgr.service.v1.SCGetAwardRecord")
	proto.RegisterType((*CSGetAward)(nil), "matchmgr.service.v1.CSGetAward")
	proto.RegisterType((*SCGetAward)(nil), "matchmgr.service.v1.SCGetAward")
	proto.RegisterType((*CSUpdateUserInfo)(nil), "matchmgr.service.v1.CSUpdateUserInfo")
	proto.RegisterType((*SCUpdateUserInfo)(nil), "matchmgr.service.v1.SCUpdateUserInfo")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 2059 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0xcf, 0x6f, 0xdb, 0xc8,
	0xf5, 0x0f, 0xf5, 0x5b, 0x4f, 0xb2, 0xac, 0x9d, 0x24, 0x5e, 0x45, 0x49, 0x1c, 0x65, 0xe2, 0x7c,
	0xd7, 0x58, 0xe0, 0x6b, 0x27, 0x0e, 0x76, 0xb1, 0xc8, 0x36, 0x2d, 0xd6, 0x4a, 0x6a, 0xbb, 0x58,
	0x3b, 0x01, 0xe5, 0x45, 0x81, 0xa2, 0x85, 0x40, 0x93, 0x23, 0x99, 0x6b, 0x8a, 0x24, 0x48, 0xca,
	0x89, 0xd2, 0x53, 0x8b, 0xfe, 0x01, 0x05, 0xda, 0xc3, 0x02, 0x3d, 0xf7, 0xd6, 0xf6, 0xd2, 0x7f,
	0xa2, 0xc7, 0x02, 0xed, 0xa1, 0xc7, 0x22, 0xdd, 0xfe, 0x11, 0xbd, 0x15, 0xf3, 0x66, 0x86, 0xa4,
	0x14, 0xd2, 0xb2, 0x51, 0xa0, 0x87, 0xde, 0x66, 0x86, 0x9f, 0xf7, 0x3e, 0x33, 0x6f, 0xde, 0xaf,
	0x21, 0xd4, 0x0d, 0xdf, 0xde, 0xf2, 0x03, 0x2f, 0xf2, 0xc8, 0xf5, 0x89, 0x11, 0x99, 0xa7, 0x93,
	0x71, 0xb0, 0x15, 0xb2, 0xe0, 0xdc, 0x36, 0xd9, 0xd6, 0xf9, 0xe3, 0xee, 0xff, 0x8f, 0xed, 0xe8,
	0x74, 0x7a, 0xb2, 0x65, 0x7a, 0x93, 0xed, 0xb1, 0x37, 0xf6, 0xb6, 0x11, 0x7b, 0x32, 0x1d, 0xe1,
	0x0c, 0x27, 0x38, 0x12, 0x3a, 0xba, 0xb7, 0xc7, 0x9e, 0x37, 0x76, 0x58, 0x82, 0x62, 0x13, 0x3f,
	0x9a, 0xc9, 0x8f, 0x77, 0xe4, 0x47, 0xc3, 0xb7, 0xb7, 0x0d, 0xd7, 0xf5, 0x22, 0x23, 0xb2, 0x3d,
	0x37, 0x14, 0x5f, 0xe9, 0x63, 0xa8, 0xbe, 0x3c, 0xf9, 0x9a, 0x99, 0xd1, 0x13, 0xd2, 0x86, 0xe2,
	0x19, 0x9b, 0x75, 0xb4, 0x5e, 0x61, 0xb3, 0xac, 0xf3, 0x21, 0xb9, 0x01, 0xe5, 0x73, 0xc3, 0x99,
	0xb2, 0x4e, 0xa1, 0x57, 0xd8, 0x2c, 0xea, 0x62, 0x42, 0x7f, 0x0a, 0xcd, 0xfe, 0x60, 0x7f, 0xd7,
	0x73, 0xa7, 0xe1, 0x2b, 0xcf, 0x73, 0x48, 0x07, 0xaa, 0x13, 0x23, 0x3a, 0x35, 0x0f, 0x2c, 0x29,
	0xab, 0xa6, 0x64, 0x0d, 0x2a, 0x91, 0x3d, 0x61, 0x07, 0x16, 0x2a, 0x28, 0xeb, 0x72, 0x46, 0xba,
	0x50, 0xf3, 0x1d, 0x63, 0xc6, 0x82, 0x03, 0xab, 0x53, 0x44, 0xd5, 0xf1, 0x9c, 0xdc, 0x85, 0xca,
	0xd8, 0x40, 0x99, 0x52, 0x4f, 0xdb, 0x2c, 0x3f, 0x2d, 0x3f, 0x7e, 0xf4, 0xe8, 0xb3, 0x4f, 0x75,
	0xb9, 0x48, 0x47, 0x00, 0xef, 0x51, 0x9b, 0xa7, 0x73, 0xd4, 0x7c, 0x4a, 0x08, 0x94, 0x5c, 0x63,
	0x22, 0x76, 0x5e, 0xd7, 0x71, 0x9c, 0x1c, 0xa7, 0xd8, 0xd3, 0xe2, 0xe3, 0xf0, 0x55, 0xd3, 0x9b,
	0xba, 0x11, 0xf2, 0x15, 0x75, 0x31, 0xa1, 0x7d, 0x68, 0x0e, 0xfa, 0x29, 0xa6, 0x27, 0x50, 0xf2,
	0x3d, 0xcf, 0xe9, 0x68, 0xbd, 0xe2, 0x66, 0x63, 0xe7, 0xde, 0x56, 0xc6, 0xad, 0x6d, 0x25, 0x70,
	0x1d, 0xc1, 0x74, 0x06, 0xd0, 0x1f, 0xec, 0xeb, 0x86, 0x7b, 0xb6, 0x6b, 0x04, 0xff, 0x5d, 0x3b,
	0x1d, 0x01, 0x0c, 0xfa, 0x31, 0x75, 0x1b, 0x8a, 0xb6, 0xf5, 0x06, 0x69, 0x8b, 0x3a, 0x1f, 0xf2,
	0x53, 0x47, 0x5e, 0x64, 0x38, 0xea, 0x6a, 0x71, 0xc2, 0xb7, 0x18, 0x30, 0xe3, 0xb5, 0x11, 0x28,
	0x3e, 0x35, 0xa5, 0xbf, 0xd3, 0xa0, 0xa6, 0x33, 0xc3, 0xe1, 0x1a, 0x33, 0xd4, 0x11, 0x28, 0xd9,
	0xa6, 0xe7, 0x2a, 0x73, 0xf3, 0x71, 0x7c, 0x05, 0xc5, 0xf9, 0x2b, 0x08, 0x4d, 0x2f, 0x60, 0xca,
	0xd8, 0x38, 0x21, 0x3b, 0x50, 0x1e, 0x7b, 0x9e, 0x15, 0x76, 0xca, 0x68, 0xdd, 0x3b, 0x99, 0xd6,
	0x95, 0x6e, 0xaa, 0x0b, 0x28, 0xb9, 0x03, 0xf5, 0x13, 0x7b, 0xbc, 0x67, 0x8f, 0xa2, 0x03, 0xab,
	0x53, 0x41, 0x8a, 0x64, 0x81, 0xbe, 0x85, 0x06, 0xb7, 0xbc, 0xda, 0x70, 0xda, 0x90, 0xda, 0x82,
	0x21, 0x53, 0xd7, 0x52, 0xc8, 0xbb, 0x96, 0xe2, 0xdc, 0xb5, 0x2c, 0x31, 0xfd, 0xb7, 0x05, 0x68,
	0x70, 0xdb, 0x2b, 0xf2, 0xa7, 0x50, 0x0f, 0x98, 0xe1, 0x0c, 0x03, 0xc3, 0x3d, 0x93, 0xfe, 0x73,
	0x37, 0xf3, 0x84, 0x4a, 0x42, 0xaf, 0x05, 0x4a, 0xf6, 0xbb, 0xd0, 0xf0, 0xdc, 0x90, 0x39, 0x23,
	0x21, 0x5d, 0xe8, 0x69, 0xcb, 0xa5, 0x41, 0x48, 0xa0, 0xfc, 0x6d, 0xa8, 0xe3, 0xcd, 0x0e, 0xdd,
	0xe9, 0x44, 0xba, 0x7d, 0x0d, 0x17, 0x8e, 0xa6, 0x13, 0xf2, 0x10, 0x5a, 0x68, 0xff, 0xa1, 0x61,
	0x59, 0x36, 0x4f, 0x0a, 0xe2, 0x3c, 0xfa, 0x0a, 0xae, 0x7e, 0x21, 0x17, 0xc9, 0x47, 0xb0, 0x1a,
	0x30, 0xee, 0x04, 0x09, 0xae, 0x8c, 0xb8, 0x96, 0x58, 0x8e, 0x81, 0x0f, 0x60, 0xc5, 0x9c, 0x83,
	0x55, 0x90, 0xb0, 0x69, 0xa6, 0x41, 0xf7, 0xa1, 0x79, 0x6e, 0xfb, 0x09, 0xa6, 0x8a, 0xaa, 0x1a,
	0xe7, 0xb6, 0x1f, 0x43, 0x36, 0xa0, 0x15, 0xfa, 0x8e, 0x1d, 0x0d, 0xd1, 0xf5, 0x86, 0xb6, 0xd5,
	0xa9, 0x21, 0xa8, 0x89, 0xab, 0x5f, 0xf0, 0xc5, 0x03, 0x8b, 0x5a, 0x50, 0xd1, 0x91, 0x1f, 0x9d,
	0xcf, 0x7a, 0xe3, 0xc8, 0x9b, 0xc5, 0xb1, 0x5c, 0x0b, 0xa4, 0x7b, 0xe3, 0x38, 0x71, 0xb3, 0xe2,
	0xa5, 0xdd, 0x8c, 0xfe, 0x18, 0xea, 0xe8, 0x48, 0x48, 0x74, 0xf5, 0x08, 0x4e, 0x5c, 0xa5, 0x98,
	0xe5, 0x2a, 0xbb, 0x50, 0x47, 0x4f, 0x41, 0xed, 0x9f, 0xf0, 0xe0, 0xe3, 0xa3, 0x50, 0x7a, 0xc9,
	0xed, 0x9c, 0x7b, 0xe6, 0x18, 0x5d, 0x61, 0xe9, 0x23, 0x58, 0xed, 0x0f, 0xf6, 0x0f, 0x31, 0xef,
	0xb9, 0x23, 0xef, 0xd8, 0xf6, 0x53, 0xac, 0x5a, 0x16, 0xeb, 0x2f, 0x34, 0x68, 0xce, 0xe1, 0x55,
	0xa4, 0x72, 0xb4, 0x8a, 0xd4, 0xb9, 0xb0, 0xd0, 0xd2, 0x67, 0x25, 0x50, 0xe2, 0xa7, 0x53, 0x71,
	0xcd, 0xc7, 0x89, 0x69, 0x4b, 0x97, 0x37, 0xad, 0x0e, 0xab, 0x83, 0xfe, 0xfc, 0xc6, 0xbf, 0x07,
	0x75, 0x14, 0x3c, 0xb6, 0x7d, 0x65, 0x84, 0xfb, 0x99, 0xaa, 0xd2, 0x52, 0x7a, 0x22, 0x43, 0x0f,
	0xb0, 0x36, 0xc5, 0x5f, 0x2f, 0x0c, 0xfc, 0xc4, 0x4a, 0x85, 0x2c, 0x2b, 0xfd, 0x51, 0xc3, 0x12,
	0x90, 0xe8, 0xba, 0x9a, 0x95, 0xd2, 0xc9, 0x43, 0x4b, 0x79, 0xc4, 0x1a, 0x54, 0xc2, 0xc8, 0x88,
	0xa6, 0xa1, 0x4c, 0x81, 0x72, 0xc6, 0xb5, 0x5b, 0xde, 0x6b, 0x11, 0x5a, 0x45, 0x1d, 0xc7, 0xb1,
	0xa5, 0x2b, 0x29, 0x4b, 0xdf, 0x05, 0xc0, 0xe3, 0x0e, 0x3d, 0x9f, 0xf1, 0xe8, 0x29, 0x6c, 0xd6,
	0xa4, 0x01, 0x5e, 0xfa, 0xcc, 0xa5, 0xff, 0x2c, 0x40, 0x63, 0xdf, 0x0e, 0x23, 0x2f, 0x98, 0x2d,
	0x4d, 0xd5, 0x5a, 0x46, 0xaa, 0x4e, 0x8e, 0xf6, 0x11, 0xac, 0xaa, 0x20, 0x1d, 0x86, 0xde, 0x34,
	0x30, 0x99, 0x4c, 0x0f, 0x2d, 0xb5, 0x3c, 0xc0, 0x55, 0x6e, 0xe3, 0x85, 0xc4, 0x10, 0xcf, 0xc9,
	0x33, 0x68, 0x88, 0xdd, 0x0a, 0xef, 0xa8, 0x5c, 0xc2, 0x3b, 0xc4, 0xf1, 0xf6, 0x30, 0xc9, 0x7f,
	0x0e, 0xe0, 0x1b, 0xe6, 0x99, 0x94, 0xae, 0x5e, 0x42, 0xba, 0xce, 0xf1, 0x42, 0xf8, 0x19, 0x34,
	0x9c, 0xa9, 0x79, 0x36, 0x93, 0xd2, 0xb5, 0xcb, 0x70, 0xa3, 0xc0, 0xde, 0xfb, 0x05, 0xa6, 0xbe,
	0x58, 0x60, 0x18, 0xb4, 0xfa, 0x83, 0xfd, 0xb4, 0xa5, 0x97, 0xd7, 0x18, 0xec, 0x53, 0x0a, 0xf3,
	0x7d, 0xca, 0x92, 0x04, 0xf1, 0x07, 0x0d, 0x5a, 0x83, 0xfe, 0x1c, 0x4f, 0x7e, 0xcf, 0xf3, 0x0c,
	0xea, 0xbc, 0x4a, 0x0c, 0x1d, 0x3b, 0x8c, 0x3a, 0x05, 0x3c, 0x6e, 0x2f, 0xbb, 0x51, 0x49, 0xd4,
	0xe9, 0x35, 0x2e, 0xf2, 0xa5, 0x1d, 0x46, 0xa4, 0x0f, 0x4d, 0xcf, 0x65, 0x49, 0xb1, 0xe1, 0xf1,
	0x7d, 0x19, 0x0d, 0x0d, 0x29, 0xc5, 0x27, 0x74, 0x0f, 0x03, 0xf0, 0x4b, 0x6e, 0x46, 0x0c, 0x9a,
	0xfc, 0xdd, 0x2e, 0x09, 0xbf, 0xcf, 0xa1, 0x9e, 0x68, 0x59, 0x83, 0x0a, 0xaf, 0x6d, 0x63, 0x26,
	0x95, 0xc8, 0x19, 0x5f, 0x0f, 0xc4, 0xba, 0x4c, 0xbb, 0x62, 0x46, 0x7f, 0x23, 0x62, 0x37, 0x67,
	0x1b, 0x5a, 0x7a, 0x1b, 0x3b, 0x50, 0xb2, 0x8c, 0xc8, 0x90, 0xf6, 0x5a, 0xcf, 0x3c, 0x6d, 0xac,
	0x47, 0x47, 0x2c, 0x79, 0x06, 0x20, 0x0a, 0x14, 0x4a, 0x16, 0x2f, 0x25, 0x59, 0x47, 0x89, 0xe7,
	0x46, 0x64, 0xd0, 0x26, 0x6f, 0x0b, 0x31, 0xaf, 0xf4, 0x47, 0x63, 0xfa, 0x03, 0xde, 0xa9, 0xa9,
	0x19, 0xf9, 0x8e, 0x0a, 0x6f, 0xbc, 0xc4, 0x8b, 0xba, 0x05, 0x25, 0x22, 0xa3, 0x9f, 0x5f, 0x21,
	0xfd, 0x97, 0x06, 0xb5, 0x58, 0xd5, 0x87, 0x50, 0xe5, 0xb6, 0xe4, 0xf5, 0x53, 0x5a, 0x4d, 0x98,
	0x96, 0xdc, 0x82, 0x9a, 0xe0, 0xb0, 0x33, 0xdc, 0x51, 0xd2, 0x47, 0x33, 0x9f, 0xc9, 0xb6, 0x47,
	0xa6, 0xd7, 0x99, 0xcf, 0xc8, 0xff, 0xc1, 0x6a, 0x78, 0xea, 0xbd, 0x1e, 0x9e, 0xb0, 0xb1, 0xed,
	0x0e, 0x31, 0x37, 0x95, 0x30, 0x32, 0x56, 0xf8, 0xf2, 0x2e, 0x5f, 0x3d, 0xe6, 0x49, 0x8a, 0x02,
	0x2e, 0x0c, 0x99, 0x6b, 0x09, 0x54, 0x19, 0x51, 0x0d, 0xbe, 0xf8, 0xc2, 0xb5, 0x10, 0xb3, 0x09,
	0x6d, 0x41, 0x95, 0x52, 0x26, 0x12, 0x5d, 0x0b, 0xd7, 0x13, 0x6d, 0x1b, 0x20, 0x56, 0x12, 0x75,
	0x55, 0xc4, 0x35, 0x71, 0x55, 0xea, 0xa3, 0x0e, 0xac, 0xf4, 0x07, 0x5f, 0xf9, 0x96, 0x11, 0x31,
	0xec, 0xc3, 0xe7, 0xaa, 0x60, 0xe1, 0x3d, 0x07, 0x53, 0xcf, 0x1d, 0xd1, 0xb1, 0xaa, 0xe7, 0xce,
	0xc8, 0x66, 0x8e, 0x25, 0x2b, 0x9b, 0x98, 0x24, 0xaf, 0x06, 0x71, 0x52, 0xf9, 0x08, 0xfa, 0x04,
	0x56, 0x06, 0xfd, 0x34, 0x1b, 0x81, 0x92, 0xe9, 0x59, 0xca, 0x41, 0x71, 0xcc, 0x29, 0x26, 0xe1,
	0x58, 0x66, 0x5a, 0x3e, 0xa4, 0x3f, 0x84, 0x15, 0x51, 0x50, 0x2c, 0xe6, 0x46, 0xf6, 0x68, 0x76,
	0xf1, 0x0b, 0x86, 0x6b, 0x57, 0x2d, 0x35, 0x1f, 0x63, 0x7f, 0xee, 0x4d, 0x5d, 0x2b, 0x6e, 0x49,
	0xd5, 0x94, 0xae, 0xf2, 0xd3, 0xa3, 0x6a, 0x9d, 0x85, 0x53, 0x27, 0xa2, 0xcf, 0xa1, 0xf6, 0x55,
	0xc8, 0x02, 0xf4, 0x7e, 0x59, 0x04, 0xc4, 0x5d, 0xcf, 0x15, 0x81, 0x62, 0x46, 0xbf, 0x5e, 0x4a,
	0xfa, 0x75, 0xfa, 0x6b, 0x8d, 0x9f, 0x33, 0xa5, 0x97, 0x7c, 0x06, 0x65, 0xdc, 0x21, 0x6e, 0xb7,
	0xb1, 0x43, 0x2f, 0x28, 0xcf, 0xf2, 0x8c, 0xba, 0x10, 0xe0, 0x86, 0xe4, 0x79, 0x25, 0xc4, 0x50,
	0x2b, 0xea, 0x62, 0x42, 0x9e, 0x40, 0x79, 0x1a, 0xb2, 0xe0, 0x89, 0x0c, 0xa3, 0x6c, 0x5f, 0x57,
	0x27, 0xd1, 0x05, 0x96, 0x1e, 0x42, 0xbb, 0x3f, 0xd8, 0x63, 0xa2, 0x17, 0xd4, 0x99, 0xe9, 0x05,
	0xd6, 0x7f, 0x52, 0xea, 0xff, 0x56, 0x80, 0x46, 0x5a, 0x15, 0x81, 0x92, 0x6c, 0xd6, 0xb1, 0x79,
	0xe4, 0xe3, 0xc5, 0x4a, 0x56, 0xb8, 0x62, 0x25, 0x5b, 0x28, 0x46, 0xc5, 0x2b, 0x16, 0xa3, 0x7d,
	0xf8, 0x20, 0xdd, 0x12, 0x5f, 0xbe, 0xd7, 0x5a, 0x4d, 0x7a, 0x66, 0xa1, 0x29, 0xbe, 0xbf, 0xf2,
	0x55, 0xef, 0x2f, 0xbe, 0xa9, 0xca, 0x15, 0x6e, 0xea, 0x08, 0xda, 0x83, 0xfe, 0xc2, 0x4d, 0x3d,
	0xe5, 0x8d, 0x2e, 0x1f, 0xa9, 0x1e, 0x2f, 0xbb, 0xc6, 0xa4, 0x44, 0x74, 0x25, 0x40, 0x7f, 0xa6,
	0xf1, 0xe4, 0xa9, 0x14, 0x5e, 0x78, 0xe9, 0xf1, 0x49, 0x0b, 0x57, 0x3d, 0xe9, 0x92, 0xa2, 0xfc,
	0x57, 0x8d, 0xa7, 0xec, 0x78, 0x0f, 0xff, 0x23, 0x9e, 0x41, 0x7f, 0xaf, 0xf1, 0xa8, 0x12, 0x39,
	0x2d, 0x4e, 0x1d, 0x97, 0x8d, 0xaa, 0x8c, 0x04, 0xdb, 0x81, 0xaa, 0x11, 0x30, 0xd7, 0x48, 0x92,
	0x95, 0x9c, 0xc6, 0xd9, 0xa7, 0xb4, 0x90, 0x7d, 0x6c, 0xf3, 0x4c, 0x56, 0x0a, 0x1c, 0x2f, 0x79,
	0xe3, 0x13, 0xee, 0x5a, 0xf3, 0xdb, 0xfd, 0xf8, 0xb7, 0x1a, 0x54, 0x5f, 0x04, 0x41, 0x9f, 0x67,
	0xdf, 0x06, 0x54, 0x07, 0x53, 0xd3, 0x64, 0x61, 0xd8, 0xbe, 0x46, 0x00, 0x2a, 0xdf, 0x37, 0x6c,
	0x87, 0x59, 0x6d, 0x8d, 0x7f, 0xe0, 0x15, 0xe3, 0xe5, 0x34, 0x6a, 0x17, 0xc8, 0x0d, 0x68, 0x1f,
	0xb8, 0xe7, 0x86, 0x63, 0x5b, 0xaf, 0x8c, 0xc0, 0x98, 0xb0, 0x88, 0x05, 0xed, 0x22, 0x59, 0x03,
	0xf2, 0x9c, 0x85, 0x2c, 0xb0, 0x0d, 0xc7, 0x7e, 0xcb, 0x2c, 0x29, 0x5a, 0x22, 0x6d, 0x68, 0x4a,
	0xf4, 0xb1, 0x77, 0xc6, 0xdc, 0x76, 0x99, 0x10, 0x68, 0x1d, 0x79, 0xd1, 0x8b, 0x37, 0x76, 0x18,
	0xbd, 0x42, 0xc3, 0xb4, 0x2b, 0x1c, 0x75, 0xe4, 0x45, 0x87, 0xe2, 0x55, 0x32, 0x61, 0xed, 0x2a,
	0x69, 0x01, 0x1c, 0x79, 0x7b, 0xc6, 0x84, 0xf5, 0x3d, 0x77, 0xd4, 0xae, 0x7d, 0xbc, 0x01, 0xd5,
	0xc3, 0x70, 0x8c, 0xdb, 0xbc, 0x05, 0x37, 0x44, 0xc9, 0xf6, 0x2c, 0x96, 0x4a, 0xb4, 0xed, 0x5f,
	0x1e, 0xed, 0x7c, 0xd3, 0x94, 0xe5, 0xfc, 0x70, 0x1c, 0x90, 0x4f, 0xa1, 0xf4, 0xca, 0x76, 0xc7,
	0x64, 0x6d, 0x4b, 0xfc, 0xd0, 0xdb, 0x52, 0x7f, 0xfb, 0xb6, 0x5e, 0x4c, 0xfc, 0x68, 0xd6, 0xcd,
	0x59, 0x27, 0x2e, 0xd4, 0x93, 0xdf, 0x58, 0xd9, 0xaf, 0xa9, 0xf4, 0xef, 0xbc, 0x6e, 0x36, 0x24,
	0xfd, 0x33, 0x8c, 0xde, 0xfe, 0xf9, 0x5f, 0xbe, 0xfd, 0x55, 0xe1, 0x26, 0xbd, 0xbe, 0xad, 0xa0,
	0xdb, 0x09, 0xc5, 0x08, 0xaa, 0xea, 0xb7, 0xd3, 0xbd, 0x3c, 0x36, 0x09, 0xe8, 0xde, 0xcb, 0xe3,
	0x92, 0x00, 0x7a, 0x0b, 0x99, 0xae, 0xd3, 0x0f, 0x12, 0x26, 0xa5, 0xfc, 0xeb, 0xd4, 0x0f, 0xa9,
	0x5e, 0x2e, 0x91, 0x44, 0x74, 0x7b, 0xb9, 0x4c, 0x12, 0x41, 0xbb, 0x48, 0x75, 0x83, 0x92, 0x14,
	0x95, 0xd2, 0x7f, 0x12, 0xff, 0x6b, 0x58, 0xcf, 0x67, 0xe2, 0xdf, 0xbb, 0xeb, 0xf9, 0x3c, 0xf8,
	0x1f, 0xad, 0x83, 0x2c, 0x84, 0xb6, 0xd3, 0x2c, 0xa8, 0xf9, 0xed, 0xc2, 0xa3, 0x7c, 0x23, 0x8f,
	0x29, 0x8d, 0xea, 0x6e, 0xe4, 0xf1, 0xa5, 0x51, 0x74, 0x1d, 0x59, 0x3b, 0x74, 0x2d, 0x61, 0x9d,
	0xe3, 0x72, 0xa1, 0x9e, 0xbc, 0x73, 0xef, 0x2f, 0x25, 0xce, 0xf7, 0x91, 0x18, 0x92, 0xe5, 0x23,
	0x09, 0xc5, 0xf9, 0xfc, 0x23, 0xf5, 0x41, 0x1e, 0x63, 0x0a, 0xd4, 0x7d, 0x90, 0xc7, 0x99, 0x02,
	0xd1, 0xbb, 0xc8, 0xfa, 0x21, 0xbd, 0x99, 0xb0, 0xa6, 0x89, 0xdc, 0xf4, 0xa3, 0x22, 0xf7, 0x9c,
	0x31, 0x24, 0xff, 0x9c, 0x31, 0x24, 0xeb, 0x9c, 0x09, 0x45, 0x04, 0x2d, 0x5e, 0x26, 0x1c, 0x27,
	0x6e, 0xca, 0xf3, 0x42, 0x42, 0x01, 0x72, 0x43, 0x22, 0x7e, 0x2f, 0xf4, 0x90, 0xb0, 0x4b, 0x3b,
	0x09, 0xe1, 0x02, 0xc7, 0x4f, 0xa0, 0x91, 0xee, 0x4c, 0x69, 0x0e, 0x65, 0x0a, 0xd3, 0xa5, 0x39,
	0xac, 0x29, 0x0c, 0xad, 0x20, 0xf1, 0x35, 0xae, 0x3e, 0xdd, 0x10, 0xd2, 0x8b, 0x4e, 0x24, 0x30,
	0xb9, 0xea, 0xd3, 0x0d, 0xab, 0x52, 0x3f, 0x12, 0x36, 0x4b, 0xf5, 0x0b, 0x0f, 0x73, 0x18, 0xe6,
	0x61, 0xdd, 0x87, 0x39, 0x24, 0xf3, 0xb0, 0x98, 0xe7, 0x18, 0x6a, 0x71, 0x09, 0xbf, 0xb7, 0x84,
	0x21, 0xf7, 0x56, 0x14, 0x20, 0xbd, 0xfb, 0x85, 0x0a, 0xfa, 0xf0, 0x42, 0xf3, 0x2b, 0x58, 0xee,
	0xee, 0xe7, 0x61, 0x8a, 0x67, 0xf7, 0xe6, 0x9f, 0xde, 0xad, 0x6b, 0x7f, 0x7e, 0xb7, 0xae, 0xfd,
	0xfd, 0xdd, 0xba, 0xf6, 0xcd, 0x3f, 0xd6, 0xaf, 0xfd, 0xa8, 0x68, 0xf8, 0xf6, 0xbf, 0x03, 0x00,
	0x00, 0xff, 0xff, 0xd4, 0xca, 0x8b, 0xf8, 0x59, 0x1a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MatchMgrClient is the client API for MatchMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MatchMgrClient interface {
	Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	BonusPool(ctx context.Context, in *CSHBonusPool, opts ...grpc.CallOption) (*SCHBonusPool, error)
	RankBar(ctx context.Context, in *CSHRankBar, opts ...grpc.CallOption) (*SCHRankBar, error)
	RealRank(ctx context.Context, in *CSHRealRank, opts ...grpc.CallOption) (*SCHRealRank, error)
	Reward(ctx context.Context, in *CSHReward, opts ...grpc.CallOption) (*SCHReward, error)
	MatchInfoTip(ctx context.Context, in *CSHMatchInfoTip, opts ...grpc.CallOption) (*SCHMatchInfoTip, error)
	MatchInfo(ctx context.Context, in *CSHMatchInfo, opts ...grpc.CallOption) (*SCHMatchInfo, error)
	HistoryRank(ctx context.Context, in *CSHHistoryRank, opts ...grpc.CallOption) (*SCHHistoryRank, error)
	LuckyInfo(ctx context.Context, in *CSHLuckyInfo, opts ...grpc.CallOption) (*SCHLuckyInfo, error)
	GetAllMatchCfg(ctx context.Context, in *CSMatchCfg, opts ...grpc.CallOption) (*SCMatchCfg, error)
	// 以下接口内部使用
	UpdateBonus(ctx context.Context, in *CSUpdateBonus, opts ...grpc.CallOption) (*SCUpdateBonus, error)
	MatchResult(ctx context.Context, in *CSMatchResult, opts ...grpc.CallOption) (*SCMatchResult, error)
	GetAwardRecord(ctx context.Context, in *CSGetAwardRecord, opts ...grpc.CallOption) (*SCGetAwardRecord, error)
	GetAward(ctx context.Context, in *CSGetAward, opts ...grpc.CallOption) (*SCGetAward, error)
	UpdateUserInfo(ctx context.Context, in *CSUpdateUserInfo, opts ...grpc.CallOption) (*SCUpdateUserInfo, error)
}

type matchMgrClient struct {
	cc *grpc.ClientConn
}

func NewMatchMgrClient(cc *grpc.ClientConn) MatchMgrClient {
	return &matchMgrClient{cc}
}

func (c *matchMgrClient) Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) BonusPool(ctx context.Context, in *CSHBonusPool, opts ...grpc.CallOption) (*SCHBonusPool, error) {
	out := new(SCHBonusPool)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/BonusPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) RankBar(ctx context.Context, in *CSHRankBar, opts ...grpc.CallOption) (*SCHRankBar, error) {
	out := new(SCHRankBar)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/RankBar", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) RealRank(ctx context.Context, in *CSHRealRank, opts ...grpc.CallOption) (*SCHRealRank, error) {
	out := new(SCHRealRank)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/RealRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) Reward(ctx context.Context, in *CSHReward, opts ...grpc.CallOption) (*SCHReward, error) {
	out := new(SCHReward)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/Reward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) MatchInfoTip(ctx context.Context, in *CSHMatchInfoTip, opts ...grpc.CallOption) (*SCHMatchInfoTip, error) {
	out := new(SCHMatchInfoTip)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/MatchInfoTip", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) MatchInfo(ctx context.Context, in *CSHMatchInfo, opts ...grpc.CallOption) (*SCHMatchInfo, error) {
	out := new(SCHMatchInfo)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/MatchInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) HistoryRank(ctx context.Context, in *CSHHistoryRank, opts ...grpc.CallOption) (*SCHHistoryRank, error) {
	out := new(SCHHistoryRank)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/HistoryRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) LuckyInfo(ctx context.Context, in *CSHLuckyInfo, opts ...grpc.CallOption) (*SCHLuckyInfo, error) {
	out := new(SCHLuckyInfo)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/LuckyInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) GetAllMatchCfg(ctx context.Context, in *CSMatchCfg, opts ...grpc.CallOption) (*SCMatchCfg, error) {
	out := new(SCMatchCfg)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/GetAllMatchCfg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) UpdateBonus(ctx context.Context, in *CSUpdateBonus, opts ...grpc.CallOption) (*SCUpdateBonus, error) {
	out := new(SCUpdateBonus)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/UpdateBonus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) MatchResult(ctx context.Context, in *CSMatchResult, opts ...grpc.CallOption) (*SCMatchResult, error) {
	out := new(SCMatchResult)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/MatchResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) GetAwardRecord(ctx context.Context, in *CSGetAwardRecord, opts ...grpc.CallOption) (*SCGetAwardRecord, error) {
	out := new(SCGetAwardRecord)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/GetAwardRecord", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) GetAward(ctx context.Context, in *CSGetAward, opts ...grpc.CallOption) (*SCGetAward, error) {
	out := new(SCGetAward)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/GetAward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchMgrClient) UpdateUserInfo(ctx context.Context, in *CSUpdateUserInfo, opts ...grpc.CallOption) (*SCUpdateUserInfo, error) {
	out := new(SCUpdateUserInfo)
	err := c.cc.Invoke(ctx, "/matchmgr.service.v1.MatchMgr/UpdateUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MatchMgrServer is the server API for MatchMgr service.
type MatchMgrServer interface {
	Ping(context.Context, *empty.Empty) (*empty.Empty, error)
	BonusPool(context.Context, *CSHBonusPool) (*SCHBonusPool, error)
	RankBar(context.Context, *CSHRankBar) (*SCHRankBar, error)
	RealRank(context.Context, *CSHRealRank) (*SCHRealRank, error)
	Reward(context.Context, *CSHReward) (*SCHReward, error)
	MatchInfoTip(context.Context, *CSHMatchInfoTip) (*SCHMatchInfoTip, error)
	MatchInfo(context.Context, *CSHMatchInfo) (*SCHMatchInfo, error)
	HistoryRank(context.Context, *CSHHistoryRank) (*SCHHistoryRank, error)
	LuckyInfo(context.Context, *CSHLuckyInfo) (*SCHLuckyInfo, error)
	GetAllMatchCfg(context.Context, *CSMatchCfg) (*SCMatchCfg, error)
	// 以下接口内部使用
	UpdateBonus(context.Context, *CSUpdateBonus) (*SCUpdateBonus, error)
	MatchResult(context.Context, *CSMatchResult) (*SCMatchResult, error)
	GetAwardRecord(context.Context, *CSGetAwardRecord) (*SCGetAwardRecord, error)
	GetAward(context.Context, *CSGetAward) (*SCGetAward, error)
	UpdateUserInfo(context.Context, *CSUpdateUserInfo) (*SCUpdateUserInfo, error)
}

// UnimplementedMatchMgrServer can be embedded to have forward compatible implementations.
type UnimplementedMatchMgrServer struct {
}

func (*UnimplementedMatchMgrServer) Ping(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (*UnimplementedMatchMgrServer) BonusPool(ctx context.Context, req *CSHBonusPool) (*SCHBonusPool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BonusPool not implemented")
}
func (*UnimplementedMatchMgrServer) RankBar(ctx context.Context, req *CSHRankBar) (*SCHRankBar, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RankBar not implemented")
}
func (*UnimplementedMatchMgrServer) RealRank(ctx context.Context, req *CSHRealRank) (*SCHRealRank, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RealRank not implemented")
}
func (*UnimplementedMatchMgrServer) Reward(ctx context.Context, req *CSHReward) (*SCHReward, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reward not implemented")
}
func (*UnimplementedMatchMgrServer) MatchInfoTip(ctx context.Context, req *CSHMatchInfoTip) (*SCHMatchInfoTip, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchInfoTip not implemented")
}
func (*UnimplementedMatchMgrServer) MatchInfo(ctx context.Context, req *CSHMatchInfo) (*SCHMatchInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchInfo not implemented")
}
func (*UnimplementedMatchMgrServer) HistoryRank(ctx context.Context, req *CSHHistoryRank) (*SCHHistoryRank, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HistoryRank not implemented")
}
func (*UnimplementedMatchMgrServer) LuckyInfo(ctx context.Context, req *CSHLuckyInfo) (*SCHLuckyInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LuckyInfo not implemented")
}
func (*UnimplementedMatchMgrServer) GetAllMatchCfg(ctx context.Context, req *CSMatchCfg) (*SCMatchCfg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllMatchCfg not implemented")
}
func (*UnimplementedMatchMgrServer) UpdateBonus(ctx context.Context, req *CSUpdateBonus) (*SCUpdateBonus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBonus not implemented")
}
func (*UnimplementedMatchMgrServer) MatchResult(ctx context.Context, req *CSMatchResult) (*SCMatchResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchResult not implemented")
}
func (*UnimplementedMatchMgrServer) GetAwardRecord(ctx context.Context, req *CSGetAwardRecord) (*SCGetAwardRecord, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAwardRecord not implemented")
}
func (*UnimplementedMatchMgrServer) GetAward(ctx context.Context, req *CSGetAward) (*SCGetAward, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAward not implemented")
}
func (*UnimplementedMatchMgrServer) UpdateUserInfo(ctx context.Context, req *CSUpdateUserInfo) (*SCUpdateUserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserInfo not implemented")
}

func RegisterMatchMgrServer(s *grpc.Server, srv MatchMgrServer) {
	s.RegisterService(&_MatchMgr_serviceDesc, srv)
}

func _MatchMgr_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).Ping(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_BonusPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSHBonusPool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).BonusPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/BonusPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).BonusPool(ctx, req.(*CSHBonusPool))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_RankBar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSHRankBar)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).RankBar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/RankBar",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).RankBar(ctx, req.(*CSHRankBar))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_RealRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSHRealRank)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).RealRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/RealRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).RealRank(ctx, req.(*CSHRealRank))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_Reward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSHReward)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).Reward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/Reward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).Reward(ctx, req.(*CSHReward))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_MatchInfoTip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSHMatchInfoTip)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).MatchInfoTip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/MatchInfoTip",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).MatchInfoTip(ctx, req.(*CSHMatchInfoTip))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_MatchInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSHMatchInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).MatchInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/MatchInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).MatchInfo(ctx, req.(*CSHMatchInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_HistoryRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSHHistoryRank)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).HistoryRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/HistoryRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).HistoryRank(ctx, req.(*CSHHistoryRank))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_LuckyInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSHLuckyInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).LuckyInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/LuckyInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).LuckyInfo(ctx, req.(*CSHLuckyInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_GetAllMatchCfg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSMatchCfg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).GetAllMatchCfg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/GetAllMatchCfg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).GetAllMatchCfg(ctx, req.(*CSMatchCfg))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_UpdateBonus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSUpdateBonus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).UpdateBonus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/UpdateBonus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).UpdateBonus(ctx, req.(*CSUpdateBonus))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_MatchResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSMatchResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).MatchResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/MatchResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).MatchResult(ctx, req.(*CSMatchResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_GetAwardRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSGetAwardRecord)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).GetAwardRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/GetAwardRecord",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).GetAwardRecord(ctx, req.(*CSGetAwardRecord))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_GetAward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSGetAward)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).GetAward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/GetAward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).GetAward(ctx, req.(*CSGetAward))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchMgr_UpdateUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSUpdateUserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchMgrServer).UpdateUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matchmgr.service.v1.MatchMgr/UpdateUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchMgrServer).UpdateUserInfo(ctx, req.(*CSUpdateUserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

var _MatchMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "matchmgr.service.v1.MatchMgr",
	HandlerType: (*MatchMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _MatchMgr_Ping_Handler,
		},
		{
			MethodName: "BonusPool",
			Handler:    _MatchMgr_BonusPool_Handler,
		},
		{
			MethodName: "RankBar",
			Handler:    _MatchMgr_RankBar_Handler,
		},
		{
			MethodName: "RealRank",
			Handler:    _MatchMgr_RealRank_Handler,
		},
		{
			MethodName: "Reward",
			Handler:    _MatchMgr_Reward_Handler,
		},
		{
			MethodName: "MatchInfoTip",
			Handler:    _MatchMgr_MatchInfoTip_Handler,
		},
		{
			MethodName: "MatchInfo",
			Handler:    _MatchMgr_MatchInfo_Handler,
		},
		{
			MethodName: "HistoryRank",
			Handler:    _MatchMgr_HistoryRank_Handler,
		},
		{
			MethodName: "LuckyInfo",
			Handler:    _MatchMgr_LuckyInfo_Handler,
		},
		{
			MethodName: "GetAllMatchCfg",
			Handler:    _MatchMgr_GetAllMatchCfg_Handler,
		},
		{
			MethodName: "UpdateBonus",
			Handler:    _MatchMgr_UpdateBonus_Handler,
		},
		{
			MethodName: "MatchResult",
			Handler:    _MatchMgr_MatchResult_Handler,
		},
		{
			MethodName: "GetAwardRecord",
			Handler:    _MatchMgr_GetAwardRecord_Handler,
		},
		{
			MethodName: "GetAward",
			Handler:    _MatchMgr_GetAward_Handler,
		},
		{
			MethodName: "UpdateUserInfo",
			Handler:    _MatchMgr_UpdateUserInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *Object3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Object3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.Value))
		i--
		dAtA[i] = 0x10
	}
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSHBonusPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSHBonusPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSHBonusPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.GameId))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if m.TimeId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.TimeId))
		i--
		dAtA[i] = 0x10
	}
	if m.MathcId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.MathcId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HBonusPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HBonusPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HBonusPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.Count))
		i--
		dAtA[i] = 0x20
	}
	if m.Value != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.Value))
		i--
		dAtA[i] = 0x18
	}
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.MatchId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.MatchId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCHBonusPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCHBonusPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCHBonusPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pool) > 0 {
		for iNdEx := len(m.Pool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CSHRankBar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSHRankBar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSHRankBar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.GameId))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if m.TimeId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.TimeId))
		i--
		dAtA[i] = 0x10
	}
	if m.MathcId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.MathcId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCHRankBar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCHRankBar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCHRankBar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reaward == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.Reaward))
		i--
		dAtA[i] = 0x18
	}
	if m.Total == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.Total))
		i--
		dAtA[i] = 0x10
	}
	if m.Idx == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RealRank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RealRank) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RealRank) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BigGiftId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.BigGiftId)
		copy(dAtA[i:], *m.BigGiftId)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.BigGiftId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Goods) > 0 {
		for iNdEx := len(m.Goods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Goods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Score != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.Score))
		i--
		dAtA[i] = 0x20
	}
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Icon == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Icon)
		copy(dAtA[i:], *m.Icon)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Icon)))
		i--
		dAtA[i] = 0x12
	}
	if m.Idx == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSHRealRank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSHRealRank) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSHRealRank) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.GameId))
		i--
		dAtA[i] = 0x20
	}
	if m.TimeId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.TimeId))
		i--
		dAtA[i] = 0x18
	}
	if m.MathcId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.MathcId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCHRealRank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCHRealRank) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCHRealRank) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SplitAwardId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.SplitAwardId))
		i--
		dAtA[i] = 0x40
	}
	if m.VipAddition != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.VipAddition))
		i--
		dAtA[i] = 0x38
	}
	if m.CardAddition != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.CardAddition))
		i--
		dAtA[i] = 0x30
	}
	if m.RewardAddition != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.RewardAddition))
		i--
		dAtA[i] = 0x28
	}
	if m.ScoreAddition != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.ScoreAddition))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalNum != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.TotalNum))
		i--
		dAtA[i] = 0x18
	}
	if m.OnselfRank != nil {
		{
			size, err := m.OnselfRank.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.RealRank) > 0 {
		for iNdEx := len(m.RealRank) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RealRank[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Reward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Goods) > 0 {
		for iNdEx := len(m.Goods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Goods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Idxr == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.Idxr))
		i--
		dAtA[i] = 0x10
	}
	if m.Idxl == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.Idxl))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSHReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSHReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSHReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if m.TimeId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.TimeId))
		i--
		dAtA[i] = 0x10
	}
	if m.MathcId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.MathcId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCHReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCHReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCHReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rewards) > 0 {
		for iNdEx := len(m.Rewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CSHMatchInfoTip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSHMatchInfoTip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSHMatchInfoTip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchInfoTip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchInfoTip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchInfoTip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Goods) > 0 {
		for iNdEx := len(m.Goods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Goods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Time == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Time)
		copy(dAtA[i:], *m.Time)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Time)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MathcId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.MathcId))
		i--
		dAtA[i] = 0x10
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SCHMatchInfoTip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCHMatchInfoTip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCHMatchInfoTip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MatchTips) > 0 {
		for iNdEx := len(m.MatchTips) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchTips[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CSHMatchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSHMatchInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSHMatchInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCHMatchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCHMatchInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCHMatchInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MatchOpen == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i--
		if *m.MatchOpen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Time == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Time)
		copy(dAtA[i:], *m.Time)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Time)))
		i--
		dAtA[i] = 0x32
	}
	if m.Down != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.Down))
		i--
		dAtA[i] = 0x28
	}
	if m.Status != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.TimeId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.TimeId))
		i--
		dAtA[i] = 0x18
	}
	if m.MathcId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.MathcId))
		i--
		dAtA[i] = 0x10
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HistoryRank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistoryRank) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HistoryRank) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BigGiftId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.BigGiftId)
		copy(dAtA[i:], *m.BigGiftId)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.BigGiftId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.LuckyGoods) > 0 {
		for iNdEx := len(m.LuckyGoods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LuckyGoods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PackGoods) > 0 {
		for iNdEx := len(m.PackGoods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PackGoods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.MatchGoods) > 0 {
		for iNdEx := len(m.MatchGoods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchGoods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Addition != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.Addition))
		i--
		dAtA[i] = 0x28
	}
	if m.AdditionSource != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.AdditionSource))
		i--
		dAtA[i] = 0x20
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Icon != nil {
		i -= len(*m.Icon)
		copy(dAtA[i:], *m.Icon)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Icon)))
		i--
		dAtA[i] = 0x12
	}
	if m.Idx == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSHHistoryRank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSHHistoryRank) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSHHistoryRank) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCHHistoryRank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCHHistoryRank) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCHHistoryRank) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OneselfRank == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		{
			size, err := m.OneselfRank.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RankList) > 0 {
		for iNdEx := len(m.RankList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RankList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MatchId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.MatchId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSHLuckyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSHLuckyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSHLuckyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.MatchId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.MatchId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuckyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuckyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuckyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RRange == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.RRange))
		i--
		dAtA[i] = 0x10
	}
	if m.LRange == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.LRange))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCHLuckyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCHLuckyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCHLuckyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SplitData) > 0 {
		for iNdEx := len(m.SplitData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SplitData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MatchId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.MatchId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSMatchCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSMatchCfg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSMatchCfg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SCMatchCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCMatchCfg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCMatchCfg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MatchList) > 0 {
		for iNdEx := len(m.MatchList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatchCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchCfg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchCfg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MatchEndTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.MatchEndTime)
		copy(dAtA[i:], *m.MatchEndTime)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.MatchEndTime)))
		i--
		dAtA[i] = 0x3a
	}
	if m.MatchBeginTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.MatchBeginTime)
		copy(dAtA[i:], *m.MatchBeginTime)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.MatchBeginTime)))
		i--
		dAtA[i] = 0x32
	}
	if m.ShowEndTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.ShowEndTime)
		copy(dAtA[i:], *m.ShowEndTime)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.ShowEndTime)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ShowBeginTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.ShowBeginTime)
		copy(dAtA[i:], *m.ShowBeginTime)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.ShowBeginTime)))
		i--
		dAtA[i] = 0x22
	}
	if m.MatchType == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.MatchType))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSUpdateBonus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSUpdateBonus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSUpdateBonus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0x22
	}
	if m.Field == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Field)
		copy(dAtA[i:], *m.Field)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Field)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Key)
		copy(dAtA[i:], *m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.GameId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCUpdateBonus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCUpdateBonus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCUpdateBonus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Msg != nil {
		i -= len(*m.Msg)
		copy(dAtA[i:], *m.Msg)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchIdentify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchIdentify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchIdentify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RoundId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.RoundId))
		i--
		dAtA[i] = 0x18
	}
	if m.Date == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Date)
		copy(dAtA[i:], *m.Date)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Date)))
		i--
		dAtA[i] = 0x12
	}
	if m.MatchId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.MatchId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSMatchResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSMatchResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSMatchResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.Icon == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Icon)
		copy(dAtA[i:], *m.Icon)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Icon)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Idx == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.Idx))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *SCMatchResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCMatchResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCMatchResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.User3) > 0 {
		for iNdEx := len(m.User3) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.User3[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Ranks) > 0 {
		for iNdEx := len(m.Ranks) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintApi(dAtA, i, uint64(m.Ranks[iNdEx]))
			i--
			dAtA[i] = 0x10
		}
	}
	if m.Match == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CSGetAwardRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSGetAwardRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSGetAwardRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AwardRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwardRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AwardRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.User3) > 0 {
		for iNdEx := len(m.User3) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.User3[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Match == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SplitAwardGoods) > 0 {
		for iNdEx := len(m.SplitAwardGoods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SplitAwardGoods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.LuckyGoods) > 0 {
		for iNdEx := len(m.LuckyGoods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LuckyGoods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.MatchGoods) > 0 {
		for iNdEx := len(m.MatchGoods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchGoods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Rank == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.Rank))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCGetAwardRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCGetAwardRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCGetAwardRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CSGetAward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSGetAward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSGetAward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != nil {
		i = encodeVarintApi(dAtA, i, uint64(*m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if m.Match == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PlayerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCGetAward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCGetAward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCGetAward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SplitAwardGoods) > 0 {
		for iNdEx := len(m.SplitAwardGoods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SplitAwardGoods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.LuckyGoods) > 0 {
		for iNdEx := len(m.LuckyGoods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LuckyGoods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.MatchGoods) > 0 {
		for iNdEx := len(m.MatchGoods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchGoods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *CSUpdateUserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSUpdateUserInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSUpdateUserInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BigGiftId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.BigGiftId)
		copy(dAtA[i:], *m.BigGiftId)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.BigGiftId)))
		i--
		dAtA[i] = 0x32
	}
	if m.Nick == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Nick)
		copy(dAtA[i:], *m.Nick)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Nick)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Icon == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Icon)
		copy(dAtA[i:], *m.Icon)
		i = encodeVarintApi(dAtA, i, uint64(len(*m.Icon)))
		i--
		dAtA[i] = 0x22
	}
	if m.ArenaId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.GameId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintApi(dAtA, i, uint64(*m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCUpdateUserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCUpdateUserInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCUpdateUserInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Object3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		n += 1 + sovApi(uint64(*m.Key))
	}
	if m.Value != nil {
		n += 1 + sovApi(uint64(*m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSHBonusPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MathcId != nil {
		n += 1 + sovApi(uint64(*m.MathcId))
	}
	if m.TimeId != nil {
		n += 1 + sovApi(uint64(*m.TimeId))
	}
	if m.PlayerId != nil {
		n += 1 + sovApi(uint64(*m.PlayerId))
	}
	if m.GameId != nil {
		n += 1 + sovApi(uint64(*m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HBonusPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchId != nil {
		n += 1 + sovApi(uint64(*m.MatchId))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Value != nil {
		n += 1 + sovApi(uint64(*m.Value))
	}
	if m.Count != nil {
		n += 1 + sovApi(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCHBonusPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pool) > 0 {
		for _, e := range m.Pool {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSHRankBar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MathcId != nil {
		n += 1 + sovApi(uint64(*m.MathcId))
	}
	if m.TimeId != nil {
		n += 1 + sovApi(uint64(*m.TimeId))
	}
	if m.PlayerId != nil {
		n += 1 + sovApi(uint64(*m.PlayerId))
	}
	if m.GameId != nil {
		n += 1 + sovApi(uint64(*m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCHRankBar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != nil {
		n += 1 + sovApi(uint64(*m.Idx))
	}
	if m.Total != nil {
		n += 1 + sovApi(uint64(*m.Total))
	}
	if m.Reaward != nil {
		n += 1 + sovApi(uint64(*m.Reaward))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RealRank) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != nil {
		n += 1 + sovApi(uint64(*m.Idx))
	}
	if m.Icon != nil {
		l = len(*m.Icon)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Score != nil {
		n += 1 + sovApi(uint64(*m.Score))
	}
	if len(m.Goods) > 0 {
		for _, e := range m.Goods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.BigGiftId != nil {
		l = len(*m.BigGiftId)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSHRealRank) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovApi(uint64(*m.PlayerId))
	}
	if m.MathcId != nil {
		n += 1 + sovApi(uint64(*m.MathcId))
	}
	if m.TimeId != nil {
		n += 1 + sovApi(uint64(*m.TimeId))
	}
	if m.GameId != nil {
		n += 1 + sovApi(uint64(*m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCHRealRank) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RealRank) > 0 {
		for _, e := range m.RealRank {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.OnselfRank != nil {
		l = m.OnselfRank.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TotalNum != nil {
		n += 1 + sovApi(uint64(*m.TotalNum))
	}
	if m.ScoreAddition != nil {
		n += 1 + sovApi(uint64(*m.ScoreAddition))
	}
	if m.RewardAddition != nil {
		n += 1 + sovApi(uint64(*m.RewardAddition))
	}
	if m.CardAddition != nil {
		n += 1 + sovApi(uint64(*m.CardAddition))
	}
	if m.VipAddition != nil {
		n += 1 + sovApi(uint64(*m.VipAddition))
	}
	if m.SplitAwardId != nil {
		n += 1 + sovApi(uint64(*m.SplitAwardId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Reward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idxl != nil {
		n += 1 + sovApi(uint64(*m.Idxl))
	}
	if m.Idxr != nil {
		n += 1 + sovApi(uint64(*m.Idxr))
	}
	if len(m.Goods) > 0 {
		for _, e := range m.Goods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSHReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MathcId != nil {
		n += 1 + sovApi(uint64(*m.MathcId))
	}
	if m.TimeId != nil {
		n += 1 + sovApi(uint64(*m.TimeId))
	}
	if m.GameId != nil {
		n += 1 + sovApi(uint64(*m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCHReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSHMatchInfoTip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != nil {
		n += 1 + sovApi(uint64(*m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchInfoTip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MathcId != nil {
		n += 1 + sovApi(uint64(*m.MathcId))
	}
	if m.Time != nil {
		l = len(*m.Time)
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Goods) > 0 {
		for _, e := range m.Goods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCHMatchInfoTip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MatchTips) > 0 {
		for _, e := range m.MatchTips {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSHMatchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovApi(uint64(*m.PlayerId))
	}
	if m.GameId != nil {
		n += 1 + sovApi(uint64(*m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCHMatchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MathcId != nil {
		n += 1 + sovApi(uint64(*m.MathcId))
	}
	if m.TimeId != nil {
		n += 1 + sovApi(uint64(*m.TimeId))
	}
	if m.Status != nil {
		n += 1 + sovApi(uint64(*m.Status))
	}
	if m.Down != nil {
		n += 1 + sovApi(uint64(*m.Down))
	}
	if m.Time != nil {
		l = len(*m.Time)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchOpen != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HistoryRank) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != nil {
		n += 1 + sovApi(uint64(*m.Idx))
	}
	if m.Icon != nil {
		l = len(*m.Icon)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.AdditionSource != nil {
		n += 1 + sovApi(uint64(*m.AdditionSource))
	}
	if m.Addition != nil {
		n += 1 + sovApi(uint64(*m.Addition))
	}
	if len(m.MatchGoods) > 0 {
		for _, e := range m.MatchGoods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.PackGoods) > 0 {
		for _, e := range m.PackGoods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.LuckyGoods) > 0 {
		for _, e := range m.LuckyGoods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.BigGiftId != nil {
		l = len(*m.BigGiftId)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSHHistoryRank) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovApi(uint64(*m.PlayerId))
	}
	if m.MatchId != nil {
		n += 1 + sovApi(uint64(*m.MatchId))
	}
	if m.GameId != nil {
		n += 1 + sovApi(uint64(*m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCHHistoryRank) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchId != nil {
		n += 1 + sovApi(uint64(*m.MatchId))
	}
	if len(m.RankList) > 0 {
		for _, e := range m.RankList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.OneselfRank != nil {
		l = m.OneselfRank.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSHLuckyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchId != nil {
		n += 1 + sovApi(uint64(*m.MatchId))
	}
	if m.GameId != nil {
		n += 1 + sovApi(uint64(*m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuckyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LRange != nil {
		n += 1 + sovApi(uint64(*m.LRange))
	}
	if m.RRange != nil {
		n += 1 + sovApi(uint64(*m.RRange))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCHLuckyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchId != nil {
		n += 1 + sovApi(uint64(*m.MatchId))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.SplitData) > 0 {
		for _, e := range m.SplitData {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSMatchCfg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCMatchCfg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MatchList) > 0 {
		for _, e := range m.MatchList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchCfg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != nil {
		n += 1 + sovApi(uint64(*m.GameId))
	}
	if m.MatchId != nil {
		n += 1 + sovApi(uint64(*m.MatchId))
	}
	if m.MatchType != nil {
		n += 1 + sovApi(uint64(*m.MatchType))
	}
	if m.ShowBeginTime != nil {
		l = len(*m.ShowBeginTime)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ShowEndTime != nil {
		l = len(*m.ShowEndTime)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchBeginTime != nil {
		l = len(*m.MatchBeginTime)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchEndTime != nil {
		l = len(*m.MatchEndTime)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSUpdateBonus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != nil {
		n += 1 + sovApi(uint64(*m.GameId))
	}
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Field != nil {
		l = len(*m.Field)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCUpdateBonus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != nil {
		n += 1 + sovApi(uint64(*m.Code))
	}
	if m.Msg != nil {
		l = len(*m.Msg)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchIdentify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchId != nil {
		n += 1 + sovApi(uint64(*m.MatchId))
	}
	if m.Date != nil {
		l = len(*m.Date)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.RoundId != nil {
		n += 1 + sovApi(uint64(*m.RoundId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSMatchResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != nil {
		n += 1 + sovApi(uint64(*m.Idx))
	}
	if m.Icon != nil {
		l = len(*m.Icon)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCMatchResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Ranks) > 0 {
		for _, e := range m.Ranks {
			n += 1 + sovApi(uint64(e))
		}
	}
	if len(m.User3) > 0 {
		for _, e := range m.User3 {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSGetAwardRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovApi(uint64(*m.PlayerId))
	}
	if m.GameId != nil {
		n += 1 + sovApi(uint64(*m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AwardRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rank != nil {
		n += 1 + sovApi(uint64(*m.Rank))
	}
	if len(m.MatchGoods) > 0 {
		for _, e := range m.MatchGoods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.LuckyGoods) > 0 {
		for _, e := range m.LuckyGoods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.SplitAwardGoods) > 0 {
		for _, e := range m.SplitAwardGoods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.User3) > 0 {
		for _, e := range m.User3 {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCGetAwardRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSGetAward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovApi(uint64(*m.PlayerId))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != nil {
		n += 1 + sovApi(uint64(*m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCGetAward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MatchGoods) > 0 {
		for _, e := range m.MatchGoods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.LuckyGoods) > 0 {
		for _, e := range m.LuckyGoods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.SplitAwardGoods) > 0 {
		for _, e := range m.SplitAwardGoods {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSUpdateUserInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovApi(uint64(*m.PlayerId))
	}
	if m.GameId != nil {
		n += 1 + sovApi(uint64(*m.GameId))
	}
	if m.ArenaId != nil {
		n += 1 + sovApi(uint64(*m.ArenaId))
	}
	if m.Icon != nil {
		l = len(*m.Icon)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Nick != nil {
		l = len(*m.Nick)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BigGiftId != nil {
		l = len(*m.BigGiftId)
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCUpdateUserInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Object3) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Key = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSHBonusPool) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSHBonusPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSHBonusPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MathcId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MathcId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HBonusPool) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HBonusPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HBonusPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MatchId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCHBonusPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCHBonusPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCHBonusPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pool = append(m.Pool, &HBonusPool{})
			if err := m.Pool[len(m.Pool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSHRankBar) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSHRankBar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSHRankBar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MathcId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MathcId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCHRankBar) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCHRankBar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCHRankBar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Idx = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Total = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reaward", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reaward = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RealRank) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RealRank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RealRank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Idx = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Icon = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Score = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Goods = append(m.Goods, &Object3{})
			if err := m.Goods[len(m.Goods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigGiftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BigGiftId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSHRealRank) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSHRealRank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSHRealRank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MathcId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MathcId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeId = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCHRealRank) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCHRealRank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCHRealRank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealRank = append(m.RealRank, &RealRank{})
			if err := m.RealRank[len(m.RealRank)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnselfRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnselfRank == nil {
				m.OnselfRank = &RealRank{}
			}
			if err := m.OnselfRank.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNum", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalNum = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreAddition", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ScoreAddition = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAddition", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RewardAddition = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardAddition", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CardAddition = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipAddition", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VipAddition = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitAwardId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SplitAwardId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reward) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idxl", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Idxl = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idxr", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Idxr = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Goods = append(m.Goods, &Object3{})
			if err := m.Goods[len(m.Goods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSHReward) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSHReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSHReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MathcId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MathcId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCHReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCHReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCHReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, &Reward{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSHMatchInfoTip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSHMatchInfoTip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSHMatchInfoTip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchInfoTip) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchInfoTip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchInfoTip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MathcId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MathcId = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Time = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Goods = append(m.Goods, &Object3{})
			if err := m.Goods[len(m.Goods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCHMatchInfoTip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCHMatchInfoTip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCHMatchInfoTip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchTips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchTips = append(m.MatchTips, &MatchInfoTip{})
			if err := m.MatchTips[len(m.MatchTips)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSHMatchInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSHMatchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSHMatchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCHMatchInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCHMatchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCHMatchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MathcId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MathcId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeId = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Down", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Down = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Time = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchOpen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MatchOpen = &b
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistoryRank) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistoryRank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistoryRank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Idx = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Icon = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionSource", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdditionSource = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addition", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Addition = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchGoods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchGoods = append(m.MatchGoods, &Object3{})
			if err := m.MatchGoods[len(m.MatchGoods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackGoods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackGoods = append(m.PackGoods, &Object3{})
			if err := m.PackGoods[len(m.PackGoods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LuckyGoods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LuckyGoods = append(m.LuckyGoods, &Object3{})
			if err := m.LuckyGoods[len(m.LuckyGoods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigGiftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BigGiftId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSHHistoryRank) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSHHistoryRank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSHHistoryRank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MatchId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCHHistoryRank) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCHHistoryRank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCHHistoryRank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MatchId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankList = append(m.RankList, &HistoryRank{})
			if err := m.RankList[len(m.RankList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneselfRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OneselfRank == nil {
				m.OneselfRank = &HistoryRank{}
			}
			if err := m.OneselfRank.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSHLuckyInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSHLuckyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSHLuckyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MatchId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuckyInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LuckyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LuckyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LRange", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LRange = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RRange", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RRange = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCHLuckyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCHLuckyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCHLuckyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MatchId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &LuckyInfo{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitData = append(m.SplitData, &LuckyInfo{})
			if err := m.SplitData[len(m.SplitData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSMatchCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSMatchCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSMatchCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCMatchCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCMatchCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCMatchCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchList = append(m.MatchList, &MatchCfg{})
			if err := m.MatchList[len(m.MatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchCfg) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MatchId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MatchType = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowBeginTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ShowBeginTime = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowEndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ShowEndTime = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchBeginTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MatchBeginTime = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchEndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MatchEndTime = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000040)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSUpdateBonus) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSUpdateBonus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSUpdateBonus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Field = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCUpdateBonus) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCUpdateBonus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCUpdateBonus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Msg = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchIdentify) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchIdentify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchIdentify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MatchId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Date = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RoundId = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSMatchResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSMatchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSMatchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Idx = &v
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Icon = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCMatchResult) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCMatchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCMatchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &MatchIdentify{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ranks = append(m.Ranks, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ranks) == 0 {
					m.Ranks = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ranks = append(m.Ranks, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranks", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User3 = append(m.User3, &UserInfo{})
			if err := m.User3[len(m.User3)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSGetAwardRecord) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSGetAwardRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSGetAwardRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwardRecord) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwardRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwardRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rank = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchGoods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchGoods = append(m.MatchGoods, &Object3{})
			if err := m.MatchGoods[len(m.MatchGoods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LuckyGoods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LuckyGoods = append(m.LuckyGoods, &Object3{})
			if err := m.LuckyGoods[len(m.LuckyGoods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitAwardGoods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitAwardGoods = append(m.SplitAwardGoods, &Object3{})
			if err := m.SplitAwardGoods[len(m.SplitAwardGoods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &MatchIdentify{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User3 = append(m.User3, &UserInfo{})
			if err := m.User3[len(m.User3)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCGetAwardRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCGetAwardRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCGetAwardRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &AwardRecord{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSGetAward) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSGetAward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSGetAward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &MatchIdentify{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCGetAward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCGetAward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCGetAward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchGoods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchGoods = append(m.MatchGoods, &Object3{})
			if err := m.MatchGoods[len(m.MatchGoods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LuckyGoods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LuckyGoods = append(m.LuckyGoods, &Object3{})
			if err := m.LuckyGoods[len(m.LuckyGoods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitAwardGoods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitAwardGoods = append(m.SplitAwardGoods, &Object3{})
			if err := m.SplitAwardGoods[len(m.SplitAwardGoods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSUpdateUserInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSUpdateUserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSUpdateUserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ArenaId = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Icon = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nick", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Nick = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigGiftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BigGiftId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCUpdateUserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCUpdateUserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCUpdateUserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
