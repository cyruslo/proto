// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

// package 命名使用 {appid}.{version} 的方式, version 形如 v1, v2 ..

package api

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PayTypeCode int32

const (
	PayTypeCode_PayTypeInitCode PayTypeCode = 0
	PayTypeCode_Bonus           PayTypeCode = 2001
	PayTypeCode_Prize           PayTypeCode = 2002
	PayTypeCode_ServiceFee      PayTypeCode = 2003
)

var PayTypeCode_name = map[int32]string{
	0:    "PayTypeInitCode",
	2001: "Bonus",
	2002: "Prize",
	2003: "ServiceFee",
}

var PayTypeCode_value = map[string]int32{
	"PayTypeInitCode": 0,
	"Bonus":           2001,
	"Prize":           2002,
	"ServiceFee":      2003,
}

func (x PayTypeCode) String() string {
	return proto.EnumName(PayTypeCode_name, int32(x))
}

func (PayTypeCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

type MatchStatusCode int32

const (
	MatchStatusCode_InitCode     MatchStatusCode = 0
	MatchStatusCode_NotBegin     MatchStatusCode = 1
	MatchStatusCode_MatchEnd     MatchStatusCode = 2
	MatchStatusCode_NotSign      MatchStatusCode = 3
	MatchStatusCode_HaveSign     MatchStatusCode = 4
	MatchStatusCode_SignGaming   MatchStatusCode = 5
	MatchStatusCode_SignDeadline MatchStatusCode = 6
)

var MatchStatusCode_name = map[int32]string{
	0: "InitCode",
	1: "NotBegin",
	2: "MatchEnd",
	3: "NotSign",
	4: "HaveSign",
	5: "SignGaming",
	6: "SignDeadline",
}

var MatchStatusCode_value = map[string]int32{
	"InitCode":     0,
	"NotBegin":     1,
	"MatchEnd":     2,
	"NotSign":      3,
	"HaveSign":     4,
	"SignGaming":   5,
	"SignDeadline": 6,
}

func (x MatchStatusCode) String() string {
	return proto.EnumName(MatchStatusCode_name, int32(x))
}

func (MatchStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}

type IdentifyErrCode int32

const (
	IdentifyErrCode_ThingNotModify         IdentifyErrCode = 0
	IdentifyErrCode_GetConfigFail          IdentifyErrCode = 10100
	IdentifyErrCode_UserNotSign            IdentifyErrCode = 10101
	IdentifyErrCode_NotFullSignCondition   IdentifyErrCode = 10102
	IdentifyErrCode_NotFullSignPay         IdentifyErrCode = 10103
	IdentifyErrCode_SignFail               IdentifyErrCode = 10104
	IdentifyErrCode_CancelSignFail         IdentifyErrCode = 10105
	IdentifyErrCode_UploadScoreFail        IdentifyErrCode = 10106
	IdentifyErrCode_CheckUserStatusFail    IdentifyErrCode = 10107
	IdentifyErrCode_GetSignPayFail         IdentifyErrCode = 10108
	IdentifyErrCode_OverMatchCount         IdentifyErrCode = 10109
	IdentifyErrCode_GetMatchCountFail      IdentifyErrCode = 10110
	IdentifyErrCode_MatchSignFail          IdentifyErrCode = 10111
	IdentifyErrCode_SetCheckSignFail       IdentifyErrCode = 10112
	IdentifyErrCode_NotFindCheckRecord     IdentifyErrCode = 10113
	IdentifyErrCode_DistributeTableFail    IdentifyErrCode = 10114
	IdentifyErrCode_DelMatchCountFail      IdentifyErrCode = 10115
	IdentifyErrCode_GetBlindBetFail        IdentifyErrCode = 10116
	IdentifyErrCode_GetRewardInfoFail      IdentifyErrCode = 10117
	IdentifyErrCode_InitUserScoreFail      IdentifyErrCode = 10118
	IdentifyErrCode_CheckUserRankFail      IdentifyErrCode = 10119
	IdentifyErrCode_SendUserRewardFail     IdentifyErrCode = 10120
	IdentifyErrCode_ReSendTableFail        IdentifyErrCode = 10121
	IdentifyErrCode_SetBlindBetFail        IdentifyErrCode = 10122
	IdentifyErrCode_SetRoundBeginFail      IdentifyErrCode = 10123
	IdentifyErrCode_GetGetRankInfoFail     IdentifyErrCode = 10124
	IdentifyErrCode_QueryUserRewardFail    IdentifyErrCode = 10125
	IdentifyErrCode_GetUserRewardFail      IdentifyErrCode = 10126
	IdentifyErrCode_GetUserRecordFail      IdentifyErrCode = 10127
	IdentifyErrCode_DelCurrentNum          IdentifyErrCode = 10128
	IdentifyErrCode_GetUserScoreFail       IdentifyErrCode = 10129
	IdentifyErrCode_InitTableScoreFail     IdentifyErrCode = 10130
	IdentifyErrCode_RoundNumOverload       IdentifyErrCode = 10131
	IdentifyErrCode_NotInMatchTime         IdentifyErrCode = 10132
	IdentifyErrCode_GetRoundInfoFail       IdentifyErrCode = 10133
	IdentifyErrCode_GetMatchDurationFail   IdentifyErrCode = 10134
	IdentifyErrCode_GetTableInfoFail       IdentifyErrCode = 10135
	IdentifyErrCode_EditRoundFail          IdentifyErrCode = 10136
	IdentifyErrCode_EditBonusPoolFail      IdentifyErrCode = 10137
	IdentifyErrCode_EditMatchCountFail     IdentifyErrCode = 10138
	IdentifyErrCode_InitNewRoundFail       IdentifyErrCode = 10139
	IdentifyErrCode_SetUSerInfoFail        IdentifyErrCode = 10140
	IdentifyErrCode_QueryExistFail         IdentifyErrCode = 10141
	IdentifyErrCode_DelTableFail           IdentifyErrCode = 10142
	IdentifyErrCode_GetSingleTableUserFail IdentifyErrCode = 10143
)

var IdentifyErrCode_name = map[int32]string{
	0:     "ThingNotModify",
	10100: "GetConfigFail",
	10101: "UserNotSign",
	10102: "NotFullSignCondition",
	10103: "NotFullSignPay",
	10104: "SignFail",
	10105: "CancelSignFail",
	10106: "UploadScoreFail",
	10107: "CheckUserStatusFail",
	10108: "GetSignPayFail",
	10109: "OverMatchCount",
	10110: "GetMatchCountFail",
	10111: "MatchSignFail",
	10112: "SetCheckSignFail",
	10113: "NotFindCheckRecord",
	10114: "DistributeTableFail",
	10115: "DelMatchCountFail",
	10116: "GetBlindBetFail",
	10117: "GetRewardInfoFail",
	10118: "InitUserScoreFail",
	10119: "CheckUserRankFail",
	10120: "SendUserRewardFail",
	10121: "ReSendTableFail",
	10122: "SetBlindBetFail",
	10123: "SetRoundBeginFail",
	10124: "GetGetRankInfoFail",
	10125: "QueryUserRewardFail",
	10126: "GetUserRewardFail",
	10127: "GetUserRecordFail",
	10128: "DelCurrentNum",
	10129: "GetUserScoreFail",
	10130: "InitTableScoreFail",
	10131: "RoundNumOverload",
	10132: "NotInMatchTime",
	10133: "GetRoundInfoFail",
	10134: "GetMatchDurationFail",
	10135: "GetTableInfoFail",
	10136: "EditRoundFail",
	10137: "EditBonusPoolFail",
	10138: "EditMatchCountFail",
	10139: "InitNewRoundFail",
	10140: "SetUSerInfoFail",
	10141: "QueryExistFail",
	10142: "DelTableFail",
	10143: "GetSingleTableUserFail",
}

var IdentifyErrCode_value = map[string]int32{
	"ThingNotModify":         0,
	"GetConfigFail":          10100,
	"UserNotSign":            10101,
	"NotFullSignCondition":   10102,
	"NotFullSignPay":         10103,
	"SignFail":               10104,
	"CancelSignFail":         10105,
	"UploadScoreFail":        10106,
	"CheckUserStatusFail":    10107,
	"GetSignPayFail":         10108,
	"OverMatchCount":         10109,
	"GetMatchCountFail":      10110,
	"MatchSignFail":          10111,
	"SetCheckSignFail":       10112,
	"NotFindCheckRecord":     10113,
	"DistributeTableFail":    10114,
	"DelMatchCountFail":      10115,
	"GetBlindBetFail":        10116,
	"GetRewardInfoFail":      10117,
	"InitUserScoreFail":      10118,
	"CheckUserRankFail":      10119,
	"SendUserRewardFail":     10120,
	"ReSendTableFail":        10121,
	"SetBlindBetFail":        10122,
	"SetRoundBeginFail":      10123,
	"GetGetRankInfoFail":     10124,
	"QueryUserRewardFail":    10125,
	"GetUserRewardFail":      10126,
	"GetUserRecordFail":      10127,
	"DelCurrentNum":          10128,
	"GetUserScoreFail":       10129,
	"InitTableScoreFail":     10130,
	"RoundNumOverload":       10131,
	"NotInMatchTime":         10132,
	"GetRoundInfoFail":       10133,
	"GetMatchDurationFail":   10134,
	"GetTableInfoFail":       10135,
	"EditRoundFail":          10136,
	"EditBonusPoolFail":      10137,
	"EditMatchCountFail":     10138,
	"InitNewRoundFail":       10139,
	"SetUSerInfoFail":        10140,
	"QueryExistFail":         10141,
	"DelTableFail":           10142,
	"GetSingleTableUserFail": 10143,
}

func (x IdentifyErrCode) String() string {
	return proto.EnumName(IdentifyErrCode_name, int32(x))
}

func (IdentifyErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}

type ListReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListReq) Reset()         { *m = ListReq{} }
func (m *ListReq) String() string { return proto.CompactTextString(m) }
func (*ListReq) ProtoMessage()    {}
func (*ListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *ListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListReq.Merge(m, src)
}
func (m *ListReq) XXX_Size() int {
	return m.Size()
}
func (m *ListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListReq proto.InternalMessageInfo

type ListRsp struct {
	MatchList            []*MatchDetail `protobuf:"bytes,1,rep,name=MatchList,proto3" json:"MatchList" form:"MatchList" `
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ListRsp) Reset()         { *m = ListRsp{} }
func (m *ListRsp) String() string { return proto.CompactTextString(m) }
func (*ListRsp) ProtoMessage()    {}
func (*ListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *ListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRsp.Merge(m, src)
}
func (m *ListRsp) XXX_Size() int {
	return m.Size()
}
func (m *ListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ListRsp proto.InternalMessageInfo

type MatchDetail struct {
	Name                 string          `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name" form:"name" `
	ID                   int32           `protobuf:"varint,2,opt,name=ID,proto3" json:"ID" form:"ID"`
	TypeID               int32           `protobuf:"varint,3,opt,name=TypeID,proto3" json:"TypeID" form:"TypeID"`
	ArenaId              int32           `protobuf:"varint,4,opt,name=ArenaId,proto3" json:"ArenaID" form:"ArenaId" `
	LimitTimes           int32           `protobuf:"varint,5,opt,name=LimitTimes,proto3" json:"LimitTimes" form:"LimitTimes"`
	Order                int32           `protobuf:"varint,6,opt,name=Order,proto3" json:"Order" form:"Order" `
	ShowSingPay          *ShowPayDetail  `protobuf:"bytes,7,opt,name=ShowSingPay,proto3" json:"ShowSingPay" form:"ShowSingPay" `
	SignCondition        []*ThingsDetail `protobuf:"bytes,8,rep,name=SignCondition,proto3" json:"SignCondition" form:"SignCondition" `
	SigNum               *SignDetail     `protobuf:"bytes,9,opt,name=SigNum,proto3" json:"SigNum" form:"SigNum" `
	Status               MatchStatusCode `protobuf:"varint,10,opt,name=Status,proto3,enum=elimination.service.v1.MatchStatusCode" json:"Status" form:"Status" `
	Date                 *DateDetail     `protobuf:"bytes,11,opt,name=Date,proto3" json:"Date" form:"Date" `
	NowRound             int64           `protobuf:"varint,12,opt,name=NowRound,proto3" json:"NowRound" form:"NowRound" `
	Time                 *TimeDetail     `protobuf:"bytes,13,opt,name=Time,proto3" json:"Time" form:"Time" `
	BonusPoolNum         int64           `protobuf:"varint,14,opt,name=BonusPoolNum,proto3" json:"BonusPoolNum" form:"BonusPoolNum" `
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MatchDetail) Reset()         { *m = MatchDetail{} }
func (m *MatchDetail) String() string { return proto.CompactTextString(m) }
func (*MatchDetail) ProtoMessage()    {}
func (*MatchDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *MatchDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchDetail.Merge(m, src)
}
func (m *MatchDetail) XXX_Size() int {
	return m.Size()
}
func (m *MatchDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchDetail.DiscardUnknown(m)
}

var xxx_messageInfo_MatchDetail proto.InternalMessageInfo

type TimeDetail struct {
	BeginTime            string   `protobuf:"bytes,1,opt,name=BeginTime,proto3" json:"BeginTime" form:"BeginTime" `
	EndTime              string   `protobuf:"bytes,2,opt,name=EndTime,proto3" json:"EndTime" form:"EndTime" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TimeDetail) Reset()         { *m = TimeDetail{} }
func (m *TimeDetail) String() string { return proto.CompactTextString(m) }
func (*TimeDetail) ProtoMessage()    {}
func (*TimeDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *TimeDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeDetail.Merge(m, src)
}
func (m *TimeDetail) XXX_Size() int {
	return m.Size()
}
func (m *TimeDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeDetail.DiscardUnknown(m)
}

var xxx_messageInfo_TimeDetail proto.InternalMessageInfo

type SignPayDetail struct {
	MatchTimes           int32           `protobuf:"varint,1,opt,name=MatchTimes,proto3" json:"MatchTimes" form:"MatchTimes" `
	Pay                  []*ThingsDetail `protobuf:"bytes,2,rep,name=Pay,proto3" json:"Pay" form:"Pay" `
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SignPayDetail) Reset()         { *m = SignPayDetail{} }
func (m *SignPayDetail) String() string { return proto.CompactTextString(m) }
func (*SignPayDetail) ProtoMessage()    {}
func (*SignPayDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *SignPayDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignPayDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignPayDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignPayDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignPayDetail.Merge(m, src)
}
func (m *SignPayDetail) XXX_Size() int {
	return m.Size()
}
func (m *SignPayDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_SignPayDetail.DiscardUnknown(m)
}

var xxx_messageInfo_SignPayDetail proto.InternalMessageInfo

type ShowPayDetail struct {
	MatchTimes           int32               `protobuf:"varint,1,opt,name=MatchTimes,proto3" json:"MatchTimes" form:"MatchTimes" `
	Pay                  []*ShowThingsDetail `protobuf:"bytes,2,rep,name=Pay,proto3" json:"Pay" form:"Pay" `
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ShowPayDetail) Reset()         { *m = ShowPayDetail{} }
func (m *ShowPayDetail) String() string { return proto.CompactTextString(m) }
func (*ShowPayDetail) ProtoMessage()    {}
func (*ShowPayDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *ShowPayDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowPayDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowPayDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowPayDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowPayDetail.Merge(m, src)
}
func (m *ShowPayDetail) XXX_Size() int {
	return m.Size()
}
func (m *ShowPayDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowPayDetail.DiscardUnknown(m)
}

var xxx_messageInfo_ShowPayDetail proto.InternalMessageInfo

type SignDetail struct {
	Total                int32    `protobuf:"varint,1,opt,name=Total,proto3" json:"Total" form:"Total"`
	Num                  int32    `protobuf:"varint,2,opt,name=Num,proto3" json:"SignNum" form:"SignNum"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignDetail) Reset()         { *m = SignDetail{} }
func (m *SignDetail) String() string { return proto.CompactTextString(m) }
func (*SignDetail) ProtoMessage()    {}
func (*SignDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *SignDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignDetail.Merge(m, src)
}
func (m *SignDetail) XXX_Size() int {
	return m.Size()
}
func (m *SignDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_SignDetail.DiscardUnknown(m)
}

var xxx_messageInfo_SignDetail proto.InternalMessageInfo

type DateDetail struct {
	Property             string   `protobuf:"bytes,1,opt,name=Property,proto3" json:"Property" form:"Property"`
	Week                 []int32  `protobuf:"varint,2,rep,packed,name=Week,proto3" json:"Week" form:"Week"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DateDetail) Reset()         { *m = DateDetail{} }
func (m *DateDetail) String() string { return proto.CompactTextString(m) }
func (*DateDetail) ProtoMessage()    {}
func (*DateDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *DateDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DateDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DateDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DateDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DateDetail.Merge(m, src)
}
func (m *DateDetail) XXX_Size() int {
	return m.Size()
}
func (m *DateDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_DateDetail.DiscardUnknown(m)
}

var xxx_messageInfo_DateDetail proto.InternalMessageInfo

type DetailReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchId              int32    `protobuf:"varint,2,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"`
	ArenaId              int32    `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId"`
	TimeArenaId          int32    `protobuf:"varint,4,opt,name=TimeArenaId,proto3" json:"TimeArenaId" form:"TimeArenaId" `
	UserID               int64    `protobuf:"varint,5,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetailReq) Reset()         { *m = DetailReq{} }
func (m *DetailReq) String() string { return proto.CompactTextString(m) }
func (*DetailReq) ProtoMessage()    {}
func (*DetailReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *DetailReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetailReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetailReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetailReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetailReq.Merge(m, src)
}
func (m *DetailReq) XXX_Size() int {
	return m.Size()
}
func (m *DetailReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DetailReq.DiscardUnknown(m)
}

var xxx_messageInfo_DetailReq proto.InternalMessageInfo

type DetailRsp struct {
	Name                 string          `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name" form:"name" `
	ID                   int32           `protobuf:"varint,2,opt,name=ID,proto3" json:"ID" form:"ID"`
	BuyLimit             int32           `protobuf:"varint,3,opt,name=BuyLimit,proto3" json:"BuyLimit" form:"BuyLimit" `
	SignLimit            int32           `protobuf:"varint,4,opt,name=SignLimit,proto3" json:"SignLimit" form:"SignLimit" `
	EnterDeadline        string          `protobuf:"bytes,5,opt,name=EnterDeadline,proto3" json:"EnterDeadline" form:"EnterDeadline"`
	MatchTime            *TimeDetail     `protobuf:"bytes,6,opt,name=MatchTime,proto3" json:"MatchTime" form:"MatchTime" `
	ShowSingPay          *ShowPayDetail  `protobuf:"bytes,7,opt,name=ShowSingPay,proto3" json:"ShowSingPay" form:"ShowSingPay" `
	SignCondition        []*ThingsDetail `protobuf:"bytes,8,rep,name=SignCondition,proto3" json:"SignCondition" form:"SignCondition" `
	SigNum               *SignDetail     `protobuf:"bytes,9,opt,name=SigNum,proto3" json:"SigNum" form:"SigNum" `
	BlindBet             *BlindBetDetail `protobuf:"bytes,10,opt,name=BlindBet,proto3" json:"BlindBet" form:"BlindBet" `
	Scoreboard           *BoardDetail    `protobuf:"bytes,11,opt,name=Scoreboard,proto3" json:"Scoreboard" form:"Scoreboard" `
	InitScoreBoard       int64           `protobuf:"varint,12,opt,name=InitScoreBoard,proto3" json:"InitScoreboard" form:"InitScoreboard" `
	NowRound             int64           `protobuf:"varint,13,opt,name=NowRound,proto3" json:"NowRound" form:"NowRound" `
	Status               MatchStatusCode `protobuf:"varint,14,opt,name=Status,proto3,enum=elimination.service.v1.MatchStatusCode" json:"Status" form:"Status" `
	MatchDuration        int64           `protobuf:"varint,15,opt,name=MatchDuration,proto3" json:"MatchDuration" form:"MatchDuration"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DetailRsp) Reset()         { *m = DetailRsp{} }
func (m *DetailRsp) String() string { return proto.CompactTextString(m) }
func (*DetailRsp) ProtoMessage()    {}
func (*DetailRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *DetailRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetailRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetailRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetailRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetailRsp.Merge(m, src)
}
func (m *DetailRsp) XXX_Size() int {
	return m.Size()
}
func (m *DetailRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_DetailRsp.DiscardUnknown(m)
}

var xxx_messageInfo_DetailRsp proto.InternalMessageInfo

type BlindBetDetail struct {
	NowBet               *BetDetail `protobuf:"bytes,1,opt,name=NowBet,proto3" json:"NowBet" form:"NowBet" `
	NextBet              *BetDetail `protobuf:"bytes,2,opt,name=NextBet,proto3" json:"NextBet" form:"NextBet"`
	RiseBetTime          int64      `protobuf:"varint,3,opt,name=RiseBetTime,proto3" json:"RiseBetTime" form:"RiseBetTime" `
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BlindBetDetail) Reset()         { *m = BlindBetDetail{} }
func (m *BlindBetDetail) String() string { return proto.CompactTextString(m) }
func (*BlindBetDetail) ProtoMessage()    {}
func (*BlindBetDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *BlindBetDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlindBetDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlindBetDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlindBetDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlindBetDetail.Merge(m, src)
}
func (m *BlindBetDetail) XXX_Size() int {
	return m.Size()
}
func (m *BlindBetDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_BlindBetDetail.DiscardUnknown(m)
}

var xxx_messageInfo_BlindBetDetail proto.InternalMessageInfo

type BetDetail struct {
	BetLevel             int32    `protobuf:"varint,1,opt,name=BetLevel,proto3" json:"BetLevel" form:"BetLevel" `
	MaxBet               int64    `protobuf:"varint,2,opt,name=MaxBet,proto3" json:"MaxBet" form:"MaxBet"`
	MinBet               int64    `protobuf:"varint,3,opt,name=MinBet,proto3" json:"MinBet" form:"MinBet" `
	FrontBet             int64    `protobuf:"varint,4,opt,name=FrontBet,proto3" json:"FrontBet" form:"FrontBet" `
	BlindTimeInterval    int64    `protobuf:"varint,5,opt,name=BlindTimeInterval,proto3" json:"BlindTimeInterval" form:"BlindTimeInterval" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BetDetail) Reset()         { *m = BetDetail{} }
func (m *BetDetail) String() string { return proto.CompactTextString(m) }
func (*BetDetail) ProtoMessage()    {}
func (*BetDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *BetDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BetDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BetDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BetDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BetDetail.Merge(m, src)
}
func (m *BetDetail) XXX_Size() int {
	return m.Size()
}
func (m *BetDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_BetDetail.DiscardUnknown(m)
}

var xxx_messageInfo_BetDetail proto.InternalMessageInfo

type BoardDetail struct {
	MaxScore             int64    `protobuf:"varint,1,opt,name=MaxScore,proto3" json:"MaxScore" form:"MaxScore"`
	MinScore             int64    `protobuf:"varint,2,opt,name=MinScore,proto3" json:"MinScore" form:"MinScore" `
	AverageScore         float32  `protobuf:"fixed32,3,opt,name=AverageScore,proto3" json:"AverageScore" form:"AverageScore" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BoardDetail) Reset()         { *m = BoardDetail{} }
func (m *BoardDetail) String() string { return proto.CompactTextString(m) }
func (*BoardDetail) ProtoMessage()    {}
func (*BoardDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *BoardDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoardDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoardDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoardDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoardDetail.Merge(m, src)
}
func (m *BoardDetail) XXX_Size() int {
	return m.Size()
}
func (m *BoardDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_BoardDetail.DiscardUnknown(m)
}

var xxx_messageInfo_BoardDetail proto.InternalMessageInfo

type RewardInfoReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchId              int32    `protobuf:"varint,2,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"`
	ArenaId              int32    `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId"`
	Round                int64    `protobuf:"varint,4,opt,name=Round,proto3" json:"Round" form:"Round" `
	UserID               int64    `protobuf:"varint,5,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RewardInfoReq) Reset()         { *m = RewardInfoReq{} }
func (m *RewardInfoReq) String() string { return proto.CompactTextString(m) }
func (*RewardInfoReq) ProtoMessage()    {}
func (*RewardInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *RewardInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardInfoReq.Merge(m, src)
}
func (m *RewardInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *RewardInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_RewardInfoReq proto.InternalMessageInfo

type RewardInfoRsp struct {
	RewardPool           int64               `protobuf:"varint,1,opt,name=RewardPool,proto3" json:"RewardPool" form:"RewardPool"`
	PersonNum            int64               `protobuf:"varint,2,opt,name=PersonNum,proto3" json:"PersonNum" form:"PersonNum"`
	TotalRewardNum       int64               `protobuf:"varint,3,opt,name=TotalRewardNum,proto3" json:"TotalRewardNum" form:"TotalRewardNum"`
	RewardList           []*RewardInfoDetail `protobuf:"bytes,4,rep,name=RewardList,proto3" json:"RewardList" form:"RewardList" `
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RewardInfoRsp) Reset()         { *m = RewardInfoRsp{} }
func (m *RewardInfoRsp) String() string { return proto.CompactTextString(m) }
func (*RewardInfoRsp) ProtoMessage()    {}
func (*RewardInfoRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *RewardInfoRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardInfoRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardInfoRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardInfoRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardInfoRsp.Merge(m, src)
}
func (m *RewardInfoRsp) XXX_Size() int {
	return m.Size()
}
func (m *RewardInfoRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardInfoRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RewardInfoRsp proto.InternalMessageInfo

type RewardInfoDetail struct {
	Rank                 []int64               `protobuf:"varint,1,rep,packed,name=Rank,proto3" json:"Rank" form:"Rank"`
	RewardList           []*RewardThingsDetail `protobuf:"bytes,2,rep,name=RewardList,proto3" json:"RewardList" form:"RewardList"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *RewardInfoDetail) Reset()         { *m = RewardInfoDetail{} }
func (m *RewardInfoDetail) String() string { return proto.CompactTextString(m) }
func (*RewardInfoDetail) ProtoMessage()    {}
func (*RewardInfoDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *RewardInfoDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardInfoDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardInfoDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardInfoDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardInfoDetail.Merge(m, src)
}
func (m *RewardInfoDetail) XXX_Size() int {
	return m.Size()
}
func (m *RewardInfoDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardInfoDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RewardInfoDetail proto.InternalMessageInfo

type RewardThingsDetail struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID" form:"ID" `
	Num                  int64    `protobuf:"varint,2,opt,name=Num,proto3" json:"Num" form:"Num"`
	Rate                 float32  `protobuf:"fixed32,3,opt,name=Rate,proto3" json:"Rate" form:"Rate"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RewardThingsDetail) Reset()         { *m = RewardThingsDetail{} }
func (m *RewardThingsDetail) String() string { return proto.CompactTextString(m) }
func (*RewardThingsDetail) ProtoMessage()    {}
func (*RewardThingsDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *RewardThingsDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardThingsDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardThingsDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardThingsDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardThingsDetail.Merge(m, src)
}
func (m *RewardThingsDetail) XXX_Size() int {
	return m.Size()
}
func (m *RewardThingsDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardThingsDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RewardThingsDetail proto.InternalMessageInfo

type RewardDetail struct {
	Rank                 []int64         `protobuf:"varint,1,rep,packed,name=Rank,proto3" json:"Rank" form:"Rank"`
	RewardList           []*ThingsDetail `protobuf:"bytes,2,rep,name=RewardList,proto3" json:"RewardList" form:"RewardList"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RewardDetail) Reset()         { *m = RewardDetail{} }
func (m *RewardDetail) String() string { return proto.CompactTextString(m) }
func (*RewardDetail) ProtoMessage()    {}
func (*RewardDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *RewardDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardDetail.Merge(m, src)
}
func (m *RewardDetail) XXX_Size() int {
	return m.Size()
}
func (m *RewardDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RewardDetail proto.InternalMessageInfo

type UserInfoReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchId              int32    `protobuf:"varint,2,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"  validate:"required"`
	ArenaId              int32    `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId"`
	TimeArenaId          int32    `protobuf:"varint,4,opt,name=TimeArenaId,proto3" json:"TimeArenaId" form:"TimeArenaId"`
	Round                int64    `protobuf:"varint,5,opt,name=Round,proto3" json:"Round" form:"Round"  validate:"required"`
	UserID               int64    `protobuf:"varint,6,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	BeginPoint           int32    `protobuf:"varint,7,opt,name=BeginPoint,proto3" json:"BeginPoint" form:"BeginPoint"  validate:"required"`
	EndPoint             int32    `protobuf:"varint,8,opt,name=EndPoint,proto3" json:"EndPoint" form:"EndPoint"  validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserInfoReq) Reset()         { *m = UserInfoReq{} }
func (m *UserInfoReq) String() string { return proto.CompactTextString(m) }
func (*UserInfoReq) ProtoMessage()    {}
func (*UserInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{18}
}
func (m *UserInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserInfoReq.Merge(m, src)
}
func (m *UserInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *UserInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserInfoReq proto.InternalMessageInfo

type UserInfoRsp struct {
	MatchName            string        `protobuf:"bytes,1,opt,name=MatchName,proto3" json:"MatchName" form:"MatchName" `
	MatchDuration        int64         `protobuf:"varint,2,opt,name=MatchDuration,proto3" json:"MatchDuration" form:"MatchDuration"`
	TotalScore           int64         `protobuf:"varint,3,opt,name=TotalScore,proto3" json:"TotalScore" form:"TotalScore"`
	AverageScore         float32       `protobuf:"fixed32,4,opt,name=AverageScore,proto3" json:"AverageScore" form:"AverageScore"`
	MaxScore             int64         `protobuf:"varint,5,opt,name=MaxScore,proto3" json:"MaxScore" form:"MaxScore"`
	MinScore             int64         `protobuf:"varint,6,opt,name=MinScore,proto3" json:"MinScore" form:"MinScore"`
	BonusNum             int64         `protobuf:"varint,7,opt,name=BonusNum,proto3" json:"BonusNum" form:"BonusNum" `
	TotalNum             int64         `protobuf:"varint,8,opt,name=TotalNum,proto3" json:"TotalNum" form:"TotalNum" `
	PersonNum            int64         `protobuf:"varint,9,opt,name=PersonNum,proto3" json:"PersonNum" form:"PersonNum" `
	SelfInfo             *UserDetail   `protobuf:"bytes,10,opt,name=SelfInfo,proto3" json:"SelfInfo" form:"SelfInfo" `
	UserScoreList        []*UserDetail `protobuf:"bytes,11,rep,name=UserScoreList,proto3" json:"UserScoreList" form:"UserScoreList" `
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UserInfoRsp) Reset()         { *m = UserInfoRsp{} }
func (m *UserInfoRsp) String() string { return proto.CompactTextString(m) }
func (*UserInfoRsp) ProtoMessage()    {}
func (*UserInfoRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{19}
}
func (m *UserInfoRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserInfoRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserInfoRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserInfoRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserInfoRsp.Merge(m, src)
}
func (m *UserInfoRsp) XXX_Size() int {
	return m.Size()
}
func (m *UserInfoRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserInfoRsp.DiscardUnknown(m)
}

var xxx_messageInfo_UserInfoRsp proto.InternalMessageInfo

type UserDetail struct {
	Table                int64    `protobuf:"varint,1,opt,name=Table,proto3" json:"Table" form:"Table" `
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID" form:"UserID"`
	Hunt                 int64    `protobuf:"varint,3,opt,name=Hunt,proto3" json:"Hunt" form:"Hunt"`
	Bounty               int64    `protobuf:"varint,4,opt,name=Bounty,proto3" json:"Bounty" form:"Bounty"`
	Rank                 int64    `protobuf:"varint,5,opt,name=Rank,proto3" json:"Rank" form:"Rank"`
	Score                int64    `protobuf:"varint,6,opt,name=Score,proto3" json:"Score" form:"Score" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserDetail) Reset()         { *m = UserDetail{} }
func (m *UserDetail) String() string { return proto.CompactTextString(m) }
func (*UserDetail) ProtoMessage()    {}
func (*UserDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{20}
}
func (m *UserDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserDetail.Merge(m, src)
}
func (m *UserDetail) XXX_Size() int {
	return m.Size()
}
func (m *UserDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_UserDetail.DiscardUnknown(m)
}

var xxx_messageInfo_UserDetail proto.InternalMessageInfo

type TableInfoReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchId              int32    `protobuf:"varint,2,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"  validate:"required"`
	ArenaId              int32    `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId"`
	TimeArenaId          int32    `protobuf:"varint,4,opt,name=TimeArenaId,proto3" json:"TimeArenaId" form:"TimeArenaId"`
	Round                int64    `protobuf:"varint,5,opt,name=Round,proto3" json:"Round" form:"Round" `
	UserID               int64    `protobuf:"varint,6,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableInfoReq) Reset()         { *m = TableInfoReq{} }
func (m *TableInfoReq) String() string { return proto.CompactTextString(m) }
func (*TableInfoReq) ProtoMessage()    {}
func (*TableInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{21}
}
func (m *TableInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableInfoReq.Merge(m, src)
}
func (m *TableInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *TableInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TableInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_TableInfoReq proto.InternalMessageInfo

type TableInfoRsp struct {
	MatchNum             int32          `protobuf:"varint,1,opt,name=MatchNum,proto3" json:"MatchNum" form:"MatchNum" `
	StandardTableNum     int32          `protobuf:"varint,2,opt,name=StandardTableNum,proto3" json:"StandardTableNum" form:"StandardTableNum" `
	TableDetail          []*TableDetail `protobuf:"bytes,3,rep,name=TableDetail,proto3" json:"TableDetail" form:"TableDetail"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TableInfoRsp) Reset()         { *m = TableInfoRsp{} }
func (m *TableInfoRsp) String() string { return proto.CompactTextString(m) }
func (*TableInfoRsp) ProtoMessage()    {}
func (*TableInfoRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{22}
}
func (m *TableInfoRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableInfoRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableInfoRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableInfoRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableInfoRsp.Merge(m, src)
}
func (m *TableInfoRsp) XXX_Size() int {
	return m.Size()
}
func (m *TableInfoRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_TableInfoRsp.DiscardUnknown(m)
}

var xxx_messageInfo_TableInfoRsp proto.InternalMessageInfo

type TableDetail struct {
	TableNumber          int64    `protobuf:"varint,1,opt,name=TableNumber,proto3" json:"TableNumber" form:"TableNumber" `
	PersonNum            int32    `protobuf:"varint,2,opt,name=PersonNum,proto3" json:"PersonNum" form:"PersonNum" `
	MaxScore             int64    `protobuf:"varint,3,opt,name=MaxScore,proto3" json:"MaxScore" form:"MaxScore"`
	MinScore             int64    `protobuf:"varint,4,opt,name=MinScore,proto3" json:"MinScore" form:"MinScore"`
	AverageScore         int64    `protobuf:"varint,5,opt,name=AverageScore,proto3" json:"AverageScore" form:"AverageScore" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableDetail) Reset()         { *m = TableDetail{} }
func (m *TableDetail) String() string { return proto.CompactTextString(m) }
func (*TableDetail) ProtoMessage()    {}
func (*TableDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{23}
}
func (m *TableDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDetail.Merge(m, src)
}
func (m *TableDetail) XXX_Size() int {
	return m.Size()
}
func (m *TableDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDetail.DiscardUnknown(m)
}

var xxx_messageInfo_TableDetail proto.InternalMessageInfo

type UserRecordReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserRecordReq) Reset()         { *m = UserRecordReq{} }
func (m *UserRecordReq) String() string { return proto.CompactTextString(m) }
func (*UserRecordReq) ProtoMessage()    {}
func (*UserRecordReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{24}
}
func (m *UserRecordReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRecordReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRecordReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRecordReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRecordReq.Merge(m, src)
}
func (m *UserRecordReq) XXX_Size() int {
	return m.Size()
}
func (m *UserRecordReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRecordReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserRecordReq proto.InternalMessageInfo

type UserRecordRsp struct {
	MatchList            []*MatchInfo    `protobuf:"bytes,1,rep,name=MatchList,proto3" json:"MatchList" form:"MatchList" `
	EndMatchList         []*EndMatchInfo `protobuf:"bytes,2,rep,name=EndMatchList,proto3" json:"EndMatchList" form:"EndMatchList" `
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UserRecordRsp) Reset()         { *m = UserRecordRsp{} }
func (m *UserRecordRsp) String() string { return proto.CompactTextString(m) }
func (*UserRecordRsp) ProtoMessage()    {}
func (*UserRecordRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{25}
}
func (m *UserRecordRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRecordRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRecordRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRecordRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRecordRsp.Merge(m, src)
}
func (m *UserRecordRsp) XXX_Size() int {
	return m.Size()
}
func (m *UserRecordRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRecordRsp.DiscardUnknown(m)
}

var xxx_messageInfo_UserRecordRsp proto.InternalMessageInfo

type MatchInfo struct {
	Name                 string          `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name" form:"Name" `
	ID                   int32           `protobuf:"varint,2,opt,name=ID,proto3" json:"ID" form:"ID"`
	TypeID               int32           `protobuf:"varint,3,opt,name=TypeID,proto3" json:"TypeID" form:"TypeID"`
	ArenaId              int32           `protobuf:"varint,4,opt,name=ArenaId,proto3" json:"ArenaID" form:"ArenaId" `
	ShowSingPay          *ShowPayDetail  `protobuf:"bytes,5,opt,name=ShowSingPay,proto3" json:"ShowSingPay" form:"ShowSingPay" `
	SigNum               *SignDetail     `protobuf:"bytes,6,opt,name=SigNum,proto3" json:"SigNum" form:"SigNum" `
	Status               MatchStatusCode `protobuf:"varint,7,opt,name=Status,proto3,enum=elimination.service.v1.MatchStatusCode" json:"Status" form:"Status" `
	Time                 *TimeDetail     `protobuf:"bytes,8,opt,name=Time,proto3" json:"Time" form:"Time" `
	BonusPoolNum         int64           `protobuf:"varint,9,opt,name=BonusPoolNum,proto3" json:"BonusPoolNum" form:"BonusPoolNum" `
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MatchInfo) Reset()         { *m = MatchInfo{} }
func (m *MatchInfo) String() string { return proto.CompactTextString(m) }
func (*MatchInfo) ProtoMessage()    {}
func (*MatchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{26}
}
func (m *MatchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchInfo.Merge(m, src)
}
func (m *MatchInfo) XXX_Size() int {
	return m.Size()
}
func (m *MatchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MatchInfo proto.InternalMessageInfo

type EndMatchInfo struct {
	Name                 string          `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name" form:"Name" `
	ID                   int32           `protobuf:"varint,2,opt,name=ID,proto3" json:"ID" form:"ID"`
	ArenaId              int32           `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaID" form:"ArenaId" `
	Rank                 int64           `protobuf:"varint,4,opt,name=Rank,proto3" json:"Rank" form:"Rank" `
	Reward               []*ThingsDetail `protobuf:"bytes,5,rep,name=Reward,proto3" json:"Reward" form:"Reward" `
	ShowSingPay          *ShowPayDetail  `protobuf:"bytes,6,opt,name=ShowSingPay,proto3" json:"ShowSingPay" form:"ShowSingPay" `
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *EndMatchInfo) Reset()         { *m = EndMatchInfo{} }
func (m *EndMatchInfo) String() string { return proto.CompactTextString(m) }
func (*EndMatchInfo) ProtoMessage()    {}
func (*EndMatchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{27}
}
func (m *EndMatchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndMatchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EndMatchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EndMatchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndMatchInfo.Merge(m, src)
}
func (m *EndMatchInfo) XXX_Size() int {
	return m.Size()
}
func (m *EndMatchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EndMatchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EndMatchInfo proto.InternalMessageInfo

type SignCheckReq struct {
	GameID               int32           `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchId              int32           `protobuf:"varint,2,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"  validate:"required"`
	ArenaId              int32           `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId"`
	TimeArenaId          int32           `protobuf:"varint,4,opt,name=TimeArenaId,proto3" json:"TimeArenaId" form:"TimeArenaId"`
	UserID               int64           `protobuf:"varint,5,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	SelfThinsList        []*ThingsDetail `protobuf:"bytes,6,rep,name=SelfThinsList,proto3" json:"SelfThinsList" form:"SelfThinsList" `
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SignCheckReq) Reset()         { *m = SignCheckReq{} }
func (m *SignCheckReq) String() string { return proto.CompactTextString(m) }
func (*SignCheckReq) ProtoMessage()    {}
func (*SignCheckReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{28}
}
func (m *SignCheckReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignCheckReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignCheckReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignCheckReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignCheckReq.Merge(m, src)
}
func (m *SignCheckReq) XXX_Size() int {
	return m.Size()
}
func (m *SignCheckReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SignCheckReq.DiscardUnknown(m)
}

var xxx_messageInfo_SignCheckReq proto.InternalMessageInfo

type SignCheckRsp struct {
	UserID               int64          `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	IsFullConditon       bool           `protobuf:"varint,2,opt,name=IsFullConditon,proto3" json:"IsFullConditon" form:"IsFullConditon"`
	IsFullPay            bool           `protobuf:"varint,3,opt,name=IsFullPay,proto3" json:"IsFullPay" form:"IsFullPay" `
	SignPay              *SignPayDetail `protobuf:"bytes,4,opt,name=SignPay,proto3" json:"SignPay" form:"SignPay" `
	ShowSingPay          *ShowPayDetail `protobuf:"bytes,5,opt,name=ShowSingPay,proto3" json:"ShowSingPay" form:"ShowSingPay" `
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SignCheckRsp) Reset()         { *m = SignCheckRsp{} }
func (m *SignCheckRsp) String() string { return proto.CompactTextString(m) }
func (*SignCheckRsp) ProtoMessage()    {}
func (*SignCheckRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{29}
}
func (m *SignCheckRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignCheckRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignCheckRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignCheckRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignCheckRsp.Merge(m, src)
}
func (m *SignCheckRsp) XXX_Size() int {
	return m.Size()
}
func (m *SignCheckRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SignCheckRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SignCheckRsp proto.InternalMessageInfo

type SignCommonReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchId              int32    `protobuf:"varint,2,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"  validate:"required"`
	ArenaId              int32    `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId"`
	UserID               int64    `protobuf:"varint,4,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignCommonReq) Reset()         { *m = SignCommonReq{} }
func (m *SignCommonReq) String() string { return proto.CompactTextString(m) }
func (*SignCommonReq) ProtoMessage()    {}
func (*SignCommonReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{30}
}
func (m *SignCommonReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignCommonReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignCommonReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignCommonReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignCommonReq.Merge(m, src)
}
func (m *SignCommonReq) XXX_Size() int {
	return m.Size()
}
func (m *SignCommonReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SignCommonReq.DiscardUnknown(m)
}

var xxx_messageInfo_SignCommonReq proto.InternalMessageInfo

type SignEnsureRsp struct {
	IsFull               bool               `protobuf:"varint,1,opt,name=IsFull,proto3" json:"IsFull" form:"IsFull" `
	Round                int64              `protobuf:"varint,2,opt,name=Round,proto3" json:"Round" form:"Round" `
	IsSign               bool               `protobuf:"varint,3,opt,name=IsSign,proto3" json:"IsSign" form:"IsSign" `
	UserInfo             []*UserTableDetail `protobuf:"bytes,4,rep,name=UserInfo,proto3" json:"UserInfo" form:"UserInfo"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SignEnsureRsp) Reset()         { *m = SignEnsureRsp{} }
func (m *SignEnsureRsp) String() string { return proto.CompactTextString(m) }
func (*SignEnsureRsp) ProtoMessage()    {}
func (*SignEnsureRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{31}
}
func (m *SignEnsureRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignEnsureRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignEnsureRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignEnsureRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignEnsureRsp.Merge(m, src)
}
func (m *SignEnsureRsp) XXX_Size() int {
	return m.Size()
}
func (m *SignEnsureRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_SignEnsureRsp.DiscardUnknown(m)
}

var xxx_messageInfo_SignEnsureRsp proto.InternalMessageInfo

type SignInfo struct {
	UserID               int64    `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID" form:"UserID"`
	IsSign               bool     `protobuf:"varint,2,opt,name=IsSign,proto3" json:"IsSign" form:"IsSign" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignInfo) Reset()         { *m = SignInfo{} }
func (m *SignInfo) String() string { return proto.CompactTextString(m) }
func (*SignInfo) ProtoMessage()    {}
func (*SignInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{32}
}
func (m *SignInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignInfo.Merge(m, src)
}
func (m *SignInfo) XXX_Size() int {
	return m.Size()
}
func (m *SignInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SignInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SignInfo proto.InternalMessageInfo

type UserTableDetail struct {
	UserList             []int64  `protobuf:"varint,1,rep,packed,name=UserList,proto3" json:"UserList" form:"UserList"`
	Room                 string   `protobuf:"bytes,2,opt,name=Room,proto3" json:"Room" form:"Room" `
	Round                int64    `protobuf:"varint,3,opt,name=Round,proto3" json:"Round" form:"Round" `
	Table                int64    `protobuf:"varint,4,opt,name=Table,proto3" json:"Table" form:"Table" `
	ArenaId              int32    `protobuf:"varint,5,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserTableDetail) Reset()         { *m = UserTableDetail{} }
func (m *UserTableDetail) String() string { return proto.CompactTextString(m) }
func (*UserTableDetail) ProtoMessage()    {}
func (*UserTableDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{33}
}
func (m *UserTableDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserTableDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserTableDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserTableDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserTableDetail.Merge(m, src)
}
func (m *UserTableDetail) XXX_Size() int {
	return m.Size()
}
func (m *UserTableDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_UserTableDetail.DiscardUnknown(m)
}

var xxx_messageInfo_UserTableDetail proto.InternalMessageInfo

type CancelSignRsp struct {
	UserID               int64           `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID" form:"UserID"`
	IsCancel             bool            `protobuf:"varint,2,opt,name=IsCancel,proto3" json:"IsCancel" form:"IsCancel"`
	CancelPay            []*ThingsDetail `protobuf:"bytes,3,rep,name=CancelPay,proto3" json:"CancelPay" form:"CancelPay"`
	Round                int64           `protobuf:"varint,4,opt,name=Round,proto3" json:"Round" form:"Round"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CancelSignRsp) Reset()         { *m = CancelSignRsp{} }
func (m *CancelSignRsp) String() string { return proto.CompactTextString(m) }
func (*CancelSignRsp) ProtoMessage()    {}
func (*CancelSignRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{34}
}
func (m *CancelSignRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelSignRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelSignRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelSignRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelSignRsp.Merge(m, src)
}
func (m *CancelSignRsp) XXX_Size() int {
	return m.Size()
}
func (m *CancelSignRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelSignRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CancelSignRsp proto.InternalMessageInfo

type UploadReq struct {
	GameID               int32       `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchId              int32       `protobuf:"varint,2,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"  validate:"required"`
	ArenaId              int32       `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId"`
	TimeArenaId          int32       `protobuf:"varint,4,opt,name=TimeArenaId,proto3" json:"TimeArenaId" form:"TimeArenaId"`
	Round                int64       `protobuf:"varint,5,opt,name=Round,proto3" json:"Round" form:"Round" validate:"required"`
	Table                int64       `protobuf:"varint,6,opt,name=Table,proto3" json:"Table" form:"Table" validate:"required"`
	Room                 string      `protobuf:"bytes,7,opt,name=Room,proto3" json:"Room" form:"Room" validate:"required"`
	UserList             []*UserInfo `protobuf:"bytes,8,rep,name=UserList,proto3" json:"UserList" form:"UserList" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *UploadReq) Reset()         { *m = UploadReq{} }
func (m *UploadReq) String() string { return proto.CompactTextString(m) }
func (*UploadReq) ProtoMessage()    {}
func (*UploadReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{35}
}
func (m *UploadReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadReq.Merge(m, src)
}
func (m *UploadReq) XXX_Size() int {
	return m.Size()
}
func (m *UploadReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadReq.DiscardUnknown(m)
}

var xxx_messageInfo_UploadReq proto.InternalMessageInfo

type UserInfo struct {
	UserID               int64    `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID" form:"UserID"`
	Score                int64    `protobuf:"varint,2,opt,name=Score,proto3" json:"Score" form:"Score"`
	OutTimeStamp         int64    `protobuf:"varint,3,opt,name=OutTimeStamp,proto3" json:"OutTimeStamp" form:"OutTimeStamp"`
	OutNum               int32    `protobuf:"varint,4,opt,name=OutNum,proto3" json:"OutNum" form:"OutNum"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserInfo) Reset()         { *m = UserInfo{} }
func (m *UserInfo) String() string { return proto.CompactTextString(m) }
func (*UserInfo) ProtoMessage()    {}
func (*UserInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{36}
}
func (m *UserInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserInfo.Merge(m, src)
}
func (m *UserInfo) XXX_Size() int {
	return m.Size()
}
func (m *UserInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UserInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UserInfo proto.InternalMessageInfo

type UploadRsp struct {
	IsEnd                bool               `protobuf:"varint,1,opt,name=IsEnd,proto3" json:"IsEnd" form:"IsEnd" `
	IsSeparateTable      bool               `protobuf:"varint,2,opt,name=IsSeparateTable,proto3" json:"IsSeparateTable" form:"IsSeparateTable" `
	UploadRetry          bool               `protobuf:"varint,3,opt,name=UploadRetry,proto3" json:"UploadRetry" form:"UploadRetry" `
	UserTableInfo        []*UserTableDetail `protobuf:"bytes,4,rep,name=UserTableInfo,proto3" json:"UserTableInfo" form:"UserTableInfo" `
	RewardList           []*OutDetail       `protobuf:"bytes,5,rep,name=RewardList,proto3" json:"RewardList" form:"RewardList"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *UploadRsp) Reset()         { *m = UploadRsp{} }
func (m *UploadRsp) String() string { return proto.CompactTextString(m) }
func (*UploadRsp) ProtoMessage()    {}
func (*UploadRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{37}
}
func (m *UploadRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadRsp.Merge(m, src)
}
func (m *UploadRsp) XXX_Size() int {
	return m.Size()
}
func (m *UploadRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadRsp.DiscardUnknown(m)
}

var xxx_messageInfo_UploadRsp proto.InternalMessageInfo

type OutDetail struct {
	UserID               int64           `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID" form:"UserID"`
	Rank                 int64           `protobuf:"varint,2,opt,name=Rank,proto3" json:"Rank" form:"Rank"`
	RewardID             string          `protobuf:"bytes,3,opt,name=RewardID,proto3" json:"RewardID" form:"RewardID"`
	RewardList           []*ThingsDetail `protobuf:"bytes,4,rep,name=RewardList,proto3" json:"RewardList" form:"RewardList"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *OutDetail) Reset()         { *m = OutDetail{} }
func (m *OutDetail) String() string { return proto.CompactTextString(m) }
func (*OutDetail) ProtoMessage()    {}
func (*OutDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{38}
}
func (m *OutDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutDetail.Merge(m, src)
}
func (m *OutDetail) XXX_Size() int {
	return m.Size()
}
func (m *OutDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_OutDetail.DiscardUnknown(m)
}

var xxx_messageInfo_OutDetail proto.InternalMessageInfo

type QueryRewardReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryRewardReq) Reset()         { *m = QueryRewardReq{} }
func (m *QueryRewardReq) String() string { return proto.CompactTextString(m) }
func (*QueryRewardReq) ProtoMessage()    {}
func (*QueryRewardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{39}
}
func (m *QueryRewardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRewardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRewardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRewardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRewardReq.Merge(m, src)
}
func (m *QueryRewardReq) XXX_Size() int {
	return m.Size()
}
func (m *QueryRewardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRewardReq.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRewardReq proto.InternalMessageInfo

type QueryRewardRsp struct {
	RewardList           []*QueryRewardDetail `protobuf:"bytes,1,rep,name=RewardList,proto3" json:"RewardList" form:"RewardList" `
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *QueryRewardRsp) Reset()         { *m = QueryRewardRsp{} }
func (m *QueryRewardRsp) String() string { return proto.CompactTextString(m) }
func (*QueryRewardRsp) ProtoMessage()    {}
func (*QueryRewardRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{40}
}
func (m *QueryRewardRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRewardRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRewardRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRewardRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRewardRsp.Merge(m, src)
}
func (m *QueryRewardRsp) XXX_Size() int {
	return m.Size()
}
func (m *QueryRewardRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRewardRsp.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRewardRsp proto.InternalMessageInfo

type QueryRewardDetail struct {
	RewardID             string          `protobuf:"bytes,1,opt,name=RewardID,proto3" json:"RewardID" form:"RewardID" `
	MatchId              int32           `protobuf:"varint,2,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"  validate:"required"`
	ArenaId              int32           `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId"`
	Rank                 int64           `protobuf:"varint,4,opt,name=Rank,proto3" json:"Rank" form:"Rank"`
	ThinsList            []*ThingsDetail `protobuf:"bytes,5,rep,name=ThinsList,proto3" json:"ThinsList" form:"ThinsList"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *QueryRewardDetail) Reset()         { *m = QueryRewardDetail{} }
func (m *QueryRewardDetail) String() string { return proto.CompactTextString(m) }
func (*QueryRewardDetail) ProtoMessage()    {}
func (*QueryRewardDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{41}
}
func (m *QueryRewardDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRewardDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRewardDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRewardDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRewardDetail.Merge(m, src)
}
func (m *QueryRewardDetail) XXX_Size() int {
	return m.Size()
}
func (m *QueryRewardDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRewardDetail.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRewardDetail proto.InternalMessageInfo

type ThingsDetail struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID" form:"ID" `
	Num                  int64    `protobuf:"varint,2,opt,name=Num,proto3" json:"Num" form:"Num"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ThingsDetail) Reset()         { *m = ThingsDetail{} }
func (m *ThingsDetail) String() string { return proto.CompactTextString(m) }
func (*ThingsDetail) ProtoMessage()    {}
func (*ThingsDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{42}
}
func (m *ThingsDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThingsDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThingsDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThingsDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThingsDetail.Merge(m, src)
}
func (m *ThingsDetail) XXX_Size() int {
	return m.Size()
}
func (m *ThingsDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_ThingsDetail.DiscardUnknown(m)
}

var xxx_messageInfo_ThingsDetail proto.InternalMessageInfo

type ShowThingsDetail struct {
	PropID               int32       `protobuf:"varint,1,opt,name=PropID,proto3" json:"PropID" form:"PropID" `
	TypeID               PayTypeCode `protobuf:"varint,2,opt,name=TypeID,proto3,enum=elimination.service.v1.PayTypeCode" json:"TypeID" form:"TypeID" `
	Num                  int64       `protobuf:"varint,3,opt,name=Num,proto3" json:"Num" form:"Num"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ShowThingsDetail) Reset()         { *m = ShowThingsDetail{} }
func (m *ShowThingsDetail) String() string { return proto.CompactTextString(m) }
func (*ShowThingsDetail) ProtoMessage()    {}
func (*ShowThingsDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{43}
}
func (m *ShowThingsDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowThingsDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowThingsDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowThingsDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowThingsDetail.Merge(m, src)
}
func (m *ShowThingsDetail) XXX_Size() int {
	return m.Size()
}
func (m *ShowThingsDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowThingsDetail.DiscardUnknown(m)
}

var xxx_messageInfo_ShowThingsDetail proto.InternalMessageInfo

type GetRewardReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	UserID               int64    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	RewardID             string   `protobuf:"bytes,3,opt,name=RewardID,proto3" json:"RewardID" form:"RewardID" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRewardReq) Reset()         { *m = GetRewardReq{} }
func (m *GetRewardReq) String() string { return proto.CompactTextString(m) }
func (*GetRewardReq) ProtoMessage()    {}
func (*GetRewardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{44}
}
func (m *GetRewardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRewardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRewardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRewardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRewardReq.Merge(m, src)
}
func (m *GetRewardReq) XXX_Size() int {
	return m.Size()
}
func (m *GetRewardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRewardReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetRewardReq proto.InternalMessageInfo

type GetRewardRsp struct {
	RewardList           []*ThingsDetail `protobuf:"bytes,1,rep,name=RewardList,proto3" json:"RewardList" form:"RewardList"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetRewardRsp) Reset()         { *m = GetRewardRsp{} }
func (m *GetRewardRsp) String() string { return proto.CompactTextString(m) }
func (*GetRewardRsp) ProtoMessage()    {}
func (*GetRewardRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{45}
}
func (m *GetRewardRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRewardRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRewardRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRewardRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRewardRsp.Merge(m, src)
}
func (m *GetRewardRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetRewardRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRewardRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetRewardRsp proto.InternalMessageInfo

type TargetTableReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchId              int32    `protobuf:"varint,2,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"  validate:"required"`
	ArenaId              int32    `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId"`
	Round                int64    `protobuf:"varint,4,opt,name=Round,proto3" json:"Round" form:"Round" validate:"required"`
	Table                int64    `protobuf:"varint,5,opt,name=Table,proto3" json:"Table" form:"Table" validate:"required"`
	Room                 string   `protobuf:"bytes,6,opt,name=Room,proto3" json:"Room" form:"Room" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TargetTableReq) Reset()         { *m = TargetTableReq{} }
func (m *TargetTableReq) String() string { return proto.CompactTextString(m) }
func (*TargetTableReq) ProtoMessage()    {}
func (*TargetTableReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{46}
}
func (m *TargetTableReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetTableReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetTableReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetTableReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetTableReq.Merge(m, src)
}
func (m *TargetTableReq) XXX_Size() int {
	return m.Size()
}
func (m *TargetTableReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetTableReq.DiscardUnknown(m)
}

var xxx_messageInfo_TargetTableReq proto.InternalMessageInfo

type TargetTableRsp struct {
	BlindBet             *BlindBetDetail    `protobuf:"bytes,1,opt,name=BlindBet,proto3" json:"BlindBet" form:"BlindBet" `
	UserScoreList        []*TableUserDetail `protobuf:"bytes,2,rep,name=UserScoreList,proto3" json:"UserScoreList" form:"UserScoreList" `
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TargetTableRsp) Reset()         { *m = TargetTableRsp{} }
func (m *TargetTableRsp) String() string { return proto.CompactTextString(m) }
func (*TargetTableRsp) ProtoMessage()    {}
func (*TargetTableRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{47}
}
func (m *TargetTableRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetTableRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetTableRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetTableRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetTableRsp.Merge(m, src)
}
func (m *TargetTableRsp) XXX_Size() int {
	return m.Size()
}
func (m *TargetTableRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetTableRsp.DiscardUnknown(m)
}

var xxx_messageInfo_TargetTableRsp proto.InternalMessageInfo

type TableUserDetail struct {
	UserID               int64    `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID" form:"UserID"`
	Hunt                 int64    `protobuf:"varint,2,opt,name=Hunt,proto3" json:"Hunt" form:"Hunt"`
	Bounty               int64    `protobuf:"varint,3,opt,name=Bounty,proto3" json:"Bounty" form:"Bounty"`
	Score                int64    `protobuf:"varint,4,opt,name=Score,proto3" json:"Score" form:"Score" `
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableUserDetail) Reset()         { *m = TableUserDetail{} }
func (m *TableUserDetail) String() string { return proto.CompactTextString(m) }
func (*TableUserDetail) ProtoMessage()    {}
func (*TableUserDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{48}
}
func (m *TableUserDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableUserDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableUserDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableUserDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableUserDetail.Merge(m, src)
}
func (m *TableUserDetail) XXX_Size() int {
	return m.Size()
}
func (m *TableUserDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_TableUserDetail.DiscardUnknown(m)
}

var xxx_messageInfo_TableUserDetail proto.InternalMessageInfo

type UserEnterReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchId              int32    `protobuf:"varint,2,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"  validate:"required"`
	ArenaId              int32    `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId"`
	UserID               int64    `protobuf:"varint,4,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserEnterReq) Reset()         { *m = UserEnterReq{} }
func (m *UserEnterReq) String() string { return proto.CompactTextString(m) }
func (*UserEnterReq) ProtoMessage()    {}
func (*UserEnterReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{49}
}
func (m *UserEnterReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserEnterReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserEnterReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserEnterReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserEnterReq.Merge(m, src)
}
func (m *UserEnterReq) XXX_Size() int {
	return m.Size()
}
func (m *UserEnterReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserEnterReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserEnterReq proto.InternalMessageInfo

type UserEnterRsp struct {
	RoomID               string   `protobuf:"bytes,1,opt,name=RoomID,proto3" json:"RoomID" form:"RoomID"`
	Round                int64    `protobuf:"varint,2,opt,name=Round,proto3" json:"Round" form:"Round"`
	Table                int64    `protobuf:"varint,3,opt,name=Table,proto3" json:"Table" form:"Table"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserEnterRsp) Reset()         { *m = UserEnterRsp{} }
func (m *UserEnterRsp) String() string { return proto.CompactTextString(m) }
func (*UserEnterRsp) ProtoMessage()    {}
func (*UserEnterRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{50}
}
func (m *UserEnterRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserEnterRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserEnterRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserEnterRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserEnterRsp.Merge(m, src)
}
func (m *UserEnterRsp) XXX_Size() int {
	return m.Size()
}
func (m *UserEnterRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserEnterRsp.DiscardUnknown(m)
}

var xxx_messageInfo_UserEnterRsp proto.InternalMessageInfo

type BlindBetReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchId              int32    `protobuf:"varint,2,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"  validate:"required"`
	ArenaId              int32    `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlindBetReq) Reset()         { *m = BlindBetReq{} }
func (m *BlindBetReq) String() string { return proto.CompactTextString(m) }
func (*BlindBetReq) ProtoMessage()    {}
func (*BlindBetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{51}
}
func (m *BlindBetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlindBetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlindBetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlindBetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlindBetReq.Merge(m, src)
}
func (m *BlindBetReq) XXX_Size() int {
	return m.Size()
}
func (m *BlindBetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BlindBetReq.DiscardUnknown(m)
}

var xxx_messageInfo_BlindBetReq proto.InternalMessageInfo

type BlindBetResp struct {
	BlindBetList         []*BetDetail `protobuf:"bytes,1,rep,name=BlindBetList,proto3" json:"BlindBetList" form:"BlindBetList"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *BlindBetResp) Reset()         { *m = BlindBetResp{} }
func (m *BlindBetResp) String() string { return proto.CompactTextString(m) }
func (*BlindBetResp) ProtoMessage()    {}
func (*BlindBetResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{52}
}
func (m *BlindBetResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlindBetResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlindBetResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlindBetResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlindBetResp.Merge(m, src)
}
func (m *BlindBetResp) XXX_Size() int {
	return m.Size()
}
func (m *BlindBetResp) XXX_DiscardUnknown() {
	xxx_messageInfo_BlindBetResp.DiscardUnknown(m)
}

var xxx_messageInfo_BlindBetResp proto.InternalMessageInfo

type RoomAllTableReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	ArenaId              int32    `protobuf:"varint,2,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId" validate:"required"`
	RoomID               string   `protobuf:"bytes,3,opt,name=RoomID,proto3" json:"RoomID" form:"RoomID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomAllTableReq) Reset()         { *m = RoomAllTableReq{} }
func (m *RoomAllTableReq) String() string { return proto.CompactTextString(m) }
func (*RoomAllTableReq) ProtoMessage()    {}
func (*RoomAllTableReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{53}
}
func (m *RoomAllTableReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomAllTableReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomAllTableReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoomAllTableReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomAllTableReq.Merge(m, src)
}
func (m *RoomAllTableReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomAllTableReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomAllTableReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomAllTableReq proto.InternalMessageInfo

type RoomAllTableResp struct {
	MatchList            []*Detail `protobuf:"bytes,2,rep,name=MatchList,proto3" json:"MatchList" form:"MatchList" `
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RoomAllTableResp) Reset()         { *m = RoomAllTableResp{} }
func (m *RoomAllTableResp) String() string { return proto.CompactTextString(m) }
func (*RoomAllTableResp) ProtoMessage()    {}
func (*RoomAllTableResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{54}
}
func (m *RoomAllTableResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomAllTableResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomAllTableResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoomAllTableResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomAllTableResp.Merge(m, src)
}
func (m *RoomAllTableResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomAllTableResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomAllTableResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomAllTableResp proto.InternalMessageInfo

type Detail struct {
	MatchId              int32          `protobuf:"varint,1,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"  validate:"required"`
	RoundList            []*RoundDetail `protobuf:"bytes,2,rep,name=RoundList,proto3" json:"RoundList" form:"RoundList" `
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Detail) Reset()         { *m = Detail{} }
func (m *Detail) String() string { return proto.CompactTextString(m) }
func (*Detail) ProtoMessage()    {}
func (*Detail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{55}
}
func (m *Detail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Detail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Detail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Detail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Detail.Merge(m, src)
}
func (m *Detail) XXX_Size() int {
	return m.Size()
}
func (m *Detail) XXX_DiscardUnknown() {
	xxx_messageInfo_Detail.DiscardUnknown(m)
}

var xxx_messageInfo_Detail proto.InternalMessageInfo

type RoundDetail struct {
	Round                int64    `protobuf:"varint,1,opt,name=Round,proto3" json:"Round" form:"Round"`
	TableList            []int64  `protobuf:"varint,2,rep,packed,name=TableList,proto3" json:"TableList" form:"TableList"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoundDetail) Reset()         { *m = RoundDetail{} }
func (m *RoundDetail) String() string { return proto.CompactTextString(m) }
func (*RoundDetail) ProtoMessage()    {}
func (*RoundDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{56}
}
func (m *RoundDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoundDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoundDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoundDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundDetail.Merge(m, src)
}
func (m *RoundDetail) XXX_Size() int {
	return m.Size()
}
func (m *RoundDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RoundDetail proto.InternalMessageInfo

type UserSelfRankReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchId              int32    `protobuf:"varint,2,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"  validate:"required"`
	ArenaId              int32    `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId" validate:"required"`
	Round                int64    `protobuf:"varint,4,opt,name=Round,proto3" json:"Round" form:"Round" validate:"required"`
	UserID               int64    `protobuf:"varint,5,opt,name=UserID,proto3" json:"UserID" form:"UserID" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserSelfRankReq) Reset()         { *m = UserSelfRankReq{} }
func (m *UserSelfRankReq) String() string { return proto.CompactTextString(m) }
func (*UserSelfRankReq) ProtoMessage()    {}
func (*UserSelfRankReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{57}
}
func (m *UserSelfRankReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserSelfRankReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserSelfRankReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserSelfRankReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSelfRankReq.Merge(m, src)
}
func (m *UserSelfRankReq) XXX_Size() int {
	return m.Size()
}
func (m *UserSelfRankReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSelfRankReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserSelfRankReq proto.InternalMessageInfo

type UserSelfRankResp struct {
	TotalNum             int64    `protobuf:"varint,1,opt,name=TotalNum,proto3" json:"TotalNum" form:"TotalNum"`
	SelfRank             int64    `protobuf:"varint,2,opt,name=SelfRank,proto3" json:"SelfRank" form:"SelfRank"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserSelfRankResp) Reset()         { *m = UserSelfRankResp{} }
func (m *UserSelfRankResp) String() string { return proto.CompactTextString(m) }
func (*UserSelfRankResp) ProtoMessage()    {}
func (*UserSelfRankResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{58}
}
func (m *UserSelfRankResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserSelfRankResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserSelfRankResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserSelfRankResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSelfRankResp.Merge(m, src)
}
func (m *UserSelfRankResp) XXX_Size() int {
	return m.Size()
}
func (m *UserSelfRankResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSelfRankResp.DiscardUnknown(m)
}

var xxx_messageInfo_UserSelfRankResp proto.InternalMessageInfo

type ReDistributeReq struct {
	GameID               int32              `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID" form:"GameID" validate:"required"`
	MatchId              int32              `protobuf:"varint,2,opt,name=MatchId,proto3" json:"MatchId" form:"MatchId"  validate:"required"`
	ArenaId              int32              `protobuf:"varint,3,opt,name=ArenaId,proto3" json:"ArenaId" form:"ArenaId"`
	Round                int64              `protobuf:"varint,4,opt,name=Round,proto3" json:"Round" form:"Round" validate:"required"`
	RoomList             []*RoomTableDetail `protobuf:"bytes,5,rep,name=RoomList,proto3" json:"RoomList" form:"RoomList"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ReDistributeReq) Reset()         { *m = ReDistributeReq{} }
func (m *ReDistributeReq) String() string { return proto.CompactTextString(m) }
func (*ReDistributeReq) ProtoMessage()    {}
func (*ReDistributeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{59}
}
func (m *ReDistributeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReDistributeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReDistributeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReDistributeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReDistributeReq.Merge(m, src)
}
func (m *ReDistributeReq) XXX_Size() int {
	return m.Size()
}
func (m *ReDistributeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReDistributeReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReDistributeReq proto.InternalMessageInfo

type RoomTableDetail struct {
	Room                 string   `protobuf:"bytes,1,opt,name=Room,proto3" json:"Room" form:"Room"`
	TableList            []int64  `protobuf:"varint,2,rep,packed,name=TableList,proto3" json:"TableList" form:"TableList"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomTableDetail) Reset()         { *m = RoomTableDetail{} }
func (m *RoomTableDetail) String() string { return proto.CompactTextString(m) }
func (*RoomTableDetail) ProtoMessage()    {}
func (*RoomTableDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{60}
}
func (m *RoomTableDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomTableDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomTableDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoomTableDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomTableDetail.Merge(m, src)
}
func (m *RoomTableDetail) XXX_Size() int {
	return m.Size()
}
func (m *RoomTableDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomTableDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RoomTableDetail proto.InternalMessageInfo

type ReDistributeResp struct {
	UserTableInfo        []*UserTableDetail `protobuf:"bytes,5,rep,name=UserTableInfo,proto3" json:"UserTableInfo" form:"UserTableInfo"  validate:"required"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ReDistributeResp) Reset()         { *m = ReDistributeResp{} }
func (m *ReDistributeResp) String() string { return proto.CompactTextString(m) }
func (*ReDistributeResp) ProtoMessage()    {}
func (*ReDistributeResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{61}
}
func (m *ReDistributeResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReDistributeResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReDistributeResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReDistributeResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReDistributeResp.Merge(m, src)
}
func (m *ReDistributeResp) XXX_Size() int {
	return m.Size()
}
func (m *ReDistributeResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReDistributeResp.DiscardUnknown(m)
}

var xxx_messageInfo_ReDistributeResp proto.InternalMessageInfo

type HelloReq struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" form:"name" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HelloReq) Reset()         { *m = HelloReq{} }
func (m *HelloReq) String() string { return proto.CompactTextString(m) }
func (*HelloReq) ProtoMessage()    {}
func (*HelloReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{62}
}
func (m *HelloReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HelloReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HelloReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HelloReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HelloReq.Merge(m, src)
}
func (m *HelloReq) XXX_Size() int {
	return m.Size()
}
func (m *HelloReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HelloReq.DiscardUnknown(m)
}

var xxx_messageInfo_HelloReq proto.InternalMessageInfo

type HelloResp struct {
	Content              string   `protobuf:"bytes,1,opt,name=Content,proto3" json:"content"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HelloResp) Reset()         { *m = HelloResp{} }
func (m *HelloResp) String() string { return proto.CompactTextString(m) }
func (*HelloResp) ProtoMessage()    {}
func (*HelloResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{63}
}
func (m *HelloResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HelloResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HelloResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HelloResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HelloResp.Merge(m, src)
}
func (m *HelloResp) XXX_Size() int {
	return m.Size()
}
func (m *HelloResp) XXX_DiscardUnknown() {
	xxx_messageInfo_HelloResp.DiscardUnknown(m)
}

var xxx_messageInfo_HelloResp proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("elimination.service.v1.PayTypeCode", PayTypeCode_name, PayTypeCode_value)
	proto.RegisterEnum("elimination.service.v1.MatchStatusCode", MatchStatusCode_name, MatchStatusCode_value)
	proto.RegisterEnum("elimination.service.v1.IdentifyErrCode", IdentifyErrCode_name, IdentifyErrCode_value)
	proto.RegisterType((*ListReq)(nil), "elimination.service.v1.ListReq")
	proto.RegisterType((*ListRsp)(nil), "elimination.service.v1.ListRsp")
	proto.RegisterType((*MatchDetail)(nil), "elimination.service.v1.MatchDetail")
	proto.RegisterType((*TimeDetail)(nil), "elimination.service.v1.TimeDetail")
	proto.RegisterType((*SignPayDetail)(nil), "elimination.service.v1.SignPayDetail")
	proto.RegisterType((*ShowPayDetail)(nil), "elimination.service.v1.ShowPayDetail")
	proto.RegisterType((*SignDetail)(nil), "elimination.service.v1.SignDetail")
	proto.RegisterType((*DateDetail)(nil), "elimination.service.v1.DateDetail")
	proto.RegisterType((*DetailReq)(nil), "elimination.service.v1.DetailReq")
	proto.RegisterType((*DetailRsp)(nil), "elimination.service.v1.DetailRsp")
	proto.RegisterType((*BlindBetDetail)(nil), "elimination.service.v1.BlindBetDetail")
	proto.RegisterType((*BetDetail)(nil), "elimination.service.v1.BetDetail")
	proto.RegisterType((*BoardDetail)(nil), "elimination.service.v1.BoardDetail")
	proto.RegisterType((*RewardInfoReq)(nil), "elimination.service.v1.RewardInfoReq")
	proto.RegisterType((*RewardInfoRsp)(nil), "elimination.service.v1.RewardInfoRsp")
	proto.RegisterType((*RewardInfoDetail)(nil), "elimination.service.v1.RewardInfoDetail")
	proto.RegisterType((*RewardThingsDetail)(nil), "elimination.service.v1.RewardThingsDetail")
	proto.RegisterType((*RewardDetail)(nil), "elimination.service.v1.RewardDetail")
	proto.RegisterType((*UserInfoReq)(nil), "elimination.service.v1.UserInfoReq")
	proto.RegisterType((*UserInfoRsp)(nil), "elimination.service.v1.UserInfoRsp")
	proto.RegisterType((*UserDetail)(nil), "elimination.service.v1.UserDetail")
	proto.RegisterType((*TableInfoReq)(nil), "elimination.service.v1.TableInfoReq")
	proto.RegisterType((*TableInfoRsp)(nil), "elimination.service.v1.TableInfoRsp")
	proto.RegisterType((*TableDetail)(nil), "elimination.service.v1.TableDetail")
	proto.RegisterType((*UserRecordReq)(nil), "elimination.service.v1.UserRecordReq")
	proto.RegisterType((*UserRecordRsp)(nil), "elimination.service.v1.UserRecordRsp")
	proto.RegisterType((*MatchInfo)(nil), "elimination.service.v1.MatchInfo")
	proto.RegisterType((*EndMatchInfo)(nil), "elimination.service.v1.EndMatchInfo")
	proto.RegisterType((*SignCheckReq)(nil), "elimination.service.v1.SignCheckReq")
	proto.RegisterType((*SignCheckRsp)(nil), "elimination.service.v1.SignCheckRsp")
	proto.RegisterType((*SignCommonReq)(nil), "elimination.service.v1.SignCommonReq")
	proto.RegisterType((*SignEnsureRsp)(nil), "elimination.service.v1.SignEnsureRsp")
	proto.RegisterType((*SignInfo)(nil), "elimination.service.v1.SignInfo")
	proto.RegisterType((*UserTableDetail)(nil), "elimination.service.v1.UserTableDetail")
	proto.RegisterType((*CancelSignRsp)(nil), "elimination.service.v1.CancelSignRsp")
	proto.RegisterType((*UploadReq)(nil), "elimination.service.v1.UploadReq")
	proto.RegisterType((*UserInfo)(nil), "elimination.service.v1.UserInfo")
	proto.RegisterType((*UploadRsp)(nil), "elimination.service.v1.UploadRsp")
	proto.RegisterType((*OutDetail)(nil), "elimination.service.v1.OutDetail")
	proto.RegisterType((*QueryRewardReq)(nil), "elimination.service.v1.QueryRewardReq")
	proto.RegisterType((*QueryRewardRsp)(nil), "elimination.service.v1.QueryRewardRsp")
	proto.RegisterType((*QueryRewardDetail)(nil), "elimination.service.v1.QueryRewardDetail")
	proto.RegisterType((*ThingsDetail)(nil), "elimination.service.v1.ThingsDetail")
	proto.RegisterType((*ShowThingsDetail)(nil), "elimination.service.v1.ShowThingsDetail")
	proto.RegisterType((*GetRewardReq)(nil), "elimination.service.v1.GetRewardReq")
	proto.RegisterType((*GetRewardRsp)(nil), "elimination.service.v1.GetRewardRsp")
	proto.RegisterType((*TargetTableReq)(nil), "elimination.service.v1.TargetTableReq")
	proto.RegisterType((*TargetTableRsp)(nil), "elimination.service.v1.TargetTableRsp")
	proto.RegisterType((*TableUserDetail)(nil), "elimination.service.v1.TableUserDetail")
	proto.RegisterType((*UserEnterReq)(nil), "elimination.service.v1.UserEnterReq")
	proto.RegisterType((*UserEnterRsp)(nil), "elimination.service.v1.UserEnterRsp")
	proto.RegisterType((*BlindBetReq)(nil), "elimination.service.v1.BlindBetReq")
	proto.RegisterType((*BlindBetResp)(nil), "elimination.service.v1.BlindBetResp")
	proto.RegisterType((*RoomAllTableReq)(nil), "elimination.service.v1.RoomAllTableReq")
	proto.RegisterType((*RoomAllTableResp)(nil), "elimination.service.v1.RoomAllTableResp")
	proto.RegisterType((*Detail)(nil), "elimination.service.v1.Detail")
	proto.RegisterType((*RoundDetail)(nil), "elimination.service.v1.RoundDetail")
	proto.RegisterType((*UserSelfRankReq)(nil), "elimination.service.v1.UserSelfRankReq")
	proto.RegisterType((*UserSelfRankResp)(nil), "elimination.service.v1.UserSelfRankResp")
	proto.RegisterType((*ReDistributeReq)(nil), "elimination.service.v1.ReDistributeReq")
	proto.RegisterType((*RoomTableDetail)(nil), "elimination.service.v1.RoomTableDetail")
	proto.RegisterType((*ReDistributeResp)(nil), "elimination.service.v1.ReDistributeResp")
	proto.RegisterType((*HelloReq)(nil), "elimination.service.v1.HelloReq")
	proto.RegisterType((*HelloResp)(nil), "elimination.service.v1.HelloResp")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 5062 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5c, 0x6b, 0x8c, 0x5b, 0xc7,
	0x75, 0xf6, 0xe5, 0x6b, 0xc9, 0x21, 0x77, 0x97, 0x1a, 0x39, 0x32, 0xb5, 0xb2, 0x45, 0x6a, 0x24,
	0x4b, 0xb2, 0xe4, 0xec, 0x3a, 0xb2, 0xd1, 0x18, 0x91, 0x51, 0xd7, 0xfb, 0xf0, 0x7a, 0x61, 0x8b,
	0xbb, 0xbd, 0x94, 0x11, 0xd7, 0x68, 0x50, 0x5f, 0x89, 0xa3, 0xf5, 0x85, 0xc9, 0x7b, 0x69, 0xde,
	0xcb, 0xb5, 0xb6, 0xaf, 0xc4, 0x4e, 0xd3, 0xa4, 0xae, 0xd3, 0xa4, 0x71, 0x9d, 0x38, 0x4d, 0x1f,
	0xa8, 0x81, 0xf4, 0x81, 0xfe, 0xe9, 0x8f, 0xfe, 0x2d, 0x50, 0x14, 0x2d, 0x90, 0x1f, 0xfd, 0x91,
	0x36, 0x45, 0x81, 0x06, 0x28, 0x51, 0xbb, 0xfd, 0x11, 0x2c, 0x5a, 0xa0, 0x5d, 0xf4, 0xfd, 0xc6,
	0x39, 0x33, 0x73, 0x67, 0xee, 0x5d, 0x92, 0xcb, 0x7d, 0x15, 0xaa, 0xa1, 0x5f, 0x7b, 0xe7, 0x9b,
	0xc7, 0x39, 0x33, 0x73, 0xce, 0x99, 0x73, 0xce, 0x0c, 0x97, 0x14, 0x9c, 0x8e, 0x3b, 0xdb, 0xe9,
	0xfa, 0xa1, 0x4f, 0x4f, 0xf0, 0x96, 0xdb, 0x76, 0x3d, 0x27, 0x74, 0x7d, 0x6f, 0x36, 0xe0, 0xdd,
	0x0d, 0xf7, 0x26, 0x9f, 0xdd, 0xf8, 0xd8, 0xcc, 0x47, 0xd7, 0xdd, 0xf0, 0xe5, 0xde, 0x8d, 0xd9,
	0x9b, 0x7e, 0x7b, 0x6e, 0xdd, 0x5f, 0xf7, 0xe7, 0xb0, 0xf9, 0x8d, 0xde, 0x2d, 0x2c, 0x61, 0x01,
	0xbf, 0xc4, 0x30, 0x33, 0xa7, 0xd6, 0x7d, 0x7f, 0xbd, 0xc5, 0x75, 0x2b, 0xde, 0xee, 0x84, 0x9b,
	0xb2, 0xf2, 0x7e, 0x59, 0xe9, 0x74, 0xdc, 0x39, 0xc7, 0xf3, 0xfc, 0x10, 0xa9, 0x05, 0xa2, 0x96,
	0x7d, 0xc3, 0x22, 0x13, 0xcf, 0xb9, 0x41, 0x68, 0xf3, 0x57, 0xe9, 0x32, 0xc9, 0x2d, 0x3b, 0x6d,
	0xbe, 0xb2, 0x58, 0xb1, 0x6a, 0xd6, 0xc5, 0xec, 0xfc, 0xdc, 0x56, 0xbf, 0x2a, 0x91, 0xed, 0x7e,
	0xf5, 0xcc, 0x2d, 0xbf, 0xdb, 0xfe, 0x04, 0x13, 0x65, 0x56, 0xdb, 0x70, 0x5a, 0x6e, 0xd3, 0x09,
	0xf9, 0x27, 0x58, 0x97, 0xbf, 0xda, 0x73, 0xbb, 0xbc, 0xc9, 0x6c, 0xd9, 0x18, 0x06, 0x7a, 0x3e,
	0xe0, 0xdd, 0x95, 0xc5, 0x4a, 0xaa, 0x66, 0x5d, 0x4c, 0x8b, 0x81, 0x04, 0xa2, 0x07, 0x12, 0xe5,
	0x21, 0x03, 0xc9, 0xca, 0x8e, 0x64, 0x2e, 0xe8, 0x50, 0x4e, 0x0a, 0xd7, 0x9c, 0xf0, 0xe6, 0xcb,
	0x50, 0xae, 0x58, 0xb5, 0xf4, 0xc5, 0xe2, 0x95, 0xb3, 0xb3, 0x83, 0x97, 0x6f, 0x16, 0x1b, 0x2e,
	0xf2, 0xd0, 0x71, 0x5b, 0xf3, 0x6c, 0xab, 0x5f, 0xd5, 0x3d, 0xb7, 0xfb, 0xd5, 0x63, 0x82, 0x7c,
	0x04, 0xb1, 0x9a, 0xad, 0xeb, 0xd9, 0xbb, 0x79, 0x52, 0x34, 0xba, 0xd3, 0x87, 0x49, 0xa6, 0xee,
	0xb4, 0x39, 0xae, 0x48, 0x61, 0xbe, 0xb2, 0xd5, 0xaf, 0x62, 0x79, 0xbb, 0x5f, 0x2d, 0x89, 0x71,
	0x3c, 0xa7, 0xcd, 0x59, 0xcd, 0x46, 0x94, 0x9e, 0x25, 0x29, 0x39, 0xe9, 0xec, 0xfc, 0xf1, 0xad,
	0x7e, 0x35, 0x85, 0x13, 0x2e, 0x88, 0x96, 0x2b, 0x8b, 0xcc, 0x4e, 0xad, 0x2c, 0xd2, 0x47, 0x49,
	0xee, 0xfa, 0x66, 0x07, 0x96, 0x39, 0x8d, 0x0d, 0x4f, 0xc1, 0xea, 0x08, 0x64, 0xbb, 0x5f, 0x9d,
	0x14, 0x8d, 0x45, 0x99, 0xd9, 0xb2, 0x82, 0x3e, 0x4e, 0x26, 0x9e, 0xea, 0x72, 0xcf, 0x59, 0x69,
	0x56, 0x32, 0xd8, 0xeb, 0xf4, 0x56, 0xbf, 0x2a, 0x21, 0xe8, 0x36, 0x2d, 0xba, 0xc9, 0x36, 0xac,
	0x66, 0xab, 0xe6, 0x74, 0x81, 0x90, 0xe7, 0xdc, 0xb6, 0x1b, 0x5e, 0x77, 0xdb, 0x3c, 0xa8, 0x64,
	0xb1, 0xf3, 0xd9, 0xad, 0x7e, 0xd5, 0x40, 0xf5, 0xaa, 0x68, 0x8c, 0xd9, 0x46, 0x03, 0xfa, 0x08,
	0xc9, 0xae, 0x76, 0x9b, 0xbc, 0x5b, 0xc9, 0x61, 0xff, 0x99, 0xad, 0x7e, 0x55, 0x00, 0x9a, 0x63,
	0x2c, 0xb2, 0x9a, 0x2d, 0x70, 0xea, 0x93, 0x62, 0xe3, 0x65, 0xff, 0xb5, 0x86, 0xeb, 0xad, 0xaf,
	0x39, 0x9b, 0x95, 0x89, 0x9a, 0x75, 0xb1, 0x78, 0xe5, 0xc1, 0x61, 0x3b, 0x06, 0x4d, 0xd7, 0x9c,
	0x4d, 0xb9, 0x67, 0xe7, 0xb7, 0xfa, 0x55, 0xb3, 0xf7, 0x76, 0xbf, 0x7a, 0x5c, 0x10, 0x31, 0x40,
	0x56, 0xb3, 0xcd, 0x36, 0x74, 0x83, 0x4c, 0x36, 0xdc, 0x75, 0x6f, 0xc1, 0xf7, 0x9a, 0x2e, 0x0c,
	0x5f, 0xc9, 0xa3, 0x90, 0x9c, 0x1b, 0x46, 0xf2, 0xfa, 0xcb, 0xae, 0xb7, 0x1e, 0x48, 0x8a, 0x97,
	0xb6, 0xfa, 0xd5, 0x78, 0xf7, 0xed, 0x7e, 0xf5, 0x23, 0x92, 0xa6, 0x09, 0xb3, 0x9a, 0x1d, 0x6f,
	0x47, 0x5f, 0x20, 0xb9, 0x86, 0xbb, 0x5e, 0xef, 0xb5, 0x2b, 0x05, 0x9c, 0x23, 0x1b, 0x3a, 0x47,
	0x77, 0xdd, 0x93, 0xe4, 0xee, 0x87, 0x2d, 0x17, 0xbd, 0xb6, 0xfb, 0xd5, 0xa9, 0x88, 0x4e, 0xbd,
	0xd7, 0x66, 0x35, 0x5b, 0xd6, 0xd0, 0x4f, 0x91, 0x5c, 0x23, 0x74, 0xc2, 0x5e, 0x50, 0x21, 0x35,
	0xeb, 0xe2, 0xd4, 0x95, 0x0b, 0x23, 0xe5, 0x5d, 0x34, 0x5d, 0xf0, 0x9b, 0x5c, 0x0e, 0x8f, 0x65,
	0x63, 0x78, 0x2c, 0xe3, 0xf0, 0xf8, 0x45, 0xd7, 0x48, 0x66, 0xd1, 0x09, 0x79, 0xa5, 0x38, 0x9a,
	0x6d, 0x68, 0x23, 0xd9, 0x46, 0xf1, 0x87, 0xb2, 0x16, 0x7f, 0x28, 0x81, 0xf8, 0xc3, 0x5f, 0xfa,
	0x04, 0xc9, 0xd7, 0xfd, 0xd7, 0x6c, 0xbf, 0xe7, 0x35, 0x2b, 0x25, 0xd4, 0xfc, 0xda, 0x56, 0xbf,
	0x1a, 0x61, 0xdb, 0xfd, 0x6a, 0x59, 0xf4, 0x52, 0x08, 0xab, 0xd9, 0x51, 0x2d, 0xf0, 0x03, 0xc2,
	0x56, 0x99, 0x1c, 0xcd, 0x0f, 0xb4, 0x31, 0xf9, 0x81, 0xb2, 0xe6, 0x07, 0x4a, 0xc0, 0x0f, 0xfc,
	0xa5, 0xcf, 0x91, 0xd2, 0xbc, 0xef, 0xf5, 0x82, 0x35, 0xdf, 0x6f, 0xc1, 0x06, 0x4d, 0x21, 0x4f,
	0x17, 0xb7, 0xfa, 0xd5, 0x18, 0xbe, 0xdd, 0xaf, 0xde, 0x2b, 0x7a, 0x9b, 0x28, 0xab, 0xd9, 0xb1,
	0x56, 0xec, 0x0b, 0x16, 0x21, 0x9a, 0x38, 0xfd, 0x01, 0x52, 0x98, 0xe7, 0xeb, 0xae, 0x87, 0x3c,
	0x0b, 0xf3, 0x80, 0xb6, 0x26, 0x02, 0xb5, 0x56, 0x45, 0x10, 0xd8, 0x9a, 0xa8, 0x00, 0x3a, 0xbd,
	0xe4, 0x35, 0xb1, 0x7f, 0x0a, 0xfb, 0xa3, 0x4e, 0x4b, 0x48, 0xeb, 0xb4, 0x04, 0x40, 0xa7, 0xd5,
	0xe7, 0x37, 0x2d, 0x21, 0xec, 0x91, 0xca, 0xd0, 0x45, 0x42, 0x50, 0x0a, 0x84, 0x96, 0x0b, 0xfb,
	0x7d, 0x0e, 0xb4, 0x5c, 0xa3, 0xdb, 0xfd, 0x2a, 0x35, 0x6c, 0x9f, 0xd0, 0xf2, 0x9a, 0x6d, 0xb4,
	0xa0, 0x75, 0x92, 0x06, 0x65, 0x4d, 0xed, 0x41, 0x73, 0x4e, 0x6c, 0xf5, 0xab, 0x69, 0xa1, 0xa3,
	0x45, 0x31, 0xba, 0xd0, 0x4d, 0xc0, 0xd8, 0x6f, 0x01, 0x9f, 0xa6, 0x6a, 0x1f, 0x12, 0x9f, 0xb6,
	0xc9, 0xe7, 0xc5, 0x51, 0x46, 0x65, 0x7c, 0x5e, 0x3d, 0x42, 0xb4, 0x86, 0xd2, 0x39, 0x92, 0xbd,
	0xee, 0x87, 0x4e, 0x4b, 0xb2, 0x78, 0x12, 0x0c, 0x1e, 0x02, 0x86, 0xa8, 0x41, 0x91, 0xd9, 0x02,
	0xa6, 0x73, 0x24, 0x0d, 0x22, 0x26, 0x6c, 0xff, 0x03, 0xb0, 0x91, 0x30, 0x5a, 0x52, 0xc1, 0x01,
	0x60, 0x36, 0xb4, 0x64, 0x1b, 0x84, 0x68, 0xd5, 0xa2, 0x57, 0x49, 0x7e, 0xad, 0xeb, 0x77, 0x78,
	0x37, 0xdc, 0x94, 0xc2, 0x54, 0x05, 0xd5, 0x51, 0x98, 0x96, 0x06, 0x85, 0x30, 0x3b, 0xaa, 0xa4,
	0x97, 0x49, 0xe6, 0x93, 0x9c, 0xbf, 0x82, 0xeb, 0x91, 0x9d, 0xbf, 0x0f, 0xb4, 0x02, 0xca, 0x7a,
	0x9a, 0x50, 0x62, 0x36, 0x82, 0xec, 0x2f, 0x52, 0xa4, 0x20, 0x88, 0x1e, 0xea, 0x99, 0xff, 0x71,
	0x32, 0x81, 0x1b, 0xb4, 0xd2, 0x34, 0xd7, 0x40, 0x42, 0x7a, 0x0d, 0x24, 0xc0, 0x6c, 0x55, 0x05,
	0x1d, 0xd5, 0xc9, 0x96, 0xd6, 0x1d, 0x25, 0xa4, 0x3b, 0xaa, 0x93, 0x4d, 0x1f, 0x6c, 0xcf, 0x90,
	0x22, 0x48, 0x43, 0xfc, 0x58, 0xc4, 0xa3, 0xc3, 0x80, 0xf5, 0xd1, 0x61, 0x80, 0x70, 0x74, 0x18,
	0x45, 0xc3, 0x5f, 0xc9, 0x1e, 0xcc, 0x5f, 0xf9, 0xbb, 0x42, 0xb4, 0xb6, 0x41, 0xe7, 0x28, 0x7c,
	0x87, 0x27, 0x48, 0x7e, 0xbe, 0xb7, 0x89, 0x07, 0xb3, 0x5c, 0x2d, 0xb4, 0xb0, 0x0a, 0xd3, 0x16,
	0x56, 0x21, 0x60, 0x61, 0xd5, 0x37, 0x98, 0x2c, 0x90, 0x41, 0xd1, 0x5d, 0xac, 0x17, 0x9a, 0xac,
	0x08, 0xd4, 0x26, 0x2b, 0x82, 0xc0, 0x64, 0x45, 0x05, 0xba, 0x4a, 0x26, 0x97, 0xbc, 0x90, 0x77,
	0x17, 0xb9, 0xd3, 0x6c, 0xb9, 0x1e, 0xc7, 0x05, 0x2b, 0xcc, 0x3f, 0x04, 0xc7, 0x67, 0xac, 0x42,
	0xdb, 0xd4, 0x18, 0xcc, 0xec, 0x78, 0x33, 0xda, 0x94, 0x6e, 0x1d, 0x5a, 0xc1, 0xdc, 0xd8, 0x96,
	0x5f, 0x7b, 0x75, 0x71, 0x4b, 0x1b, 0x41, 0x91, 0x57, 0x87, 0x96, 0xf6, 0xae, 0x33, 0x72, 0x60,
	0x67, 0xa4, 0x49, 0xf2, 0xf3, 0x2d, 0xd7, 0x6b, 0xce, 0xf3, 0x10, 0xdd, 0x91, 0xe2, 0x95, 0xf3,
	0xc3, 0xc6, 0x56, 0xed, 0xe4, 0xf8, 0x42, 0x42, 0x25, 0x66, 0x48, 0xa8, 0x44, 0x50, 0x42, 0xe5,
	0x37, 0x75, 0x09, 0x69, 0xdc, 0xf4, 0xbb, 0xfc, 0x86, 0xef, 0x74, 0x9b, 0xd2, 0x33, 0x19, 0xea,
	0xe6, 0xcf, 0x43, 0x23, 0x49, 0x04, 0xcf, 0x10, 0xdd, 0x55, 0x9f, 0x21, 0x1a, 0x83, 0x33, 0x44,
	0x97, 0xe8, 0x75, 0x32, 0xb5, 0xe2, 0xb9, 0x21, 0x22, 0x38, 0x92, 0x74, 0x59, 0x1e, 0xde, 0xea,
	0x57, 0x75, 0x8d, 0x1a, 0xed, 0x84, 0xd4, 0xc3, 0x18, 0xce, 0x6a, 0x76, 0x62, 0x8c, 0x98, 0x0b,
	0x34, 0xb9, 0x67, 0x17, 0x48, 0x7b, 0x7c, 0x53, 0x47, 0xe1, 0xf1, 0xad, 0x92, 0x49, 0x11, 0xdb,
	0xf4, 0xba, 0x38, 0x62, 0x65, 0x1a, 0x39, 0x44, 0xed, 0x8d, 0x55, 0x68, 0xed, 0x8d, 0xc1, 0xcc,
	0x8e, 0x37, 0x63, 0x5f, 0x4a, 0x91, 0xa9, 0xf8, 0x6e, 0xd3, 0x4f, 0x92, 0x5c, 0xdd, 0x7f, 0x0d,
	0xa4, 0xc4, 0xc2, 0xdd, 0x3b, 0x33, 0x74, 0xf7, 0x22, 0x01, 0x41, 0xe6, 0x45, 0x27, 0xcd, 0xbc,
	0x28, 0x03, 0xf3, 0xe2, 0x8b, 0xbe, 0x48, 0x26, 0xea, 0xfc, 0x76, 0x08, 0x23, 0xa7, 0xc6, 0x1d,
	0x19, 0x8f, 0x12, 0xd9, 0xcb, 0x18, 0x5a, 0x00, 0xcc, 0x56, 0x55, 0x70, 0x94, 0xd8, 0x6e, 0xc0,
	0xe7, 0x39, 0x86, 0x3b, 0x68, 0x59, 0xd3, 0x42, 0xf1, 0x0d, 0x58, 0x2b, 0xbe, 0x01, 0x82, 0xe2,
	0x9b, 0xc5, 0x3f, 0x4b, 0x81, 0x5b, 0xa8, 0x16, 0x03, 0xcc, 0x35, 0x0f, 0x9f, 0xe3, 0x1b, 0x5c,
	0x39, 0x12, 0x42, 0x19, 0x24, 0x66, 0x28, 0x83, 0x44, 0x50, 0x19, 0xe4, 0x37, 0x04, 0x8a, 0xd7,
	0x9c, 0xdb, 0x6a, 0xc2, 0x69, 0x11, 0x28, 0x0a, 0x44, 0x87, 0x5d, 0xa2, 0xcc, 0x6c, 0x59, 0x41,
	0x1f, 0x23, 0xb9, 0x6b, 0xae, 0x07, 0x9d, 0xc4, 0x2c, 0x70, 0x71, 0x05, 0x62, 0x9c, 0xc2, 0x58,
	0x86, 0xc5, 0x15, 0x5f, 0xc0, 0xe8, 0xd3, 0x5d, 0xdf, 0xc3, 0xd5, 0xcd, 0x68, 0xb1, 0x55, 0x98,
	0x66, 0x54, 0x21, 0xc0, 0xa8, 0xfa, 0xa6, 0x2f, 0x91, 0x63, 0x28, 0x05, 0xb0, 0x02, 0x2b, 0x60,
	0xde, 0x37, 0x9c, 0x96, 0x3c, 0x4a, 0xaf, 0x6c, 0xf5, 0xab, 0x3b, 0x2b, 0xb7, 0xfb, 0xd5, 0x93,
	0x86, 0x15, 0x30, 0xab, 0x58, 0xcd, 0xde, 0xd9, 0x9e, 0xfd, 0xb9, 0x45, 0x8a, 0x86, 0xba, 0x83,
	0xbb, 0x74, 0xcd, 0xb9, 0x8d, 0x7a, 0x87, 0x0b, 0x9b, 0x16, 0xee, 0x92, 0xc2, 0xb4, 0xbb, 0xa4,
	0x10, 0x66, 0x47, 0x95, 0x30, 0xd9, 0x6b, 0xae, 0x27, 0x3a, 0xa7, 0xf4, 0x64, 0x15, 0xa6, 0x27,
	0xab, 0x10, 0x98, 0xac, 0xfa, 0x86, 0xa0, 0xe2, 0xa9, 0x0d, 0xde, 0x75, 0xd6, 0xb9, 0x18, 0x01,
	0x96, 0x39, 0x25, 0x82, 0x0a, 0x13, 0xd7, 0x2a, 0x64, 0xa2, 0x10, 0x54, 0xc4, 0xca, 0x7f, 0x94,
	0x22, 0x93, 0x36, 0x7f, 0xcd, 0xe9, 0x36, 0x57, 0xbc, 0x5b, 0xfe, 0xff, 0x73, 0x8f, 0xec, 0x11,
	0x92, 0x15, 0x96, 0x4f, 0x88, 0x10, 0x66, 0x09, 0x94, 0xd9, 0x93, 0xe2, 0xaa, 0x6c, 0x9e, 0xc0,
	0x0f, 0xcf, 0xf3, 0xfa, 0x6e, 0x7c, 0x1d, 0x83, 0x0e, 0x5d, 0x20, 0x44, 0x00, 0x10, 0xbf, 0x49,
	0x21, 0xc1, 0xbc, 0x87, 0x46, 0xb5, 0xdf, 0xa0, 0x31, 0x66, 0x1b, 0x0d, 0xe8, 0x93, 0xa4, 0xb0,
	0xc6, 0xbb, 0x81, 0xef, 0x29, 0xdf, 0x3e, 0x3d, 0x7f, 0x06, 0x5c, 0x8f, 0x08, 0xd4, 0xc2, 0x12,
	0x41, 0xcc, 0xd6, 0xd5, 0xb4, 0x41, 0xa6, 0x30, 0x3e, 0x10, 0x63, 0xc2, 0x28, 0x42, 0x2d, 0x2f,
	0xc3, 0x29, 0x13, 0xaf, 0xd1, 0x87, 0x7c, 0x1c, 0x67, 0x76, 0xa2, 0x21, 0xf5, 0xd4, 0xd4, 0x30,
	0x19, 0x96, 0x19, 0x1d, 0x05, 0xe9, 0x55, 0x31, 0x8f, 0x4a, 0xdd, 0x5f, 0x1f, 0x95, 0x1a, 0x83,
	0xa3, 0xd2, 0x28, 0xfd, 0x8e, 0x45, 0xca, 0xc9, 0x61, 0x20, 0xe8, 0xb0, 0x1d, 0xef, 0x15, 0xcc,
	0xc5, 0xa5, 0x45, 0xd0, 0x01, 0x65, 0x1d, 0x74, 0x40, 0x89, 0xd9, 0x08, 0x52, 0x3f, 0xc6, 0xb1,
	0x88, 0xdb, 0x2e, 0x8d, 0xe6, 0x38, 0xe6, 0x12, 0x9d, 0xdd, 0xc1, 0xf3, 0xb1, 0x1d, 0x3c, 0xc7,
	0x58, 0xfe, 0xb2, 0x45, 0xe8, 0xce, 0x71, 0xe8, 0x39, 0x74, 0xb2, 0x85, 0x62, 0xdd, 0x1b, 0x39,
	0xd9, 0x24, 0x72, 0xb2, 0x6b, 0xe8, 0x65, 0x5f, 0xd0, 0xb1, 0x5c, 0x7a, 0xfe, 0x23, 0x10, 0x34,
	0x8a, 0xed, 0x91, 0xed, 0xa2, 0x18, 0x4e, 0xac, 0x41, 0xa8, 0x6c, 0x80, 0x5c, 0x03, 0x4c, 0x8f,
	0x44, 0x6b, 0x10, 0x72, 0x5c, 0x83, 0x90, 0xb3, 0x5f, 0xb7, 0x48, 0x49, 0xb0, 0xb4, 0x9f, 0x15,
	0x74, 0x07, 0xac, 0xe0, 0x78, 0xee, 0xe4, 0x9e, 0xd7, 0xee, 0xfd, 0x0c, 0x29, 0xa2, 0x5a, 0x1d,
	0xb6, 0x45, 0x7a, 0x2e, 0x69, 0x91, 0xae, 0xc4, 0x2d, 0xd2, 0xd9, 0xb8, 0x45, 0xaa, 0x0d, 0x1c,
	0xec, 0xe0, 0x66, 0x6a, 0x79, 0x50, 0xe0, 0xf8, 0xe0, 0xce, 0xc0, 0x91, 0xee, 0x0c, 0x1c, 0xe3,
	0x71, 0xe3, 0xa2, 0xb2, 0x77, 0xc2, 0x78, 0xcd, 0x9a, 0xf6, 0xee, 0x4c, 0xcc, 0xde, 0x0d, 0x9c,
	0xc9, 0x0e, 0x1b, 0x98, 0x3b, 0x90, 0x0d, 0xa4, 0x2f, 0x10, 0x82, 0xc9, 0xa5, 0x35, 0xdf, 0xf5,
	0x42, 0x0c, 0x72, 0xb2, 0xf3, 0x8f, 0xc3, 0xe6, 0x6b, 0x74, 0xbb, 0x5f, 0x3d, 0x6f, 0xe4, 0xa4,
	0x10, 0x1b, 0xc2, 0x9d, 0xd1, 0x8b, 0xae, 0x91, 0xfc, 0x92, 0xd7, 0x14, 0xe3, 0xe6, 0x71, 0xdc,
	0xc7, 0xe0, 0xc4, 0x54, 0xd8, 0x76, 0xbf, 0x7a, 0x2e, 0xca, 0x55, 0x8d, 0x1a, 0x33, 0xea, 0xc1,
	0xfe, 0x20, 0x67, 0xc8, 0x58, 0xd0, 0x81, 0xd0, 0x14, 0xf7, 0xd5, 0x08, 0x98, 0x75, 0x8c, 0x27,
	0xa3, 0x66, 0x33, 0xc6, 0xab, 0x3b, 0x46, 0x8c, 0x87, 0xf1, 0xf3, 0x0e, 0xe7, 0x36, 0x75, 0x30,
	0xe7, 0x16, 0x0e, 0x10, 0xb4, 0xbb, 0xfa, 0x98, 0x97, 0x07, 0x88, 0x46, 0x35, 0x53, 0x1a, 0x63,
	0xb6, 0xd1, 0x80, 0x3e, 0x9b, 0xf0, 0x16, 0x32, 0x68, 0x29, 0x2e, 0x0c, 0xf0, 0x16, 0x8e, 0x0f,
	0xf0, 0x16, 0xe2, 0xce, 0x42, 0xcc, 0xeb, 0xc9, 0xee, 0xd5, 0xeb, 0xb9, 0x6a, 0x78, 0x3d, 0x39,
	0xa3, 0xb3, 0xf6, 0x7a, 0xa6, 0x13, 0x5e, 0x8f, 0xe1, 0xf4, 0x80, 0x23, 0xeb, 0x7b, 0xbd, 0x00,
	0xcc, 0xe2, 0x84, 0x76, 0x99, 0x14, 0x66, 0x38, 0xb2, 0x12, 0x41, 0x47, 0x56, 0x7e, 0x43, 0x6f,
	0x5c, 0x12, 0xe8, 0x9d, 0xd7, 0xbd, 0x15, 0xa6, 0x7b, 0x2b, 0x04, 0x7a, 0xab, 0x6f, 0x10, 0x0d,
	0x7d, 0x06, 0x17, 0xb0, 0x3b, 0x4b, 0x9e, 0xc1, 0xc7, 0x92, 0x67, 0x70, 0xcd, 0x3c, 0x84, 0x5f,
	0x22, 0xf9, 0x06, 0x6f, 0xdd, 0x02, 0x59, 0x93, 0xb1, 0xeb, 0xd0, 0xb8, 0x18, 0x64, 0xd2, 0x8c,
	0x5b, 0x55, 0x3f, 0xcd, 0xa3, 0x42, 0x80, 0x47, 0xf5, 0x4d, 0x43, 0x32, 0x09, 0x3d, 0x71, 0xb1,
	0xd0, 0x40, 0x17, 0xd1, 0x40, 0x8f, 0x43, 0x06, 0xa3, 0xfd, 0x58, 0x67, 0xed, 0x08, 0xc4, 0x60,
	0x88, 0xf6, 0xe3, 0xc0, 0xef, 0xa6, 0x08, 0xd1, 0x23, 0x81, 0xfb, 0x75, 0xdd, 0xb9, 0xd1, 0x52,
	0x1e, 0x31, 0xba, 0x5f, 0x08, 0x18, 0xd7, 0x4a, 0x50, 0x04, 0xf7, 0x0b, 0x3f, 0x20, 0xc2, 0x88,
	0x5d, 0xd4, 0x9d, 0x8a, 0x99, 0x9e, 0xc9, 0x98, 0xe9, 0x89, 0xcc, 0xcc, 0x65, 0x92, 0x79, 0xa6,
	0xe7, 0xa9, 0xf8, 0x02, 0x8f, 0x2d, 0x28, 0xeb, 0x63, 0x0b, 0x4a, 0xcc, 0x46, 0x10, 0x28, 0xcc,
	0xfb, 0x3d, 0x2f, 0xdc, 0x94, 0x3e, 0x21, 0x52, 0x10, 0x88, 0xa6, 0x20, 0xca, 0xcc, 0x96, 0x15,
	0xd1, 0xc1, 0x98, 0xd5, 0x14, 0x86, 0x1f, 0x8c, 0x8f, 0x90, 0xac, 0x29, 0xd4, 0x38, 0x6b, 0x25,
	0xd1, 0x93, 0x46, 0x0e, 0x00, 0x66, 0x2d, 0x3e, 0xde, 0x4b, 0x93, 0x12, 0xce, 0xff, 0xee, 0x01,
	0xb7, 0xcb, 0x01, 0xf7, 0x48, 0xfc, 0x80, 0xdb, 0x93, 0x43, 0x7f, 0xb0, 0xc3, 0x8c, 0xbd, 0x9b,
	0x32, 0x37, 0x29, 0xe8, 0x60, 0xd4, 0x86, 0xc6, 0xbe, 0xd7, 0x36, 0x63, 0x69, 0x85, 0x19, 0x51,
	0x9b, 0x44, 0x30, 0x6a, 0x93, 0xdf, 0xf4, 0x87, 0x49, 0xb9, 0x11, 0x3a, 0x5e, 0x13, 0x1c, 0x42,
	0x18, 0x55, 0xe7, 0xea, 0x1f, 0xd9, 0xea, 0x57, 0x77, 0xd4, 0x6d, 0xf7, 0xab, 0x95, 0x28, 0x89,
	0x12, 0xab, 0x61, 0x35, 0x7b, 0x47, 0x6b, 0xda, 0x22, 0x45, 0xfc, 0x16, 0x8a, 0x58, 0x49, 0x8f,
	0xbe, 0x9e, 0x36, 0x9a, 0xca, 0x5d, 0xd1, 0x80, 0xb1, 0x2b, 0x1a, 0x84, 0x5d, 0x31, 0x4a, 0xef,
	0xa7, 0x62, 0xe4, 0x30, 0x11, 0x2e, 0x39, 0xb9, 0xc1, 0xbb, 0x52, 0xfb, 0xcf, 0x47, 0x03, 0x0b,
	0xd8, 0x48, 0x84, 0x6b, 0x10, 0x13, 0xe1, 0xba, 0x18, 0x37, 0xb5, 0x29, 0x9d, 0x20, 0x1e, 0xdf,
	0xd4, 0x9a, 0x47, 0x54, 0xfa, 0x20, 0x47, 0x54, 0x66, 0xaf, 0x47, 0x54, 0x32, 0x2e, 0xcf, 0xea,
	0xcb, 0xbe, 0x7d, 0xc4, 0xe5, 0xbf, 0x66, 0x09, 0x8b, 0x6e, 0xf3, 0x9b, 0x7e, 0xb7, 0x79, 0x67,
	0xbe, 0x8e, 0xf8, 0x5e, 0x9c, 0xc7, 0xa0, 0x43, 0x6f, 0xee, 0x7c, 0x24, 0x71, 0x66, 0x64, 0x0a,
	0x11, 0x94, 0x6b, 0x8f, 0x4f, 0x24, 0x68, 0x97, 0x94, 0x96, 0xbc, 0xa6, 0xa6, 0xb3, 0x4b, 0x2c,
	0xa2, 0xda, 0x22, 0x29, 0xdc, 0x0e, 0xb3, 0xb7, 0x79, 0x4f, 0xd0, 0x34, 0x09, 0xc6, 0x5a, 0xb1,
	0xaf, 0x65, 0xe5, 0xcc, 0xf0, 0xb4, 0xdd, 0xf5, 0x62, 0xa5, 0x7e, 0xa7, 0x3f, 0xca, 0x48, 0x5c,
	0x48, 0x64, 0x8f, 0xfc, 0x42, 0x42, 0x5f, 0x0c, 0xe4, 0x8e, 0xec, 0x95, 0xc2, 0xc4, 0x11, 0xbd,
	0x52, 0xc0, 0x9c, 0x6c, 0xfe, 0xc8, 0x5e, 0x05, 0x14, 0x0e, 0xf4, 0x2a, 0xe0, 0xab, 0x69, 0xad,
	0x0e, 0x47, 0x25, 0x9c, 0x8f, 0x27, 0x1d, 0x81, 0xb1, 0xe5, 0xec, 0x61, 0xe9, 0x49, 0x09, 0x6b,
	0x5a, 0x31, 0x3c, 0xa9, 0x92, 0xe1, 0x49, 0xd5, 0xa4, 0x2b, 0xf5, 0x22, 0xc9, 0x89, 0x34, 0x40,
	0x25, 0xbb, 0x87, 0xfc, 0x02, 0xee, 0xa3, 0xe8, 0xa7, 0xf7, 0x51, 0x94, 0x61, 0x1f, 0xc5, 0x57,
	0x52, 0xe2, 0x73, 0x47, 0x2d, 0xf1, 0xec, 0x7b, 0x69, 0x52, 0xc2, 0xcb, 0xb1, 0x97, 0xf9, 0xcd,
	0x57, 0xee, 0x7a, 0x79, 0x23, 0xbc, 0xbc, 0xc3, 0x4a, 0xc2, 0xe2, 0xad, 0x27, 0x6f, 0xdd, 0x02,
	0xe9, 0x08, 0xf0, 0x68, 0xc8, 0xed, 0xf9, 0xd6, 0xd3, 0xec, 0x6e, 0xdc, 0x7a, 0x9a, 0x30, 0xde,
	0x7a, 0xc6, 0x80, 0xdf, 0x8f, 0x6d, 0x75, 0xd0, 0x31, 0x66, 0x64, 0x1d, 0x6c, 0x46, 0x0d, 0x32,
	0xb5, 0x12, 0x3c, 0xdd, 0x6b, 0xb5, 0xc4, 0x15, 0xab, 0xcc, 0x2a, 0xe4, 0x45, 0xfa, 0x36, 0x5e,
	0xa3, 0xb9, 0x8d, 0xe3, 0xcc, 0x4e, 0x34, 0x04, 0x2f, 0x4b, 0x20, 0xa0, 0x08, 0x69, 0x1c, 0x0f,
	0x8f, 0xe0, 0x08, 0xd4, 0x47, 0x70, 0x04, 0xc1, 0x11, 0x1c, 0x15, 0xe8, 0x8f, 0x90, 0x09, 0xf9,
	0xfc, 0x07, 0xb7, 0x7d, 0x94, 0x22, 0x99, 0xaf, 0x84, 0x84, 0xdd, 0x90, 0x90, 0xb6, 0x1b, 0x12,
	0x00, 0xbb, 0x21, 0x3f, 0xff, 0xcf, 0xcf, 0x27, 0xf6, 0x9b, 0x29, 0x75, 0x63, 0xde, 0x6e, 0xfb,
	0xde, 0x87, 0x53, 0x5d, 0x95, 0x4c, 0x66, 0x0e, 0xe6, 0xf6, 0xbd, 0x2d, 0x97, 0x6a, 0xc9, 0x0b,
	0x7a, 0x5d, 0x0e, 0xe2, 0xfe, 0x18, 0xc9, 0x09, 0xd9, 0xc0, 0xa5, 0xca, 0x0b, 0x8b, 0x2c, 0x10,
	0xcd, 0x91, 0x28, 0x83, 0x45, 0x16, 0x5f, 0x3a, 0xb8, 0x4b, 0x8d, 0x1b, 0xdc, 0x21, 0x1d, 0x20,
	0x2d, 0xa5, 0x56, 0xd2, 0x01, 0xc4, 0xa4, 0x03, 0x65, 0x41, 0x07, 0xbe, 0x68, 0x93, 0xe4, 0x55,
	0xa6, 0x4f, 0xde, 0x55, 0x5c, 0x18, 0x95, 0x16, 0x31, 0xa3, 0x23, 0x74, 0xff, 0x55, 0x67, 0x2d,
	0xb0, 0x0a, 0x61, 0x76, 0x54, 0xc9, 0x7a, 0x24, 0x0f, 0xd4, 0xf0, 0x08, 0x7e, 0x34, 0xa1, 0xfe,
	0x63, 0xa5, 0x35, 0xf4, 0xe4, 0x52, 0xe3, 0x4f, 0x8e, 0x7d, 0x3d, 0x45, 0xa6, 0x13, 0x5c, 0x43,
	0x18, 0x03, 0x50, 0xe4, 0x84, 0xa7, 0xf5, 0x3c, 0xa4, 0x59, 0x33, 0xe6, 0x21, 0xd2, 0xef, 0x51,
	0x25, 0x9e, 0xd8, 0xbe, 0xdf, 0x96, 0x2f, 0x02, 0xc5, 0x89, 0xed, 0xfb, 0x6d, 0xe3, 0xc4, 0xf6,
	0xfd, 0x36, 0x9e, 0xd8, 0xbe, 0xdf, 0xd6, 0x7b, 0x98, 0x1e, 0x77, 0x0f, 0xa3, 0x24, 0x51, 0x66,
	0xdc, 0x24, 0x91, 0x21, 0xf1, 0xd9, 0xbd, 0x48, 0x3c, 0xac, 0xcd, 0xe4, 0x82, 0xe3, 0xdd, 0xe4,
	0x2d, 0x58, 0x2a, 0x10, 0xd4, 0x7d, 0x6d, 0xcc, 0x55, 0x92, 0x5f, 0x09, 0xc4, 0x38, 0x72, 0x6b,
	0x70, 0x39, 0x15, 0xa6, 0x97, 0x53, 0x21, 0xcc, 0x8e, 0x2a, 0x29, 0x27, 0x05, 0xf1, 0x25, 0x6c,
	0xed, 0xf8, 0xc7, 0x11, 0x5e, 0xf3, 0x45, 0x5d, 0x75, 0x76, 0x21, 0x82, 0x98, 0xad, 0xab, 0xe9,
	0x5c, 0xfc, 0xe6, 0xf3, 0xa4, 0xb9, 0x0f, 0x25, 0x73, 0x1f, 0xe4, 0x36, 0xb0, 0x0f, 0x32, 0xa4,
	0xf0, 0x7c, 0xa7, 0xe5, 0x3b, 0xcd, 0xbb, 0xae, 0xc9, 0x08, 0xd7, 0x64, 0x21, 0x9e, 0x80, 0xfa,
	0xa8, 0xb9, 0xae, 0xb5, 0x98, 0x7c, 0x8f, 0xb8, 0x60, 0x59, 0x50, 0x22, 0x9f, 0xd3, 0x83, 0x28,
	0x91, 0xaf, 0xc5, 0x44, 0x7e, 0xe0, 0x20, 0x42, 0x0b, 0x9e, 0x94, 0x7a, 0x39, 0x81, 0x7a, 0x79,
	0xd9, 0xd0, 0xcb, 0xaa, 0xa9, 0x97, 0x83, 0x46, 0x10, 0xaa, 0xfa, 0xaa, 0x61, 0x15, 0xc4, 0x6b,
	0xb0, 0xda, 0x28, 0x33, 0x88, 0xe1, 0xf2, 0xa3, 0x09, 0xbb, 0x71, 0x36, 0x61, 0x37, 0x06, 0x5f,
	0xb2, 0x44, 0xd5, 0xdb, 0x96, 0x36, 0xbd, 0xfb, 0xd3, 0xbd, 0x39, 0x95, 0x5c, 0x4d, 0x69, 0xb9,
	0x56, 0x69, 0x94, 0x92, 0x99, 0x5c, 0x95, 0xb9, 0x55, 0xfa, 0x2c, 0x29, 0xad, 0xf6, 0xf0, 0x29,
	0x4c, 0x23, 0x74, 0xda, 0x1d, 0x69, 0x97, 0xf0, 0xbe, 0xc3, 0xc4, 0xb5, 0x4f, 0x60, 0xa2, 0xcc,
	0x8e, 0x35, 0x02, 0x96, 0x57, 0x7b, 0x21, 0xc4, 0x68, 0x19, 0x1d, 0x94, 0x0b, 0xc4, 0xf8, 0xdd,
	0x01, 0x96, 0x99, 0x2d, 0x2b, 0xd8, 0x1f, 0xa6, 0x23, 0xcd, 0x0a, 0x3a, 0x60, 0xee, 0x56, 0x82,
	0x25, 0xaf, 0x29, 0x4f, 0x46, 0x34, 0x77, 0x08, 0xe8, 0x01, 0xb0, 0x08, 0xe6, 0x0e, 0x3f, 0xe8,
	0x0b, 0x64, 0x7a, 0x25, 0x68, 0xf0, 0x8e, 0xd3, 0x75, 0x42, 0x2e, 0xe4, 0x46, 0x58, 0x9d, 0xd9,
	0xad, 0x7e, 0x35, 0x59, 0xb5, 0xdd, 0xaf, 0xde, 0x17, 0x9d, 0x0c, 0x66, 0x05, 0xab, 0xd9, 0xc9,
	0xb6, 0xf4, 0x19, 0x52, 0x54, 0x2a, 0x1f, 0x76, 0x95, 0xe7, 0x87, 0xde, 0x92, 0x01, 0xeb, 0x95,
	0x31, 0x40, 0xf0, 0x96, 0x8c, 0x22, 0xdd, 0x14, 0x89, 0x9f, 0x28, 0x3f, 0xba, 0xd7, 0x73, 0x35,
	0xba, 0x73, 0x88, 0x46, 0x88, 0xdf, 0x39, 0x44, 0xb0, 0xba, 0x73, 0x88, 0x00, 0x7a, 0x2b, 0x76,
	0x0f, 0x9d, 0x1d, 0x9d, 0x63, 0x5a, 0xed, 0x85, 0xfb, 0xbd, 0x84, 0x7e, 0x27, 0x45, 0x0a, 0x51,
	0xf7, 0xfd, 0x09, 0xaf, 0xba, 0x46, 0x48, 0x8d, 0x73, 0x8d, 0x70, 0x95, 0xe4, 0xe5, 0x13, 0x07,
	0x91, 0x02, 0x92, 0x0f, 0xb0, 0x15, 0xa6, 0x4f, 0x19, 0x85, 0x30, 0x3b, 0xaa, 0x4c, 0x5c, 0xce,
	0x67, 0x8e, 0xf2, 0x72, 0xfe, 0x3d, 0x8b, 0x4c, 0xfd, 0x60, 0x8f, 0x77, 0x37, 0x05, 0x76, 0x67,
	0x66, 0x26, 0x5f, 0x4f, 0x30, 0x19, 0x74, 0x12, 0x2f, 0x40, 0x44, 0x6e, 0xf2, 0xa1, 0x61, 0x4b,
	0x64, 0xf4, 0xdd, 0xf7, 0xa3, 0x95, 0xbf, 0x4d, 0x91, 0x63, 0x3b, 0xc6, 0xa1, 0x4f, 0x18, 0xdb,
	0x2c, 0x32, 0x34, 0xb5, 0xc4, 0x36, 0x97, 0x13, 0xdb, 0x5c, 0x33, 0xf6, 0xf9, 0x0e, 0x39, 0x5e,
	0x2f, 0xc7, 0xb2, 0x3a, 0xbb, 0x08, 0x36, 0x27, 0x05, 0x1d, 0x90, 0x67, 0xf7, 0xea, 0x01, 0x99,
	0xc1, 0xb8, 0xba, 0xa4, 0x8d, 0xe2, 0x6e, 0x5b, 0x57, 0xb3, 0x4f, 0x91, 0xd2, 0x11, 0xbe, 0xb4,
	0x61, 0x7f, 0x6c, 0x91, 0x72, 0xf2, 0xf7, 0x1c, 0xe0, 0xb2, 0xaf, 0x75, 0xfd, 0x4e, 0x44, 0x07,
	0x5d, 0x76, 0x81, 0xe8, 0xe5, 0x13, 0x65, 0x70, 0xd9, 0xc5, 0x17, 0xfd, 0xa1, 0x28, 0xd5, 0x9b,
	0xc2, 0x84, 0xe5, 0xd0, 0x7b, 0x9a, 0x35, 0x67, 0x13, 0x1a, 0xea, 0x64, 0x65, 0x94, 0x0f, 0x9e,
	0x8a, 0xe5, 0x83, 0x6b, 0x51, 0x42, 0x58, 0x4e, 0x27, 0xbd, 0xeb, 0x74, 0xfa, 0x16, 0x29, 0x2d,
	0xf3, 0xf0, 0x0e, 0xd6, 0xe1, 0x98, 0xa6, 0xa4, 0xf7, 0xaa, 0x29, 0x6c, 0xd3, 0x9c, 0x5f, 0xd0,
	0x49, 0x58, 0x48, 0xeb, 0x28, 0x2d, 0xe4, 0x6f, 0xa7, 0xc9, 0xd4, 0x75, 0xa7, 0xbb, 0xce, 0x43,
	0x3c, 0xb5, 0x3e, 0x8c, 0xfe, 0xf5, 0x42, 0x3c, 0xdc, 0x38, 0xa0, 0x5b, 0x9c, 0x3d, 0x04, 0xb7,
	0x38, 0xb7, 0x4f, 0xb7, 0x98, 0xfd, 0x83, 0x15, 0xdf, 0xad, 0xa0, 0x13, 0xfb, 0xa9, 0x81, 0x75,
	0x64, 0x3f, 0x35, 0xd8, 0x4c, 0x3e, 0xd9, 0x48, 0x8d, 0xf6, 0xa1, 0x90, 0xbd, 0xc3, 0x79, 0xb7,
	0xf1, 0x5d, 0x8b, 0x4c, 0x27, 0x86, 0xdb, 0xb7, 0x87, 0x83, 0x4f, 0x31, 0x52, 0x7b, 0x7b, 0x8a,
	0x91, 0x1e, 0xff, 0x29, 0x46, 0xf4, 0xba, 0x22, 0x33, 0xee, 0xeb, 0x8a, 0xdf, 0x48, 0x91, 0x12,
	0xb0, 0x87, 0xbf, 0xf3, 0xb9, 0x9b, 0xc8, 0x1b, 0xe1, 0x25, 0x7d, 0xd3, 0x32, 0x57, 0x4a, 0xa4,
	0x47, 0x40, 0x27, 0x22, 0xd7, 0x04, 0x77, 0x48, 0x20, 0x66, 0x3e, 0x07, 0xca, 0xcc, 0x96, 0x15,
	0x3a, 0xf5, 0x90, 0x1a, 0x2f, 0xf5, 0x80, 0x3f, 0x6d, 0x44, 0xbd, 0x4f, 0xeb, 0x0e, 0x4a, 0xef,
	0x4b, 0xa6, 0xde, 0x4b, 0x1d, 0x67, 0x7f, 0x69, 0x91, 0xa2, 0x52, 0x9b, 0x0f, 0xe1, 0x86, 0xb2,
	0x9f, 0x24, 0x25, 0x3d, 0xbd, 0xa0, 0x43, 0x3d, 0x5d, 0x1e, 0xe7, 0x22, 0x5d, 0x9b, 0x1f, 0x0c,
	0x73, 0xcd, 0xae, 0x3a, 0x98, 0x33, 0x51, 0x66, 0xc7, 0x1a, 0xb1, 0xbf, 0xb7, 0xc8, 0x34, 0x6c,
	0xe6, 0x53, 0xad, 0xd6, 0xe1, 0x9f, 0x58, 0xcf, 0xea, 0x55, 0x11, 0x6b, 0xfc, 0xb1, 0xf8, 0xaa,
	0xb0, 0xc4, 0xdd, 0xe1, 0xc0, 0x25, 0x36, 0x44, 0x5f, 0x0a, 0xa8, 0xf0, 0x08, 0xe6, 0x62, 0x02,
	0x7a, 0x26, 0x26, 0xa0, 0x83, 0xb9, 0x92, 0x95, 0x21, 0x29, 0xc7, 0x67, 0x1c, 0x74, 0xe8, 0x4b,
	0xe6, 0xe3, 0x05, 0x61, 0x8c, 0x4f, 0x0f, 0xfd, 0x51, 0xfa, 0xbe, 0xfe, 0xb9, 0xc3, 0xef, 0x59,
	0x24, 0x27, 0xcd, 0xad, 0x21, 0x7a, 0xd6, 0xc1, 0x45, 0x8f, 0x93, 0x02, 0xea, 0x96, 0xc1, 0xfa,
	0x50, 0xaf, 0x12, 0x1b, 0x9a, 0xfc, 0x47, 0x3d, 0x0d, 0xd7, 0x46, 0x41, 0xc0, 0xbf, 0x2e, 0x7c,
	0x9a, 0x14, 0x8d, 0xde, 0x5a, 0xf3, 0xad, 0x31, 0x35, 0xff, 0x49, 0x52, 0xc0, 0xe5, 0x8e, 0xd8,
	0x94, 0xbf, 0x66, 0x88, 0x40, 0xc3, 0xc9, 0x57, 0x10, 0x38, 0xf9, 0xd1, 0xf7, 0x67, 0xd3, 0x22,
	0xdb, 0xdd, 0xe0, 0xad, 0x5b, 0x10, 0x5c, 0xdc, 0xc1, 0xd6, 0xe0, 0xd9, 0xa4, 0x35, 0x38, 0x88,
	0xdc, 0x1f, 0x8a, 0xbf, 0x75, 0x68, 0xbf, 0x75, 0x79, 0xcb, 0x22, 0xe5, 0xf8, 0x2e, 0x04, 0x1d,
	0x7a, 0xd5, 0x78, 0x63, 0x6b, 0xfc, 0x22, 0xca, 0x78, 0x63, 0x3b, 0x9d, 0x78, 0x63, 0x6b, 0x3c,
	0xb1, 0xbd, 0x2a, 0x1e, 0xc8, 0x1a, 0xd9, 0x92, 0xaa, 0x7a, 0xfc, 0x2a, 0x03, 0xcb, 0x69, 0x7d,
	0x11, 0x2b, 0x82, 0xcb, 0xa8, 0x92, 0xbd, 0x95, 0x26, 0xd3, 0x36, 0x5f, 0x74, 0x83, 0xb0, 0xeb,
	0xde, 0xe8, 0x85, 0x77, 0x1d, 0xee, 0x61, 0x02, 0xd0, 0x24, 0x79, 0x30, 0x7a, 0x46, 0x20, 0x7e,
	0x61, 0xb8, 0x91, 0xf0, 0xdb, 0x3b, 0x2e, 0xc2, 0x54, 0x67, 0x23, 0x17, 0x25, 0x11, 0x66, 0x47,
	0x95, 0xec, 0xd3, 0xe2, 0x30, 0x31, 0x2f, 0xa4, 0x2e, 0x4b, 0x27, 0x5d, 0x78, 0x15, 0xf7, 0x19,
	0x4e, 0x7a, 0xd1, 0x70, 0xd2, 0x65, 0x9e, 0xfa, 0xc0, 0x46, 0xe2, 0x3d, 0xfc, 0xb5, 0x90, 0x29,
	0x0f, 0x41, 0x87, 0x7e, 0xd1, 0x4a, 0xa6, 0x2c, 0xb3, 0x7b, 0x4b, 0x59, 0x7e, 0xff, 0xa0, 0x94,
	0xe5, 0x43, 0x03, 0x53, 0x96, 0x03, 0xf7, 0x20, 0xde, 0x97, 0x2d, 0x90, 0xfc, 0x33, 0xbc, 0xd5,
	0xc2, 0xe7, 0xbf, 0x1f, 0x27, 0x19, 0x4f, 0xbf, 0xd8, 0x39, 0xab, 0x63, 0x17, 0xf1, 0xfb, 0xfc,
	0x81, 0xb1, 0x0b, 0x56, 0x5d, 0x21, 0x05, 0x39, 0x48, 0xd0, 0xa1, 0x0f, 0x92, 0x89, 0x05, 0xdf,
	0x0b, 0xb9, 0x17, 0xca, 0x81, 0x8a, 0x20, 0x5b, 0x37, 0x05, 0x64, 0xab, 0xba, 0x4b, 0xcf, 0x92,
	0xa2, 0x91, 0x57, 0xa0, 0xc7, 0xc9, 0xb4, 0x2c, 0xae, 0x78, 0x6e, 0x08, 0x50, 0xf9, 0x1e, 0x4a,
	0x48, 0x16, 0xdf, 0x18, 0x95, 0xff, 0x64, 0x1a, 0xbe, 0xd7, 0xba, 0xee, 0x8f, 0xf2, 0xf2, 0x9f,
	0x4e, 0xd3, 0x69, 0x42, 0x1a, 0x62, 0x85, 0x9e, 0xe6, 0xbc, 0xfc, 0x9d, 0xe9, 0x4b, 0xb7, 0xc9,
	0x74, 0xe2, 0x55, 0x15, 0x2d, 0x91, 0xbc, 0x31, 0x52, 0x89, 0xe4, 0xeb, 0x7e, 0x88, 0xbf, 0xe4,
	0x28, 0x5b, 0x50, 0xc2, 0xe6, 0x4b, 0x5e, 0xb3, 0x9c, 0xa2, 0x45, 0x32, 0x51, 0xf7, 0xc3, 0x86,
	0xbb, 0xee, 0x95, 0xd3, 0x50, 0xf5, 0x8c, 0xb3, 0xc1, 0xb1, 0x94, 0xa1, 0x53, 0xe2, 0x7f, 0x61,
	0x2c, 0x3b, 0x6d, 0xd7, 0x5b, 0x2f, 0x67, 0x69, 0x59, 0xbc, 0xaf, 0x50, 0xbf, 0xda, 0x2f, 0xe7,
	0x2e, 0xbd, 0x93, 0x27, 0xd3, 0x2b, 0x4d, 0xee, 0x85, 0xee, 0xad, 0xcd, 0xa5, 0x6e, 0x17, 0x49,
	0x53, 0x32, 0x85, 0x91, 0x7b, 0xdd, 0x0f, 0xaf, 0xf9, 0x4d, 0xf7, 0xd6, 0x66, 0xf9, 0x1e, 0x4a,
	0xc9, 0xe4, 0x32, 0x0f, 0x17, 0x7c, 0xef, 0x96, 0xbb, 0xfe, 0xb4, 0xe3, 0xb6, 0xca, 0xff, 0x58,
	0xa7, 0x65, 0xf1, 0xd3, 0x0f, 0x45, 0xfc, 0x9f, 0xea, 0xf4, 0x24, 0xb9, 0xb7, 0xee, 0x87, 0x4f,
	0xf7, 0x5a, 0xad, 0xd8, 0xcf, 0xd9, 0xcb, 0xff, 0x5c, 0xa7, 0xc7, 0xc9, 0x94, 0x51, 0xb5, 0xe6,
	0x6c, 0x96, 0xff, 0xa5, 0x4e, 0x27, 0xc5, 0x65, 0x2f, 0x0e, 0xf8, 0xaf, 0xd8, 0x46, 0xdf, 0x33,
	0x22, 0xf8, 0x6f, 0x75, 0x7a, 0x2f, 0x99, 0x16, 0x29, 0x73, 0x0c, 0x4b, 0x10, 0xfd, 0xf7, 0x3a,
	0xad, 0x90, 0xe3, 0xf8, 0x4a, 0x04, 0xed, 0x27, 0xae, 0x1a, 0xd6, 0xfc, 0x07, 0x0e, 0xb2, 0xcc,
	0x43, 0x49, 0x04, 0xc1, 0xff, 0x44, 0x70, 0x75, 0x83, 0x77, 0x71, 0xd5, 0x16, 0x20, 0x22, 0x2a,
	0xff, 0x57, 0x9d, 0x9e, 0x20, 0xc7, 0x96, 0x79, 0xa8, 0x31, 0x6c, 0xfc, 0xdf, 0x75, 0x98, 0xab,
	0xd8, 0x0d, 0xc5, 0xc5, 0xff, 0xd4, 0xe9, 0x47, 0x48, 0xb9, 0xc1, 0x43, 0x24, 0x19, 0xc1, 0x9f,
	0x59, 0xa5, 0xf7, 0x11, 0x0a, 0xb3, 0x72, 0xbd, 0xa6, 0x7c, 0x9e, 0x74, 0xd3, 0xef, 0x36, 0xcb,
	0xaf, 0xaf, 0x02, 0x7f, 0x5a, 0x73, 0x50, 0x5c, 0xb1, 0xcb, 0x1b, 0xab, 0x40, 0x75, 0x91, 0xb7,
	0x12, 0x54, 0x3f, 0xbb, 0x0a, 0xf3, 0x5c, 0xe6, 0xa1, 0x72, 0x28, 0x11, 0xfd, 0xa9, 0x55, 0xc9,
	0xa3, 0xfe, 0xd1, 0x1e, 0xe2, 0x9f, 0x43, 0x1c, 0xc4, 0x23, 0x8a, 0x47, 0x11, 0xff, 0x69, 0xc4,
	0xa3, 0x75, 0x01, 0xab, 0x8e, 0xf8, 0xe7, 0x91, 0xd1, 0x06, 0xf7, 0x9a, 0xe2, 0x99, 0x29, 0x0c,
	0x86, 0x15, 0x5f, 0x40, 0xb2, 0x36, 0x87, 0x2a, 0xcd, 0xe4, 0xcf, 0x20, 0xda, 0x48, 0x30, 0xf3,
	0x26, 0x0e, 0xde, 0xe0, 0x21, 0x1a, 0x41, 0x14, 0x45, 0xc4, 0x7f, 0x16, 0x07, 0x5f, 0xe6, 0x21,
	0xf0, 0xe9, 0x78, 0xaf, 0x44, 0x5c, 0xbe, 0x85, 0xab, 0x80, 0xa9, 0xdb, 0x04, 0xd9, 0x2f, 0xaa,
	0x79, 0x25, 0xf0, 0x9f, 0x8b, 0xe3, 0xb0, 0x96, 0x88, 0x7f, 0x69, 0x15, 0xf6, 0x64, 0x91, 0xb7,
	0x16, 0x7a, 0xdd, 0x2e, 0xf7, 0xc2, 0x7a, 0xaf, 0x5d, 0xfe, 0xf2, 0x2a, 0xec, 0x89, 0x6c, 0xab,
	0x97, 0xe0, 0xe7, 0x91, 0x1b, 0x58, 0x1a, 0x9c, 0x8f, 0xae, 0xf8, 0x0a, 0xb6, 0x47, 0xde, 0xeb,
	0xbd, 0x36, 0x08, 0x03, 0xc8, 0x54, 0xf9, 0xed, 0x55, 0x29, 0x99, 0x2b, 0x5e, 0xf4, 0x6f, 0x26,
	0xca, 0xbf, 0xa0, 0xc6, 0xc6, 0xe6, 0xd1, 0x84, 0xde, 0x59, 0x05, 0x01, 0x57, 0x22, 0xa3, 0x7e,
	0x5f, 0x84, 0x55, 0x5f, 0x55, 0x3d, 0x22, 0xcb, 0x84, 0xf0, 0xd7, 0x90, 0xf1, 0xa5, 0xa6, 0x2b,
	0x46, 0x42, 0xec, 0x5d, 0x9c, 0x24, 0x60, 0xd1, 0xfb, 0x43, 0xc4, 0xbf, 0x8e, 0x9c, 0x03, 0x9e,
	0x90, 0x8d, 0x5f, 0xc4, 0xb1, 0x61, 0x4a, 0x75, 0xfe, 0x9a, 0x1e, 0xe7, 0x1b, 0x6a, 0x97, 0x9e,
	0x6f, 0x88, 0x9b, 0x41, 0x44, 0x7f, 0x09, 0xe7, 0x83, 0x8b, 0xbe, 0x74, 0xdb, 0x0d, 0xc4, 0x08,
	0xbf, 0xbc, 0x4a, 0x8f, 0x91, 0xd2, 0x22, 0x6f, 0xe9, 0x3d, 0xfe, 0x95, 0x55, 0x7a, 0x8a, 0x9c,
	0x40, 0x45, 0xf1, 0xd6, 0x5b, 0x3c, 0xca, 0x62, 0x60, 0xe5, 0xaf, 0xae, 0x5e, 0xf9, 0x36, 0x25,
	0xc5, 0x25, 0x6d, 0xd1, 0xe9, 0xf7, 0x91, 0xcc, 0x9a, 0xeb, 0xad, 0xd3, 0x13, 0xb3, 0xe2, 0xdf,
	0xd0, 0xcd, 0xaa, 0xff, 0x51, 0x37, 0xbb, 0xd4, 0xee, 0x84, 0x9b, 0x33, 0x43, 0x70, 0xea, 0x92,
	0x0c, 0x3e, 0x87, 0xa8, 0x0e, 0x3b, 0x1f, 0xe4, 0x3f, 0xad, 0x9b, 0x19, 0xdd, 0x20, 0xe8, 0xb0,
	0xea, 0x1b, 0xdf, 0xf9, 0x9b, 0xb7, 0x53, 0x27, 0xd9, 0x7d, 0x73, 0x06, 0x5f, 0x73, 0x38, 0xd3,
	0x39, 0x24, 0xf1, 0x6a, 0x14, 0x14, 0x9c, 0x19, 0x1d, 0x6e, 0x00, 0xb9, 0xdd, 0x9a, 0x04, 0x1d,
	0x76, 0x06, 0x09, 0x9e, 0x62, 0x27, 0x07, 0x10, 0x94, 0x84, 0x5e, 0xb7, 0x54, 0x3a, 0x14, 0xef,
	0xd4, 0x1e, 0xdc, 0xfd, 0xb7, 0xbb, 0x40, 0x7b, 0x9c, 0x66, 0x41, 0x87, 0x3d, 0x88, 0xf4, 0xab,
	0xec, 0x81, 0x01, 0xf4, 0x0d, 0xa2, 0x9b, 0xc6, 0xdd, 0xf0, 0xd9, 0xdd, 0x6e, 0xa2, 0x81, 0xfc,
	0xee, 0x8d, 0x82, 0x0e, 0x3b, 0x8b, 0xc4, 0x1f, 0x60, 0xa7, 0x06, 0x10, 0x8f, 0xc8, 0xfd, 0x84,
	0x74, 0x31, 0xb0, 0x70, 0x6e, 0x64, 0xc2, 0x4d, 0x11, 0x1f, 0xa3, 0x55, 0xd0, 0x61, 0xe7, 0x90,
	0xfa, 0x69, 0x76, 0xff, 0x00, 0xea, 0x9a, 0x22, 0xac, 0xbe, 0xb6, 0x14, 0xc3, 0x57, 0x3f, 0xf6,
	0xfe, 0x7f, 0x66, 0x9c, 0x66, 0xbb, 0xac, 0xbe, 0x41, 0xf4, 0xb6, 0xf8, 0x57, 0x3c, 0x68, 0x73,
	0x87, 0x2f, 0x81, 0xf9, 0x7e, 0x75, 0x66, 0x8c, 0x56, 0x43, 0xc5, 0x1d, 0xab, 0xe7, 0xf0, 0x39,
	0xd6, 0x8f, 0x89, 0xb3, 0x5d, 0xbc, 0x1e, 0xa3, 0x23, 0x1f, 0x0e, 0x46, 0x8f, 0xf1, 0x66, 0x46,
	0x36, 0x8b, 0x1e, 0xa2, 0x0d, 0x21, 0x6e, 0x90, 0xfb, 0x71, 0x42, 0xf4, 0x49, 0x7d, 0x60, 0xe2,
	0xb1, 0xc7, 0x45, 0xac, 0x86, 0xc4, 0x67, 0x58, 0x25, 0x3e, 0x73, 0x6c, 0x23, 0xa6, 0xfe, 0x2a,
	0xc9, 0x09, 0x97, 0x60, 0xb8, 0xa6, 0x47, 0x6f, 0x72, 0x66, 0x76, 0x6b, 0x32, 0x54, 0xd3, 0x45,
	0xfd, 0x9c, 0x78, 0x0f, 0xf1, 0x19, 0x8b, 0x14, 0x8d, 0x5b, 0x48, 0x7a, 0x7e, 0x8c, 0x2b, 0x4f,
	0xa0, 0x3e, 0x56, 0xbb, 0x5d, 0x8c, 0x8d, 0x24, 0x79, 0x9b, 0x14, 0x22, 0x57, 0x60, 0xb8, 0xa8,
	0x99, 0xb7, 0x51, 0x33, 0x63, 0xb4, 0x1a, 0xba, 0xdb, 0xcb, 0x3c, 0x54, 0x94, 0x3f, 0x8f, 0x79,
	0xee, 0x28, 0xb7, 0x8f, 0xca, 0x77, 0x7e, 0xb8, 0x22, 0x9b, 0x57, 0x36, 0x33, 0x63, 0xb5, 0x1b,
	0xaa, 0xf2, 0xc0, 0x84, 0xd1, 0x90, 0x7e, 0x4e, 0x86, 0x1f, 0x98, 0x6a, 0x1d, 0x6d, 0x76, 0xcc,
	0xdc, 0xf5, 0xcc, 0x18, 0xad, 0x82, 0x0e, 0xbb, 0x88, 0x3c, 0x30, 0x56, 0x1b, 0xa2, 0xf3, 0x9a,
	0xea, 0x1b, 0x56, 0x3c, 0xb7, 0x38, 0xdc, 0xf2, 0x1a, 0x09, 0xd7, 0xe1, 0x5c, 0x98, 0x69, 0x4b,
	0x76, 0x01, 0xb9, 0x38, 0xc3, 0xaa, 0x03, 0xb8, 0x88, 0xd1, 0x7c, 0xd3, 0x22, 0x25, 0x33, 0xfb,
	0x46, 0x47, 0x86, 0xa1, 0x46, 0x56, 0x72, 0xe6, 0xe2, 0x78, 0x0d, 0x77, 0x61, 0x26, 0x46, 0xfb,
	0x4d, 0x99, 0x04, 0x57, 0xe9, 0x04, 0x3a, 0x32, 0x22, 0x34, 0x12, 0x4f, 0xc3, 0x99, 0x49, 0xe6,
	0x46, 0x46, 0x32, 0x13, 0xa3, 0xfd, 0x15, 0x8b, 0x1c, 0x33, 0x43, 0xd7, 0xdd, 0x96, 0x27, 0x9e,
	0xf5, 0x18, 0xb1, 0x3c, 0x89, 0x70, 0x98, 0x5d, 0x42, 0x8e, 0xce, 0x31, 0x16, 0xe3, 0x08, 0x1f,
	0xf7, 0xcc, 0x25, 0xc8, 0xcf, 0x9f, 0xfc, 0xd6, 0xfb, 0xa7, 0xef, 0xf9, 0xd6, 0x07, 0xa7, 0xad,
	0x6f, 0x7f, 0x70, 0xda, 0xfa, 0xab, 0x0f, 0x4e, 0x5b, 0xef, 0xfe, 0xf5, 0xe9, 0x7b, 0x5e, 0x4c,
	0x3b, 0x1d, 0xf7, 0x46, 0x0e, 0xbd, 0xa6, 0x47, 0xff, 0x37, 0x00, 0x00, 0xff, 0xff, 0x12, 0xc5,
	0x5f, 0x11, 0x53, 0x58, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EliminationClient is the client API for Elimination service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EliminationClient interface {
	Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	//一.查询比赛列表
	List(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListRsp, error)
	//二.获取比赛详情
	Detail(ctx context.Context, in *DetailReq, opts ...grpc.CallOption) (*DetailRsp, error)
	//    三.获取比赛奖励信息
	RewardInfo(ctx context.Context, in *RewardInfoReq, opts ...grpc.CallOption) (*RewardInfoRsp, error)
	//    四.获取比赛玩家信息(包含实时战绩)
	UserInfo(ctx context.Context, in *UserInfoReq, opts ...grpc.CallOption) (*UserInfoRsp, error)
	//    五.获取牌桌信息
	TableInfo(ctx context.Context, in *TableInfoReq, opts ...grpc.CallOption) (*TableInfoRsp, error)
	//    六.获取个人参赛记录
	UserRecord(ctx context.Context, in *UserRecordReq, opts ...grpc.CallOption) (*UserRecordRsp, error)
	//    七.查询报名费用以及是否满足报名条件
	SignCheck(ctx context.Context, in *SignCheckReq, opts ...grpc.CallOption) (*SignCheckRsp, error)
	//   八.确认报名(包含分房与配桌)
	SignEnsure(ctx context.Context, in *SignCommonReq, opts ...grpc.CallOption) (*SignEnsureRsp, error)
	//    九.取消报名
	CancelSign(ctx context.Context, in *SignCommonReq, opts ...grpc.CallOption) (*CancelSignRsp, error)
	//    十.积分上报(包含淘汰发奖)
	Upload(ctx context.Context, in *UploadReq, opts ...grpc.CallOption) (*UploadRsp, error)
	// 十一.查询奖励
	QueryReward(ctx context.Context, in *QueryRewardReq, opts ...grpc.CallOption) (*QueryRewardRsp, error)
	// 十二.领取奖励
	GetReward(ctx context.Context, in *GetRewardReq, opts ...grpc.CallOption) (*GetRewardRsp, error)
	// 十三.获取特定牌桌的信息
	TargetTableInfo(ctx context.Context, in *TargetTableReq, opts ...grpc.CallOption) (*TargetTableRsp, error)
	// 十四.获取用户进场信息
	UserEnterInfo(ctx context.Context, in *UserEnterReq, opts ...grpc.CallOption) (*UserEnterRsp, error)
	// 十五.获取盲注列表
	BlindBetList(ctx context.Context, in *BlindBetReq, opts ...grpc.CallOption) (*BlindBetResp, error)
	// 十六.获取Room下的所有场次的所有桌子
	RoomAllTable(ctx context.Context, in *RoomAllTableReq, opts ...grpc.CallOption) (*RoomAllTableResp, error)
	// 十七.获取实时个人排名相关数据
	UserSelfRank(ctx context.Context, in *UserSelfRankReq, opts ...grpc.CallOption) (*UserSelfRankResp, error)
	// 十七.获取实时个人排名相关数据
	ReDistributeTable(ctx context.Context, in *ReDistributeReq, opts ...grpc.CallOption) (*ReDistributeResp, error)
}

type eliminationClient struct {
	cc *grpc.ClientConn
}

func NewEliminationClient(cc *grpc.ClientConn) EliminationClient {
	return &eliminationClient{cc}
}

func (c *eliminationClient) Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) List(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListRsp, error) {
	out := new(ListRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) Detail(ctx context.Context, in *DetailReq, opts ...grpc.CallOption) (*DetailRsp, error) {
	out := new(DetailRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/Detail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) RewardInfo(ctx context.Context, in *RewardInfoReq, opts ...grpc.CallOption) (*RewardInfoRsp, error) {
	out := new(RewardInfoRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/RewardInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) UserInfo(ctx context.Context, in *UserInfoReq, opts ...grpc.CallOption) (*UserInfoRsp, error) {
	out := new(UserInfoRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/UserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) TableInfo(ctx context.Context, in *TableInfoReq, opts ...grpc.CallOption) (*TableInfoRsp, error) {
	out := new(TableInfoRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/TableInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) UserRecord(ctx context.Context, in *UserRecordReq, opts ...grpc.CallOption) (*UserRecordRsp, error) {
	out := new(UserRecordRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/UserRecord", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) SignCheck(ctx context.Context, in *SignCheckReq, opts ...grpc.CallOption) (*SignCheckRsp, error) {
	out := new(SignCheckRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/SignCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) SignEnsure(ctx context.Context, in *SignCommonReq, opts ...grpc.CallOption) (*SignEnsureRsp, error) {
	out := new(SignEnsureRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/SignEnsure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) CancelSign(ctx context.Context, in *SignCommonReq, opts ...grpc.CallOption) (*CancelSignRsp, error) {
	out := new(CancelSignRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/CancelSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) Upload(ctx context.Context, in *UploadReq, opts ...grpc.CallOption) (*UploadRsp, error) {
	out := new(UploadRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/Upload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) QueryReward(ctx context.Context, in *QueryRewardReq, opts ...grpc.CallOption) (*QueryRewardRsp, error) {
	out := new(QueryRewardRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/QueryReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) GetReward(ctx context.Context, in *GetRewardReq, opts ...grpc.CallOption) (*GetRewardRsp, error) {
	out := new(GetRewardRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/GetReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) TargetTableInfo(ctx context.Context, in *TargetTableReq, opts ...grpc.CallOption) (*TargetTableRsp, error) {
	out := new(TargetTableRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/TargetTableInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) UserEnterInfo(ctx context.Context, in *UserEnterReq, opts ...grpc.CallOption) (*UserEnterRsp, error) {
	out := new(UserEnterRsp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/UserEnterInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) BlindBetList(ctx context.Context, in *BlindBetReq, opts ...grpc.CallOption) (*BlindBetResp, error) {
	out := new(BlindBetResp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/BlindBetList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) RoomAllTable(ctx context.Context, in *RoomAllTableReq, opts ...grpc.CallOption) (*RoomAllTableResp, error) {
	out := new(RoomAllTableResp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/RoomAllTable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) UserSelfRank(ctx context.Context, in *UserSelfRankReq, opts ...grpc.CallOption) (*UserSelfRankResp, error) {
	out := new(UserSelfRankResp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/UserSelfRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eliminationClient) ReDistributeTable(ctx context.Context, in *ReDistributeReq, opts ...grpc.CallOption) (*ReDistributeResp, error) {
	out := new(ReDistributeResp)
	err := c.cc.Invoke(ctx, "/elimination.service.v1.Elimination/ReDistributeTable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EliminationServer is the server API for Elimination service.
type EliminationServer interface {
	Ping(context.Context, *empty.Empty) (*empty.Empty, error)
	//一.查询比赛列表
	List(context.Context, *ListReq) (*ListRsp, error)
	//二.获取比赛详情
	Detail(context.Context, *DetailReq) (*DetailRsp, error)
	//    三.获取比赛奖励信息
	RewardInfo(context.Context, *RewardInfoReq) (*RewardInfoRsp, error)
	//    四.获取比赛玩家信息(包含实时战绩)
	UserInfo(context.Context, *UserInfoReq) (*UserInfoRsp, error)
	//    五.获取牌桌信息
	TableInfo(context.Context, *TableInfoReq) (*TableInfoRsp, error)
	//    六.获取个人参赛记录
	UserRecord(context.Context, *UserRecordReq) (*UserRecordRsp, error)
	//    七.查询报名费用以及是否满足报名条件
	SignCheck(context.Context, *SignCheckReq) (*SignCheckRsp, error)
	//   八.确认报名(包含分房与配桌)
	SignEnsure(context.Context, *SignCommonReq) (*SignEnsureRsp, error)
	//    九.取消报名
	CancelSign(context.Context, *SignCommonReq) (*CancelSignRsp, error)
	//    十.积分上报(包含淘汰发奖)
	Upload(context.Context, *UploadReq) (*UploadRsp, error)
	// 十一.查询奖励
	QueryReward(context.Context, *QueryRewardReq) (*QueryRewardRsp, error)
	// 十二.领取奖励
	GetReward(context.Context, *GetRewardReq) (*GetRewardRsp, error)
	// 十三.获取特定牌桌的信息
	TargetTableInfo(context.Context, *TargetTableReq) (*TargetTableRsp, error)
	// 十四.获取用户进场信息
	UserEnterInfo(context.Context, *UserEnterReq) (*UserEnterRsp, error)
	// 十五.获取盲注列表
	BlindBetList(context.Context, *BlindBetReq) (*BlindBetResp, error)
	// 十六.获取Room下的所有场次的所有桌子
	RoomAllTable(context.Context, *RoomAllTableReq) (*RoomAllTableResp, error)
	// 十七.获取实时个人排名相关数据
	UserSelfRank(context.Context, *UserSelfRankReq) (*UserSelfRankResp, error)
	// 十七.获取实时个人排名相关数据
	ReDistributeTable(context.Context, *ReDistributeReq) (*ReDistributeResp, error)
}

// UnimplementedEliminationServer can be embedded to have forward compatible implementations.
type UnimplementedEliminationServer struct {
}

func (*UnimplementedEliminationServer) Ping(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (*UnimplementedEliminationServer) List(ctx context.Context, req *ListReq) (*ListRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (*UnimplementedEliminationServer) Detail(ctx context.Context, req *DetailReq) (*DetailRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detail not implemented")
}
func (*UnimplementedEliminationServer) RewardInfo(ctx context.Context, req *RewardInfoReq) (*RewardInfoRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RewardInfo not implemented")
}
func (*UnimplementedEliminationServer) UserInfo(ctx context.Context, req *UserInfoReq) (*UserInfoRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfo not implemented")
}
func (*UnimplementedEliminationServer) TableInfo(ctx context.Context, req *TableInfoReq) (*TableInfoRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TableInfo not implemented")
}
func (*UnimplementedEliminationServer) UserRecord(ctx context.Context, req *UserRecordReq) (*UserRecordRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRecord not implemented")
}
func (*UnimplementedEliminationServer) SignCheck(ctx context.Context, req *SignCheckReq) (*SignCheckRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignCheck not implemented")
}
func (*UnimplementedEliminationServer) SignEnsure(ctx context.Context, req *SignCommonReq) (*SignEnsureRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignEnsure not implemented")
}
func (*UnimplementedEliminationServer) CancelSign(ctx context.Context, req *SignCommonReq) (*CancelSignRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelSign not implemented")
}
func (*UnimplementedEliminationServer) Upload(ctx context.Context, req *UploadReq) (*UploadRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upload not implemented")
}
func (*UnimplementedEliminationServer) QueryReward(ctx context.Context, req *QueryRewardReq) (*QueryRewardRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryReward not implemented")
}
func (*UnimplementedEliminationServer) GetReward(ctx context.Context, req *GetRewardReq) (*GetRewardRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReward not implemented")
}
func (*UnimplementedEliminationServer) TargetTableInfo(ctx context.Context, req *TargetTableReq) (*TargetTableRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetTableInfo not implemented")
}
func (*UnimplementedEliminationServer) UserEnterInfo(ctx context.Context, req *UserEnterReq) (*UserEnterRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserEnterInfo not implemented")
}
func (*UnimplementedEliminationServer) BlindBetList(ctx context.Context, req *BlindBetReq) (*BlindBetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlindBetList not implemented")
}
func (*UnimplementedEliminationServer) RoomAllTable(ctx context.Context, req *RoomAllTableReq) (*RoomAllTableResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoomAllTable not implemented")
}
func (*UnimplementedEliminationServer) UserSelfRank(ctx context.Context, req *UserSelfRankReq) (*UserSelfRankResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserSelfRank not implemented")
}
func (*UnimplementedEliminationServer) ReDistributeTable(ctx context.Context, req *ReDistributeReq) (*ReDistributeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReDistributeTable not implemented")
}

func RegisterEliminationServer(s *grpc.Server, srv EliminationServer) {
	s.RegisterService(&_Elimination_serviceDesc, srv)
}

func _Elimination_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).Ping(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).List(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_Detail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).Detail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/Detail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).Detail(ctx, req.(*DetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_RewardInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RewardInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).RewardInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/RewardInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).RewardInfo(ctx, req.(*RewardInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_UserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).UserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/UserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).UserInfo(ctx, req.(*UserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_TableInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TableInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).TableInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/TableInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).TableInfo(ctx, req.(*TableInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_UserRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRecordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).UserRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/UserRecord",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).UserRecord(ctx, req.(*UserRecordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_SignCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignCheckReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).SignCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/SignCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).SignCheck(ctx, req.(*SignCheckReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_SignEnsure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignCommonReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).SignEnsure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/SignEnsure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).SignEnsure(ctx, req.(*SignCommonReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_CancelSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignCommonReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).CancelSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/CancelSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).CancelSign(ctx, req.(*SignCommonReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_Upload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).Upload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/Upload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).Upload(ctx, req.(*UploadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_QueryReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRewardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).QueryReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/QueryReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).QueryReward(ctx, req.(*QueryRewardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_GetReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRewardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).GetReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/GetReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).GetReward(ctx, req.(*GetRewardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_TargetTableInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TargetTableReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).TargetTableInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/TargetTableInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).TargetTableInfo(ctx, req.(*TargetTableReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_UserEnterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserEnterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).UserEnterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/UserEnterInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).UserEnterInfo(ctx, req.(*UserEnterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_BlindBetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlindBetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).BlindBetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/BlindBetList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).BlindBetList(ctx, req.(*BlindBetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_RoomAllTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomAllTableReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).RoomAllTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/RoomAllTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).RoomAllTable(ctx, req.(*RoomAllTableReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_UserSelfRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSelfRankReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).UserSelfRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/UserSelfRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).UserSelfRank(ctx, req.(*UserSelfRankReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Elimination_ReDistributeTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReDistributeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EliminationServer).ReDistributeTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elimination.service.v1.Elimination/ReDistributeTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EliminationServer).ReDistributeTable(ctx, req.(*ReDistributeReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Elimination_serviceDesc = grpc.ServiceDesc{
	ServiceName: "elimination.service.v1.Elimination",
	HandlerType: (*EliminationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Elimination_Ping_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Elimination_List_Handler,
		},
		{
			MethodName: "Detail",
			Handler:    _Elimination_Detail_Handler,
		},
		{
			MethodName: "RewardInfo",
			Handler:    _Elimination_RewardInfo_Handler,
		},
		{
			MethodName: "UserInfo",
			Handler:    _Elimination_UserInfo_Handler,
		},
		{
			MethodName: "TableInfo",
			Handler:    _Elimination_TableInfo_Handler,
		},
		{
			MethodName: "UserRecord",
			Handler:    _Elimination_UserRecord_Handler,
		},
		{
			MethodName: "SignCheck",
			Handler:    _Elimination_SignCheck_Handler,
		},
		{
			MethodName: "SignEnsure",
			Handler:    _Elimination_SignEnsure_Handler,
		},
		{
			MethodName: "CancelSign",
			Handler:    _Elimination_CancelSign_Handler,
		},
		{
			MethodName: "Upload",
			Handler:    _Elimination_Upload_Handler,
		},
		{
			MethodName: "QueryReward",
			Handler:    _Elimination_QueryReward_Handler,
		},
		{
			MethodName: "GetReward",
			Handler:    _Elimination_GetReward_Handler,
		},
		{
			MethodName: "TargetTableInfo",
			Handler:    _Elimination_TargetTableInfo_Handler,
		},
		{
			MethodName: "UserEnterInfo",
			Handler:    _Elimination_UserEnterInfo_Handler,
		},
		{
			MethodName: "BlindBetList",
			Handler:    _Elimination_BlindBetList_Handler,
		},
		{
			MethodName: "RoomAllTable",
			Handler:    _Elimination_RoomAllTable_Handler,
		},
		{
			MethodName: "UserSelfRank",
			Handler:    _Elimination_UserSelfRank_Handler,
		},
		{
			MethodName: "ReDistributeTable",
			Handler:    _Elimination_ReDistributeTable_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *ListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MatchList) > 0 {
		for iNdEx := len(m.MatchList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatchDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BonusPoolNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BonusPoolNum))
		i--
		dAtA[i] = 0x70
	}
	if m.Time != nil {
		{
			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.NowRound != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NowRound))
		i--
		dAtA[i] = 0x60
	}
	if m.Date != nil {
		{
			size, err := m.Date.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if m.SigNum != nil {
		{
			size, err := m.SigNum.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SignCondition) > 0 {
		for iNdEx := len(m.SignCondition) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignCondition[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ShowSingPay != nil {
		{
			size, err := m.ShowSingPay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Order != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x30
	}
	if m.LimitTimes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LimitTimes))
		i--
		dAtA[i] = 0x28
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x20
	}
	if m.TypeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimeDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BeginTime) > 0 {
		i -= len(m.BeginTime)
		copy(dAtA[i:], m.BeginTime)
		i = encodeVarintApi(dAtA, i, uint64(len(m.BeginTime)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignPayDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignPayDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignPayDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pay) > 0 {
		for iNdEx := len(m.Pay) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pay[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MatchTimes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchTimes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShowPayDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowPayDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowPayDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pay) > 0 {
		for iNdEx := len(m.Pay) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pay[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MatchTimes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchTimes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SignDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Num != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DateDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DateDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DateDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Week) > 0 {
		dAtA6 := make([]byte, len(m.Week)*10)
		var j5 int
		for _, num1 := range m.Week {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintApi(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Property) > 0 {
		i -= len(m.Property)
		copy(dAtA[i:], m.Property)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Property)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DetailReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetailReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetailReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x28
	}
	if m.TimeArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TimeArenaId))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DetailRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetailRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetailRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MatchDuration != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchDuration))
		i--
		dAtA[i] = 0x78
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x70
	}
	if m.NowRound != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NowRound))
		i--
		dAtA[i] = 0x68
	}
	if m.InitScoreBoard != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.InitScoreBoard))
		i--
		dAtA[i] = 0x60
	}
	if m.Scoreboard != nil {
		{
			size, err := m.Scoreboard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.BlindBet != nil {
		{
			size, err := m.BlindBet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SigNum != nil {
		{
			size, err := m.SigNum.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SignCondition) > 0 {
		for iNdEx := len(m.SignCondition) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignCondition[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ShowSingPay != nil {
		{
			size, err := m.ShowSingPay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.MatchTime != nil {
		{
			size, err := m.MatchTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.EnterDeadline) > 0 {
		i -= len(m.EnterDeadline)
		copy(dAtA[i:], m.EnterDeadline)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EnterDeadline)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SignLimit != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SignLimit))
		i--
		dAtA[i] = 0x20
	}
	if m.BuyLimit != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BuyLimit))
		i--
		dAtA[i] = 0x18
	}
	if m.ID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlindBetDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlindBetDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlindBetDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RiseBetTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RiseBetTime))
		i--
		dAtA[i] = 0x18
	}
	if m.NextBet != nil {
		{
			size, err := m.NextBet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NowBet != nil {
		{
			size, err := m.NowBet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BetDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BetDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BetDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlindTimeInterval != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BlindTimeInterval))
		i--
		dAtA[i] = 0x28
	}
	if m.FrontBet != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.FrontBet))
		i--
		dAtA[i] = 0x20
	}
	if m.MinBet != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MinBet))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxBet != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MaxBet))
		i--
		dAtA[i] = 0x10
	}
	if m.BetLevel != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BetLevel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BoardDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoardDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BoardDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AverageScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AverageScore))))
		i--
		dAtA[i] = 0x1d
	}
	if m.MinScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MinScore))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MaxScore))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x28
	}
	if m.Round != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardInfoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardInfoRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardInfoRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.TotalRewardNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TotalRewardNum))
		i--
		dAtA[i] = 0x18
	}
	if m.PersonNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PersonNum))
		i--
		dAtA[i] = 0x10
	}
	if m.RewardPool != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RewardPool))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardInfoDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardInfoDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardInfoDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Rank) > 0 {
		dAtA15 := make([]byte, len(m.Rank)*10)
		var j14 int
		for _, num1 := range m.Rank {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintApi(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardThingsDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardThingsDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardThingsDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rate))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Num != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Rank) > 0 {
		dAtA17 := make([]byte, len(m.Rank)*10)
		var j16 int
		for _, num1 := range m.Rank {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintApi(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndPoint != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EndPoint))
		i--
		dAtA[i] = 0x40
	}
	if m.BeginPoint != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BeginPoint))
		i--
		dAtA[i] = 0x38
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x30
	}
	if m.Round != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x28
	}
	if m.TimeArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TimeArenaId))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserInfoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserInfoRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserInfoRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserScoreList) > 0 {
		for iNdEx := len(m.UserScoreList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserScoreList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.SelfInfo != nil {
		{
			size, err := m.SelfInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.PersonNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PersonNum))
		i--
		dAtA[i] = 0x48
	}
	if m.TotalNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TotalNum))
		i--
		dAtA[i] = 0x40
	}
	if m.BonusNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BonusNum))
		i--
		dAtA[i] = 0x38
	}
	if m.MinScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MinScore))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MaxScore))
		i--
		dAtA[i] = 0x28
	}
	if m.AverageScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AverageScore))))
		i--
		dAtA[i] = 0x25
	}
	if m.TotalScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TotalScore))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchDuration != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchDuration))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MatchName) > 0 {
		i -= len(m.MatchName)
		copy(dAtA[i:], m.MatchName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.MatchName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x30
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x28
	}
	if m.Bounty != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Bounty))
		i--
		dAtA[i] = 0x20
	}
	if m.Hunt != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Hunt))
		i--
		dAtA[i] = 0x18
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.Table != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Table))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x30
	}
	if m.Round != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x28
	}
	if m.TimeArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TimeArenaId))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableInfoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableInfoRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableInfoRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TableDetail) > 0 {
		for iNdEx := len(m.TableDetail) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableDetail[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.StandardTableNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StandardTableNum))
		i--
		dAtA[i] = 0x10
	}
	if m.MatchNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AverageScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AverageScore))
		i--
		dAtA[i] = 0x28
	}
	if m.MinScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MinScore))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxScore != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MaxScore))
		i--
		dAtA[i] = 0x18
	}
	if m.PersonNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PersonNum))
		i--
		dAtA[i] = 0x10
	}
	if m.TableNumber != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TableNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserRecordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRecordReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRecordReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserRecordRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRecordRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRecordRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndMatchList) > 0 {
		for iNdEx := len(m.EndMatchList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EndMatchList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MatchList) > 0 {
		for iNdEx := len(m.MatchList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BonusPoolNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BonusPoolNum))
		i--
		dAtA[i] = 0x48
	}
	if m.Time != nil {
		{
			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.SigNum != nil {
		{
			size, err := m.SigNum.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ShowSingPay != nil {
		{
			size, err := m.ShowSingPay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x20
	}
	if m.TypeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EndMatchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndMatchInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndMatchInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShowSingPay != nil {
		{
			size, err := m.ShowSingPay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Reward) > 0 {
		for iNdEx := len(m.Reward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Reward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.ID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignCheckReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignCheckReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignCheckReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SelfThinsList) > 0 {
		for iNdEx := len(m.SelfThinsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SelfThinsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x28
	}
	if m.TimeArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TimeArenaId))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SignCheckRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignCheckRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignCheckRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShowSingPay != nil {
		{
			size, err := m.ShowSingPay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SignPay != nil {
		{
			size, err := m.SignPay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IsFullPay {
		i--
		if m.IsFullPay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IsFullConditon {
		i--
		if m.IsFullConditon {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SignCommonReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignCommonReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignCommonReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SignEnsureRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignEnsureRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignEnsureRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserInfo) > 0 {
		for iNdEx := len(m.UserInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.IsSign {
		i--
		if m.IsSign {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Round != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.IsFull {
		i--
		if m.IsFull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SignInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsSign {
		i--
		if m.IsSign {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserTableDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserTableDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserTableDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x28
	}
	if m.Table != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Table))
		i--
		dAtA[i] = 0x20
	}
	if m.Round != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Room) > 0 {
		i -= len(m.Room)
		copy(dAtA[i:], m.Room)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Room)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserList) > 0 {
		dAtA26 := make([]byte, len(m.UserList)*10)
		var j25 int
		for _, num1 := range m.UserList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA26[:j25])
		i = encodeVarintApi(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelSignRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelSignRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelSignRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Round != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CancelPay) > 0 {
		for iNdEx := len(m.CancelPay) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CancelPay[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IsCancel {
		i--
		if m.IsCancel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserList) > 0 {
		for iNdEx := len(m.UserList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Room) > 0 {
		i -= len(m.Room)
		copy(dAtA[i:], m.Room)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Room)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Table != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Table))
		i--
		dAtA[i] = 0x30
	}
	if m.Round != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x28
	}
	if m.TimeArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TimeArenaId))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OutNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OutNum))
		i--
		dAtA[i] = 0x20
	}
	if m.OutTimeStamp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.OutTimeStamp))
		i--
		dAtA[i] = 0x18
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.UserTableInfo) > 0 {
		for iNdEx := len(m.UserTableInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserTableInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.UploadRetry {
		i--
		if m.UploadRetry {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IsSeparateTable {
		i--
		if m.IsSeparateTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IsEnd {
		i--
		if m.IsEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OutDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RewardID) > 0 {
		i -= len(m.RewardID)
		copy(dAtA[i:], m.RewardID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RewardID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRewardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRewardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryRewardRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRewardRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRewardRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryRewardDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRewardDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRewardDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ThinsList) > 0 {
		for iNdEx := len(m.ThinsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ThinsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RewardID) > 0 {
		i -= len(m.RewardID)
		copy(dAtA[i:], m.RewardID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RewardID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ThingsDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThingsDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThingsDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Num != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShowThingsDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowThingsDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowThingsDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Num != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x18
	}
	if m.TypeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.PropID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PropID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRewardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRewardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardID) > 0 {
		i -= len(m.RewardID)
		copy(dAtA[i:], m.RewardID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RewardID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetRewardRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRewardRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRewardRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TargetTableReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetTableReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetTableReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Room) > 0 {
		i -= len(m.Room)
		copy(dAtA[i:], m.Room)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Room)))
		i--
		dAtA[i] = 0x32
	}
	if m.Table != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Table))
		i--
		dAtA[i] = 0x28
	}
	if m.Round != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TargetTableRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetTableRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetTableRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserScoreList) > 0 {
		for iNdEx := len(m.UserScoreList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserScoreList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BlindBet != nil {
		{
			size, err := m.BlindBet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableUserDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableUserDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableUserDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x20
	}
	if m.Bounty != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Bounty))
		i--
		dAtA[i] = 0x18
	}
	if m.Hunt != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Hunt))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserEnterReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserEnterReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserEnterReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserEnterRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserEnterRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserEnterRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Table != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Table))
		i--
		dAtA[i] = 0x18
	}
	if m.Round != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RoomID) > 0 {
		i -= len(m.RoomID)
		copy(dAtA[i:], m.RoomID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RoomID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlindBetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlindBetReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlindBetReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlindBetResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlindBetResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlindBetResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BlindBetList) > 0 {
		for iNdEx := len(m.BlindBetList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BlindBetList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RoomAllTableReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomAllTableReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoomAllTableReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomID) > 0 {
		i -= len(m.RoomID)
		copy(dAtA[i:], m.RoomID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RoomID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoomAllTableResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomAllTableResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoomAllTableResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MatchList) > 0 {
		for iNdEx := len(m.MatchList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *Detail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Detail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Detail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoundList) > 0 {
		for iNdEx := len(m.RoundList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoundList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoundDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoundDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoundDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TableList) > 0 {
		dAtA29 := make([]byte, len(m.TableList)*10)
		var j28 int
		for _, num1 := range m.TableList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		i -= j28
		copy(dAtA[i:], dAtA29[:j28])
		i = encodeVarintApi(dAtA, i, uint64(j28))
		i--
		dAtA[i] = 0x12
	}
	if m.Round != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserSelfRankReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSelfRankReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserSelfRankReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x28
	}
	if m.Round != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserSelfRankResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSelfRankResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserSelfRankResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SelfRank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SelfRank))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TotalNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReDistributeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReDistributeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReDistributeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomList) > 0 {
		for iNdEx := len(m.RoomList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoomList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Round != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x20
	}
	if m.ArenaId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ArenaId))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoomTableDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomTableDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoomTableDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TableList) > 0 {
		dAtA31 := make([]byte, len(m.TableList)*10)
		var j30 int
		for _, num1 := range m.TableList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		i -= j30
		copy(dAtA[i:], dAtA31[:j30])
		i = encodeVarintApi(dAtA, i, uint64(j30))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Room) > 0 {
		i -= len(m.Room)
		copy(dAtA[i:], m.Room)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Room)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReDistributeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReDistributeResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReDistributeResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserTableInfo) > 0 {
		for iNdEx := len(m.UserTableInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserTableInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	return len(dAtA) - i, nil
}

func (m *HelloReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelloReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HelloReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HelloResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelloResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HelloResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MatchList) > 0 {
		for _, e := range m.MatchList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	if m.TypeID != 0 {
		n += 1 + sovApi(uint64(m.TypeID))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.LimitTimes != 0 {
		n += 1 + sovApi(uint64(m.LimitTimes))
	}
	if m.Order != 0 {
		n += 1 + sovApi(uint64(m.Order))
	}
	if m.ShowSingPay != nil {
		l = m.ShowSingPay.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.SignCondition) > 0 {
		for _, e := range m.SignCondition {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.SigNum != nil {
		l = m.SigNum.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.Date != nil {
		l = m.Date.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NowRound != 0 {
		n += 1 + sovApi(uint64(m.NowRound))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BonusPoolNum != 0 {
		n += 1 + sovApi(uint64(m.BonusPoolNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TimeDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BeginTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignPayDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchTimes != 0 {
		n += 1 + sovApi(uint64(m.MatchTimes))
	}
	if len(m.Pay) > 0 {
		for _, e := range m.Pay {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowPayDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchTimes != 0 {
		n += 1 + sovApi(uint64(m.MatchTimes))
	}
	if len(m.Pay) > 0 {
		for _, e := range m.Pay {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DateDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Property)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Week) > 0 {
		l = 0
		for _, e := range m.Week {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DetailReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.TimeArenaId != 0 {
		n += 1 + sovApi(uint64(m.TimeArenaId))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DetailRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	if m.BuyLimit != 0 {
		n += 1 + sovApi(uint64(m.BuyLimit))
	}
	if m.SignLimit != 0 {
		n += 1 + sovApi(uint64(m.SignLimit))
	}
	l = len(m.EnterDeadline)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchTime != nil {
		l = m.MatchTime.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ShowSingPay != nil {
		l = m.ShowSingPay.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.SignCondition) > 0 {
		for _, e := range m.SignCondition {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.SigNum != nil {
		l = m.SigNum.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BlindBet != nil {
		l = m.BlindBet.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Scoreboard != nil {
		l = m.Scoreboard.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.InitScoreBoard != 0 {
		n += 1 + sovApi(uint64(m.InitScoreBoard))
	}
	if m.NowRound != 0 {
		n += 1 + sovApi(uint64(m.NowRound))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.MatchDuration != 0 {
		n += 1 + sovApi(uint64(m.MatchDuration))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlindBetDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NowBet != nil {
		l = m.NowBet.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NextBet != nil {
		l = m.NextBet.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.RiseBetTime != 0 {
		n += 1 + sovApi(uint64(m.RiseBetTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BetDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BetLevel != 0 {
		n += 1 + sovApi(uint64(m.BetLevel))
	}
	if m.MaxBet != 0 {
		n += 1 + sovApi(uint64(m.MaxBet))
	}
	if m.MinBet != 0 {
		n += 1 + sovApi(uint64(m.MinBet))
	}
	if m.FrontBet != 0 {
		n += 1 + sovApi(uint64(m.FrontBet))
	}
	if m.BlindTimeInterval != 0 {
		n += 1 + sovApi(uint64(m.BlindTimeInterval))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BoardDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxScore != 0 {
		n += 1 + sovApi(uint64(m.MaxScore))
	}
	if m.MinScore != 0 {
		n += 1 + sovApi(uint64(m.MinScore))
	}
	if m.AverageScore != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.Round != 0 {
		n += 1 + sovApi(uint64(m.Round))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardInfoRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RewardPool != 0 {
		n += 1 + sovApi(uint64(m.RewardPool))
	}
	if m.PersonNum != 0 {
		n += 1 + sovApi(uint64(m.PersonNum))
	}
	if m.TotalRewardNum != 0 {
		n += 1 + sovApi(uint64(m.TotalRewardNum))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardInfoDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rank) > 0 {
		l = 0
		for _, e := range m.Rank {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardThingsDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.Rate != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rank) > 0 {
		l = 0
		for _, e := range m.Rank {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.TimeArenaId != 0 {
		n += 1 + sovApi(uint64(m.TimeArenaId))
	}
	if m.Round != 0 {
		n += 1 + sovApi(uint64(m.Round))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.BeginPoint != 0 {
		n += 1 + sovApi(uint64(m.BeginPoint))
	}
	if m.EndPoint != 0 {
		n += 1 + sovApi(uint64(m.EndPoint))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserInfoRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MatchName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchDuration != 0 {
		n += 1 + sovApi(uint64(m.MatchDuration))
	}
	if m.TotalScore != 0 {
		n += 1 + sovApi(uint64(m.TotalScore))
	}
	if m.AverageScore != 0 {
		n += 5
	}
	if m.MaxScore != 0 {
		n += 1 + sovApi(uint64(m.MaxScore))
	}
	if m.MinScore != 0 {
		n += 1 + sovApi(uint64(m.MinScore))
	}
	if m.BonusNum != 0 {
		n += 1 + sovApi(uint64(m.BonusNum))
	}
	if m.TotalNum != 0 {
		n += 1 + sovApi(uint64(m.TotalNum))
	}
	if m.PersonNum != 0 {
		n += 1 + sovApi(uint64(m.PersonNum))
	}
	if m.SelfInfo != nil {
		l = m.SelfInfo.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.UserScoreList) > 0 {
		for _, e := range m.UserScoreList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Table != 0 {
		n += 1 + sovApi(uint64(m.Table))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.Hunt != 0 {
		n += 1 + sovApi(uint64(m.Hunt))
	}
	if m.Bounty != 0 {
		n += 1 + sovApi(uint64(m.Bounty))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.TimeArenaId != 0 {
		n += 1 + sovApi(uint64(m.TimeArenaId))
	}
	if m.Round != 0 {
		n += 1 + sovApi(uint64(m.Round))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableInfoRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchNum != 0 {
		n += 1 + sovApi(uint64(m.MatchNum))
	}
	if m.StandardTableNum != 0 {
		n += 1 + sovApi(uint64(m.StandardTableNum))
	}
	if len(m.TableDetail) > 0 {
		for _, e := range m.TableDetail {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableNumber != 0 {
		n += 1 + sovApi(uint64(m.TableNumber))
	}
	if m.PersonNum != 0 {
		n += 1 + sovApi(uint64(m.PersonNum))
	}
	if m.MaxScore != 0 {
		n += 1 + sovApi(uint64(m.MaxScore))
	}
	if m.MinScore != 0 {
		n += 1 + sovApi(uint64(m.MinScore))
	}
	if m.AverageScore != 0 {
		n += 1 + sovApi(uint64(m.AverageScore))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserRecordReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserRecordRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MatchList) > 0 {
		for _, e := range m.MatchList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.EndMatchList) > 0 {
		for _, e := range m.EndMatchList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	if m.TypeID != 0 {
		n += 1 + sovApi(uint64(m.TypeID))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.ShowSingPay != nil {
		l = m.ShowSingPay.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.SigNum != nil {
		l = m.SigNum.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BonusPoolNum != 0 {
		n += 1 + sovApi(uint64(m.BonusPoolNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EndMatchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if len(m.Reward) > 0 {
		for _, e := range m.Reward {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.ShowSingPay != nil {
		l = m.ShowSingPay.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignCheckReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.TimeArenaId != 0 {
		n += 1 + sovApi(uint64(m.TimeArenaId))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if len(m.SelfThinsList) > 0 {
		for _, e := range m.SelfThinsList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignCheckRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.IsFullConditon {
		n += 2
	}
	if m.IsFullPay {
		n += 2
	}
	if m.SignPay != nil {
		l = m.SignPay.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ShowSingPay != nil {
		l = m.ShowSingPay.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignCommonReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignEnsureRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsFull {
		n += 2
	}
	if m.Round != 0 {
		n += 1 + sovApi(uint64(m.Round))
	}
	if m.IsSign {
		n += 2
	}
	if len(m.UserInfo) > 0 {
		for _, e := range m.UserInfo {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.IsSign {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserTableDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserList) > 0 {
		l = 0
		for _, e := range m.UserList {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	l = len(m.Room)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Round != 0 {
		n += 1 + sovApi(uint64(m.Round))
	}
	if m.Table != 0 {
		n += 1 + sovApi(uint64(m.Table))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelSignRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.IsCancel {
		n += 2
	}
	if len(m.CancelPay) > 0 {
		for _, e := range m.CancelPay {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Round != 0 {
		n += 1 + sovApi(uint64(m.Round))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.TimeArenaId != 0 {
		n += 1 + sovApi(uint64(m.TimeArenaId))
	}
	if m.Round != 0 {
		n += 1 + sovApi(uint64(m.Round))
	}
	if m.Table != 0 {
		n += 1 + sovApi(uint64(m.Table))
	}
	l = len(m.Room)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.UserList) > 0 {
		for _, e := range m.UserList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.OutTimeStamp != 0 {
		n += 1 + sovApi(uint64(m.OutTimeStamp))
	}
	if m.OutNum != 0 {
		n += 1 + sovApi(uint64(m.OutNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsEnd {
		n += 2
	}
	if m.IsSeparateTable {
		n += 2
	}
	if m.UploadRetry {
		n += 2
	}
	if len(m.UserTableInfo) > 0 {
		for _, e := range m.UserTableInfo {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OutDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	l = len(m.RewardID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryRewardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryRewardRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryRewardDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RewardID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if len(m.ThinsList) > 0 {
		for _, e := range m.ThinsList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ThingsDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowThingsDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PropID != 0 {
		n += 1 + sovApi(uint64(m.PropID))
	}
	if m.TypeID != 0 {
		n += 1 + sovApi(uint64(m.TypeID))
	}
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRewardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	l = len(m.RewardID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRewardRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetTableReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.Round != 0 {
		n += 1 + sovApi(uint64(m.Round))
	}
	if m.Table != 0 {
		n += 1 + sovApi(uint64(m.Table))
	}
	l = len(m.Room)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetTableRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlindBet != nil {
		l = m.BlindBet.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.UserScoreList) > 0 {
		for _, e := range m.UserScoreList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableUserDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.Hunt != 0 {
		n += 1 + sovApi(uint64(m.Hunt))
	}
	if m.Bounty != 0 {
		n += 1 + sovApi(uint64(m.Bounty))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserEnterReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserEnterRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Round != 0 {
		n += 1 + sovApi(uint64(m.Round))
	}
	if m.Table != 0 {
		n += 1 + sovApi(uint64(m.Table))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlindBetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlindBetResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BlindBetList) > 0 {
		for _, e := range m.BlindBetList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomAllTableReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	l = len(m.RoomID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomAllTableResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MatchList) > 0 {
		for _, e := range m.MatchList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Detail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if len(m.RoundList) > 0 {
		for _, e := range m.RoundList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoundDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Round != 0 {
		n += 1 + sovApi(uint64(m.Round))
	}
	if len(m.TableList) > 0 {
		l = 0
		for _, e := range m.TableList {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserSelfRankReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.Round != 0 {
		n += 1 + sovApi(uint64(m.Round))
	}
	if m.UserID != 0 {
		n += 1 + sovApi(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserSelfRankResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalNum != 0 {
		n += 1 + sovApi(uint64(m.TotalNum))
	}
	if m.SelfRank != 0 {
		n += 1 + sovApi(uint64(m.SelfRank))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReDistributeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.ArenaId != 0 {
		n += 1 + sovApi(uint64(m.ArenaId))
	}
	if m.Round != 0 {
		n += 1 + sovApi(uint64(m.Round))
	}
	if len(m.RoomList) > 0 {
		for _, e := range m.RoomList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomTableDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Room)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.TableList) > 0 {
		l = 0
		for _, e := range m.TableList {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReDistributeResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserTableInfo) > 0 {
		for _, e := range m.UserTableInfo {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HelloReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HelloResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchList = append(m.MatchList, &MatchDetail{})
			if err := m.MatchList[len(m.MatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitTimes", wireType)
			}
			m.LimitTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowSingPay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowSingPay == nil {
				m.ShowSingPay = &ShowPayDetail{}
			}
			if err := m.ShowSingPay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignCondition = append(m.SignCondition, &ThingsDetail{})
			if err := m.SignCondition[len(m.SignCondition)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigNum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigNum == nil {
				m.SigNum = &SignDetail{}
			}
			if err := m.SigNum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= MatchStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Date == nil {
				m.Date = &DateDetail{}
			}
			if err := m.Date.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowRound", wireType)
			}
			m.NowRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowRound |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &TimeDetail{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusPoolNum", wireType)
			}
			m.BonusPoolNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BonusPoolNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BeginTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignPayDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignPayDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignPayDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchTimes", wireType)
			}
			m.MatchTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pay = append(m.Pay, &ThingsDetail{})
			if err := m.Pay[len(m.Pay)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowPayDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowPayDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowPayDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchTimes", wireType)
			}
			m.MatchTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pay = append(m.Pay, &ShowThingsDetail{})
			if err := m.Pay[len(m.Pay)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DateDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DateDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DateDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Property", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Property = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Week = append(m.Week, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Week) == 0 {
					m.Week = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Week = append(m.Week, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Week", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetailReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetailReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetailReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeArenaId", wireType)
			}
			m.TimeArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetailRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetailRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetailRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyLimit", wireType)
			}
			m.BuyLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignLimit", wireType)
			}
			m.SignLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterDeadline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnterDeadline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchTime == nil {
				m.MatchTime = &TimeDetail{}
			}
			if err := m.MatchTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowSingPay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowSingPay == nil {
				m.ShowSingPay = &ShowPayDetail{}
			}
			if err := m.ShowSingPay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignCondition = append(m.SignCondition, &ThingsDetail{})
			if err := m.SignCondition[len(m.SignCondition)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigNum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigNum == nil {
				m.SigNum = &SignDetail{}
			}
			if err := m.SigNum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindBet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlindBet == nil {
				m.BlindBet = &BlindBetDetail{}
			}
			if err := m.BlindBet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scoreboard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scoreboard == nil {
				m.Scoreboard = &BoardDetail{}
			}
			if err := m.Scoreboard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitScoreBoard", wireType)
			}
			m.InitScoreBoard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitScoreBoard |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowRound", wireType)
			}
			m.NowRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowRound |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= MatchStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchDuration", wireType)
			}
			m.MatchDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlindBetDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlindBetDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlindBetDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowBet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NowBet == nil {
				m.NowBet = &BetDetail{}
			}
			if err := m.NowBet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextBet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextBet == nil {
				m.NextBet = &BetDetail{}
			}
			if err := m.NextBet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiseBetTime", wireType)
			}
			m.RiseBetTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RiseBetTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BetDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BetDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BetDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetLevel", wireType)
			}
			m.BetLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BetLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBet", wireType)
			}
			m.MaxBet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBet |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBet", wireType)
			}
			m.MinBet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinBet |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrontBet", wireType)
			}
			m.FrontBet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrontBet |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindTimeInterval", wireType)
			}
			m.BlindTimeInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlindTimeInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoardDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoardDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoardDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxScore", wireType)
			}
			m.MaxScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinScore", wireType)
			}
			m.MinScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AverageScore = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardInfoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardInfoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardInfoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPool", wireType)
			}
			m.RewardPool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardPool |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonNum", wireType)
			}
			m.PersonNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PersonNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRewardNum", wireType)
			}
			m.TotalRewardNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRewardNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &RewardInfoDetail{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardInfoDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardInfoDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardInfoDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Rank = append(m.Rank, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Rank) == 0 {
					m.Rank = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Rank = append(m.Rank, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &RewardThingsDetail{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardThingsDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardThingsDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardThingsDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rate = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Rank = append(m.Rank, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Rank) == 0 {
					m.Rank = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Rank = append(m.Rank, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ThingsDetail{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeArenaId", wireType)
			}
			m.TimeArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginPoint", wireType)
			}
			m.BeginPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginPoint |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPoint", wireType)
			}
			m.EndPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndPoint |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserInfoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserInfoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserInfoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchDuration", wireType)
			}
			m.MatchDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalScore", wireType)
			}
			m.TotalScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AverageScore = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxScore", wireType)
			}
			m.MaxScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinScore", wireType)
			}
			m.MinScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusNum", wireType)
			}
			m.BonusNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BonusNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNum", wireType)
			}
			m.TotalNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonNum", wireType)
			}
			m.PersonNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PersonNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelfInfo == nil {
				m.SelfInfo = &UserDetail{}
			}
			if err := m.SelfInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserScoreList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserScoreList = append(m.UserScoreList, &UserDetail{})
			if err := m.UserScoreList[len(m.UserScoreList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			m.Table = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Table |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hunt", wireType)
			}
			m.Hunt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hunt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounty", wireType)
			}
			m.Bounty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bounty |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeArenaId", wireType)
			}
			m.TimeArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableInfoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableInfoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableInfoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchNum", wireType)
			}
			m.MatchNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardTableNum", wireType)
			}
			m.StandardTableNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StandardTableNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableDetail = append(m.TableDetail, &TableDetail{})
			if err := m.TableDetail[len(m.TableDetail)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableNumber", wireType)
			}
			m.TableNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonNum", wireType)
			}
			m.PersonNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PersonNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxScore", wireType)
			}
			m.MaxScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinScore", wireType)
			}
			m.MinScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageScore", wireType)
			}
			m.AverageScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AverageScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRecordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRecordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRecordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRecordRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRecordRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRecordRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchList = append(m.MatchList, &MatchInfo{})
			if err := m.MatchList[len(m.MatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndMatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndMatchList = append(m.EndMatchList, &EndMatchInfo{})
			if err := m.EndMatchList[len(m.EndMatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowSingPay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowSingPay == nil {
				m.ShowSingPay = &ShowPayDetail{}
			}
			if err := m.ShowSingPay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigNum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigNum == nil {
				m.SigNum = &SignDetail{}
			}
			if err := m.SigNum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= MatchStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &TimeDetail{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusPoolNum", wireType)
			}
			m.BonusPoolNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BonusPoolNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndMatchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndMatchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndMatchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reward = append(m.Reward, &ThingsDetail{})
			if err := m.Reward[len(m.Reward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowSingPay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowSingPay == nil {
				m.ShowSingPay = &ShowPayDetail{}
			}
			if err := m.ShowSingPay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignCheckReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignCheckReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignCheckReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeArenaId", wireType)
			}
			m.TimeArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfThinsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelfThinsList = append(m.SelfThinsList, &ThingsDetail{})
			if err := m.SelfThinsList[len(m.SelfThinsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignCheckRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignCheckRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignCheckRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFullConditon", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFullConditon = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFullPay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFullPay = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignPay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignPay == nil {
				m.SignPay = &SignPayDetail{}
			}
			if err := m.SignPay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowSingPay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowSingPay == nil {
				m.ShowSingPay = &ShowPayDetail{}
			}
			if err := m.ShowSingPay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignCommonReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignCommonReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignCommonReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignEnsureRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignEnsureRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignEnsureRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFull = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSign", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSign = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserInfo = append(m.UserInfo, &UserTableDetail{})
			if err := m.UserInfo[len(m.UserInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSign", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSign = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserTableDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserTableDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserTableDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserList = append(m.UserList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserList) == 0 {
					m.UserList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserList = append(m.UserList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserList", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Room = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			m.Table = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Table |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelSignRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelSignRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelSignRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCancel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCancel = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelPay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelPay = append(m.CancelPay, &ThingsDetail{})
			if err := m.CancelPay[len(m.CancelPay)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeArenaId", wireType)
			}
			m.TimeArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			m.Table = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Table |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Room = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserList = append(m.UserList, &UserInfo{})
			if err := m.UserList[len(m.UserList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTimeStamp", wireType)
			}
			m.OutTimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutTimeStamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutNum", wireType)
			}
			m.OutNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSeparateTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSeparateTable = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadRetry", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UploadRetry = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTableInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserTableInfo = append(m.UserTableInfo, &UserTableDetail{})
			if err := m.UserTableInfo[len(m.UserTableInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &OutDetail{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ThingsDetail{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRewardRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRewardRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRewardRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &QueryRewardDetail{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRewardDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRewardDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRewardDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThinsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThinsList = append(m.ThinsList, &ThingsDetail{})
			if err := m.ThinsList[len(m.ThinsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThingsDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThingsDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThingsDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowThingsDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowThingsDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowThingsDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropID", wireType)
			}
			m.PropID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PropID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= PayTypeCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRewardRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRewardRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRewardRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ThingsDetail{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetTableReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetTableReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetTableReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			m.Table = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Table |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Room = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetTableRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetTableRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetTableRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindBet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlindBet == nil {
				m.BlindBet = &BlindBetDetail{}
			}
			if err := m.BlindBet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserScoreList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserScoreList = append(m.UserScoreList, &TableUserDetail{})
			if err := m.UserScoreList[len(m.UserScoreList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableUserDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableUserDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableUserDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hunt", wireType)
			}
			m.Hunt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hunt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounty", wireType)
			}
			m.Bounty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bounty |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserEnterReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserEnterReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserEnterReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserEnterRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserEnterRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserEnterRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			m.Table = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Table |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlindBetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlindBetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlindBetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlindBetResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlindBetResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlindBetResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindBetList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlindBetList = append(m.BlindBetList, &BetDetail{})
			if err := m.BlindBetList[len(m.BlindBetList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomAllTableReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomAllTableReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomAllTableReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomAllTableResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomAllTableResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomAllTableResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchList = append(m.MatchList, &Detail{})
			if err := m.MatchList[len(m.MatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Detail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoundList = append(m.RoundList, &RoundDetail{})
			if err := m.RoundList[len(m.RoundList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoundDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoundDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoundDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TableList = append(m.TableList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TableList) == 0 {
					m.TableList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TableList = append(m.TableList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TableList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSelfRankReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSelfRankReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSelfRankReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSelfRankResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSelfRankResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSelfRankResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNum", wireType)
			}
			m.TotalNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfRank", wireType)
			}
			m.SelfRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfRank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReDistributeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReDistributeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReDistributeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaId", wireType)
			}
			m.ArenaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomList = append(m.RoomList, &RoomTableDetail{})
			if err := m.RoomList[len(m.RoomList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomTableDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomTableDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomTableDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Room = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TableList = append(m.TableList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TableList) == 0 {
					m.TableList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TableList = append(m.TableList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TableList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReDistributeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReDistributeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReDistributeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTableInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserTableInfo = append(m.UserTableInfo, &UserTableDetail{})
			if err := m.UserTableInfo[len(m.UserTableInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelloReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HelloReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HelloReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelloResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HelloResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HelloResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
